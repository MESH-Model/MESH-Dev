      PROGRAM fst_2_r2c
      IMPLICIT NONE
*     
*     Conversion de fichiers du format STD de RPN au format R2C de EnSim
*     001 - 2006-12-07 Vincent Fortin
*     002 - 2006-12-11 Vincent Fortin - ajout d'un STOP apres affichage de l'aide
*                                     - ajout du parametre "horaire"
*                                     - retrait de l'impression de l'unite de mesure
*     003 - 2007-01-31 Vincent Fortin Incrementation du compteur de frames apres
*                                     l'ecriture de l'entete plutot qu'a la fin
*                                     de la boucle de lecture pour corriger bogue
*                                     en mode horaire
*     004 - 2007-02-01 Vincent Fortin Modification du calcul de nhdebut en mode horaire
*                                     pour tenir compte d'enregistrements avec des
*                                     dateo differents
*     005 - 2007-02-07 Vincent Fortin Augmentation de la taille du champ d'ecriture
*     006 - 2007-02-26 Vincent Fortin Augmentation du nombre de decimales de la
*                                     localisation de la grille
*     007 - 2007-03-06 Isabelle Dore  Correction d'un bogue dans le calcul de xOrigin
*                                     pour s'assurer que xOrigin soit entre -180 et 180
*     008 - 2007-04-23 Vincent Fortin Deplacement de xOrigin et yOrigin d'un demi point
*                                     de grille car c'est le coin inferieur gauche du
*                                     pave associe au point de grille inferieur gauche
*     009 - 2007-04-28 Vincent Fortin On n'impose pas une grille X pour
*                                     les tictacs
*
*     Utilisation:
*
*     fst_2_r2c <fst> <r2c> <nomvar_fst> <ip1> [<nomvar_r2c>] [horaire]
*
*     Exemple:
*     fst_2_r2c 040701_rff.fst 040701_rff.r2c RFF channel_inflow
*
*     Notes:
*     1. Seule la projection lat-lon sur grille Z est supportee
*     2. Si <nomvar_r2c> est omis, on utilise nomvar_fst a la place
*     3. La resolution maximale de la grille est de 0.0001 degre
*     4. Si on indique "horaire", le programme creera un enregistrement
*        par heure en recopiant au besoin des enregistrements du fichier
*        standard
*
*     Compilation:
*
*     r.compile -src fst_2_r2c.ftn -o fst_2_r2c -librmn
*
*     Parametres de la ligne de commande
*
      CHARACTER*1024 filein,fileout ! Fichier d'entree et de sortie
      CHARACTER*4 nomvar ! nom de la variable dans le fichier standard
      CHARACTER*8 strip1 ! ip1 desire dans le fichier standard
      CHARACTER*128 name ! nom de la variable dans le fichier r2c
      LOGICAL horaire ! indique si on doit creer un enregistrement par heure
      INTEGER iargc ! nombre de parametres sur la ligne de commande
*
*     API pour les fichiers standards
*
      INTEGER fnom,fstouv,fclos,fstfrm,fstlir,fstprm,fstinf,fstsui,fstluk
      EXTERNAL fnom,fstouv,fclos,fstfrm,fstlir,fstprm,fstinf,fstsui,fstluk
*
*     Fonctions de gestion de date de ARMNLIB
*      
      INTEGER newdate
      EXTERNAL newdate,incdatr,difdat
*
*     Gestion du temps
*
      INTEGER today(3),now(3) ! date et heure courantes
      INTEGER yyyymmdd,hhmmssHH ! date et heure d'emission lue au fichier
      CHARACTER*10 strymd ! date d'emission convertie en chaine
      CHARACTER*12 strhms ! heure d'emission convertie en chaine
      INTEGER datev ! date et heure valide au format CMC (date d'emission + deet*npas)
      INTEGER dateoprec ! valeur precedente de la date d'emission au format CMC
      INTEGER ip2prec ! valeur precedente de ip2
      INTEGER ecartdateo ! ecart entre dateo pour deux enregistrements successifs
      REAL*8 nhours ! nombre d'heures entre date d'emission et date valide
      REAL*8 nhdebut,nhfin ! bloc d'heures dans le fichier r2c
      ! pour un enregistrement dans le fichier standard
*
*     Variables necessaires pour les appels a fstprm
*      
      INTEGER ier,key,dateo,deet,npas,ni,nj,nk,nbits,datyp
      INTEGER ip1,ip2,ip3,ig1,ig2,ig3,ig4
      INTEGER swa,lng,dltf,ubc,extra1,extra2,extra3
      CHARACTER*1 typvar,grtyp
      CHARACTER*8 etiket
*
*     Unites d'entree et de sortie
*
      INTEGER iun,iunout
*
*     Parametres de la grille
*      
      REAL lon0,lat0,deltax,deltay
*
*     Format d'impression des donnees
*
      CHARACTER*128 strfmt
*
*     Compteurs
*      
      INTEGER i,j,nrecs
*
*     Buffer
*
      CHARACTER*1024 buffer
*
*     Tableaux contenant les latitudes, longitudes et les donnees
*
      REAL, DIMENSION(:), ALLOCATABLE :: lat,lon
      REAL, DIMENSION(:,:), ALLOCATABLE :: fld
*
*     Unites d'entree et de sortie
*
      PARAMETER(iun=1,iunout=2)
*
*     Lecture de la ligne de commande
*   
      IF((IARGC().LT.4).OR.(IARGC().GT.6))THEN
        PRINT*,'fst_2_r2c rev 008'
        PRINT*,' '
        PRINT*,'Conversion du format FST de RPN au format R2C de Ensim'
        PRINT*,' '
        PRINT*,'Vincent Fortin, 2007-04-23'
        PRINT*,'vincent.fortin@ec.gc.ca'
        PRINT*,' '
        PRINT*,'Utilisation:'
        PRINT*,' '
        PRINT*,
     &  'fst_2_r2c <fst> <r2c> <nomvar_fst> <ip1> [<nomvar_r2c>] [horaire]'
        PRINT*,' '
        PRINT*,'Notes:'
        PRINT*,'1. Seule la projection lat-lon sur grille Z est supportee'
        PRINT*,'2. Si <nomvar_r2c> est omis, on utilise nomvar_fst a la place'
        PRINT*,'3. La resolution maximale de la grille est de 0.0001 degre'
        STOP
      ENDIF
      CALL GETARG(1,filein)
      CALL GETARG(2,fileout)
      CALL GETARG(3,nomvar)
      CALL GETARG(4,strip1)
      READ(strip1,*)ip1
      IF(IARGC().LT.5)THEN
        name=nomvar
        horaire=.FALSE.
      ELSE
        CALL GETARG(5,name)
        IF(IARGC().GE.6)THEN
          CALL GETARG(6,buffer)
          horaire=buffer(1:LEN_TRIM(buffer)).EQ.'horaire'
        ELSE
          horaire=.FALSE.
        ENDIF
      ENDIF
*
*     Ouverture des fichiers
*
      ier=fnom(iun,filein,'STD+RND',0)
      IF(ier.lt.0)THEN
        PRINT*,'Fatal error while opening the file (FNOM)'
        STOP
      ENDIF
      ier=fstouv(iun,'RND')
      IF(ier.LT.0)THEN
        PRINT*, 'Cannot open unit:', iun, 
     *          ' in random access mode (FSTOUV)'
        STOP
      ENDIF
      OPEN(UNIT=iunout,FILE=fileout)
*
*     Recherche du premier enregistrement pour obtenir ni et nj
*
      key = fstinf(iun,ni,nj,nk,-1,'',ip1,-1,-1,'',nomvar)
      IF(key.LT.0)THEN
        PRINT*,'Aucun enregistrement ',nomvar,' dans le fichier'
        STOP
      ENDIF
*
*     Dimensionnement des tableaux en consequence
*      
      ALLOCATE(fld(ni,nj))
      ALLOCATE(lon(MAX(ni,nj)))
      ALLOCATE(lat(MAX(ni,nj)))
*
*     Lecture des enregistrements positionnels
*      
      ier=fstlir(lat,iun,1,nj,1,-1,'',-1,-1,-1,'X','^^')
      IF(ier.LT.0)THEN
        ier=fstlir(lat,iun,ni,nj,1,-1,'',-1,-1,-1,-1,'^^')
      ENDIF
      IF(ier.LT.0)THEN
        PRINT*,'Enregistrement positionnel ^^ manquant'
        STOP
      ENDIF
      ier=fstlir(lon,iun,ni,1,1,-1,'',-1,-1,-1,'X','>>')
      IF(ier.LT.0)THEN
        ier=fstlir(lat,iun,ni,nj,1,-1,'',-1,-1,-1,-1,'^^')
      ENDIF
      IF(ier.LT.0)THEN
        PRINT*,'Enregistrement positionnel >> manquant'
        STOP
      ENDIF
*
*     Calcul du pas de la grille
*     On arrondit le pas a la septieme decimale
*      
      deltay=(lat(nj)-lat(1))/(nj-1)
      deltay=nint(deltay*1E7)/1E7
      deltax=(lon(ni)-lon(1))/(ni-1)
      deltax=nint(deltax*1E7)/1E7
*
*     Longitude du premier point
*     que l'on limite entre -180 et +180
*
      IF(lon(1).GT.180)THEN
        lon0=lon(1)-360
        lat0=lat(1)
      ELSE
        lon0=lon(1)
        lat0=lat(1)
      ENDIF
*
*     On enleve un demi point de grille
*     pour obtenir xOrigin et yOrigin
*      
      lon0=lon0-deltax/2
      lat0=lat0-deltay/2
*
*     On obtient la date et l'heure courante
*      
      call idate(today)
      call itime(now)
*
*     On peut maintenant ecrire l'entete du fichier
*      
      WRITE(iunout,'((A))'),'########################################'
      WRITE(iunout,'((A))'),':FileType r2c  ASCII  EnSim 1.0         '
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'((A))'),'# DataType               2D Rect Cell   '
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'((A))'),':Application             EnSimHydrologic'
      WRITE(iunout,'((A))'),':Version                 2.1.23         '
      WRITE(iunout,'((A))'),':WrittenBy               fst_2_r2c      '
      WRITE(iunout,'(A,I4,A,I2,A,I2,I3,A,I2)'),
     1      ':CreationDate            ',
     2      2000+today(3),'-',today(2),'-',today(1),
     3      now(1),':',now(2)
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'((A))'),'#---------------------------------------'
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'(A,A)'),':Name                   ',
     1      name(1:LEN_TRIM(name))
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'((A))'),':Projection         LATLONG             '
      WRITE(iunout,'((A))'),':Ellipsoid          GRS80               '
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'(A,F9.4)'),':xOrigin                 ',
     1      lon0
      WRITE(iunout,'(A,F9.4)'),':yOrigin                 ',
     1      lat0
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'(A,A)'),':SourceFile                   ',
     1      filein(1:LEN_TRIM(filein))
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'(A,A)'),':AttributeName 1  ',
     1      name(1:LEN_TRIM(name))
c      WRITE(iunout,'((A))'),':AttributeUnits   mm                    '
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'(A,I)'),':xCount                       ',ni
      WRITE(iunout,'(A,I)'),':yCount                       ',nj
      WRITE(iunout,'(A,F12.7)'),':xDelta                    ',deltax
      WRITE(iunout,'(A,F12.7)'),':yDelta                    ',deltay
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'((A))'),'#                                       '
      WRITE(iunout,'((A))'),':endHeader                              '
*
*     On construit la chaine contenant le format d'ecriture des donnees
*      
      WRITE(strfmt,'(A,I,A)')'(',ni,'F15.5)'
*
*     Lecture des donnees du premier enregistrement
*
      key = fstlir(fld,iun,ni,nj,1,-1,'',ip1,-1,-1,'',nomvar)
*
*     On utilise fstprm pour obtenir la date d'emission
*
      ier=fstprm(key,dateo,deet,npas,ni,nj,nk,nbits,datyp,
     1           ip1,ip2,ip3,typvar,nomvar,etiket,grtyp, 
     2          ig1,ig2,ig3,ig4,
     3           swa,lng,dltf,ubc,extra1,extra2,extra3)
      nrecs=1
      dateoprec=dateo
      ip2prec=ip2
      DO
*      
*       On ajoute deet*npas a la date d'emission
*       pour obtenir la date valide
*
        IF(horaire)THEN
          CALL difdat(dateo,dateoprec,ecartdateo)
          nhdebut=ip2prec+1-ecartdateo
	  nhfin=ip2
        ELSE
          nhdebut=deet*npas/3600.0
	  nhfin=nhdebut
        ENDIF
        DO nhours=nhdebut,nhfin
          CALL incdatr(datev,dateo,nhours)
*
*         On construit une chaine de caractere
*         de format AAAA/MM/JJ HH:MM:SS.000
*         a partir de la date valide
*
          ier=newdate(datev,yyyymmdd,hhmmssHH,-3)
          WRITE(strymd,'(I8)'),yyyymmdd
          strymd=strymd(1:4)//'/'//strymd(5:6)//'/'//strymd(7:8)
          WRITE(strhms,'(I8)'),hhmmssHH
          DO i=1,8
            IF(strhms(i:i).EQ.' ')THEN
              strhms(i:i)='0'
            ENDIF
          ENDDO
          strhms=strhms(1:2)//':'//strhms(3:4)//':'//strhms(5:6)//'.000'
*
*         On ecrit l'entete de l'enregistrement
*
          WRITE(iunout,'(A,I8,I8,A,A,A,A,A)'),
     1          ':Frame ',nrecs,nrecs,' "',strymd,' ',strhms,'"'
*
*         On incremente le compteur de frames
*
          nrecs=nrecs+1
*
*         Maintenant on ecrit les donnees
*
          DO j=1,nj
            WRITE(iunout,strfmt)(fld(i,j),i=1,ni)
          ENDDO
*
*         On ecrit :EndFrame pour terminer l'enregistrement
*
          WRITE(iunout,'(A)')':EndFrame'
        ENDDO
*
*       On lit les donnees de l'enregistrement suivant
*       Si on a rien trouve on quitte la boucle
*
        key = fstsui(iun,ni,nj,nk)
        IF(key.LT.0)GO TO 100
        ier = fstluk(fld,key,ni,nj,nk)
        IF(ier.LT.0)GO TO 100
*
*       On utilise fstprm pour obtenir la date d'emission
*	
        dateoprec=dateo
        ip2prec=ip2
        ier = fstprm(key,dateo,deet,npas,ni,nj,nk,nbits,datyp,
     1           ip1,ip2,ip3,typvar,nomvar,etiket,grtyp, 
     2           ig1,ig2,ig3,ig4,
     3           swa,lng,dltf,ubc,extra1,extra2,extra3)
        IF(ier.LT.0)GO TO 100
      ENDDO
100   CONTINUE
*
*     On libere la memoire allouee dynamiquement
*
      DEALLOCATE(lon)
      DEALLOCATE(lat)
      DEALLOCATE(fld)
*
*     On ferme les fichiers
*
      ier = fstfrm(iun)
      ier = fclos(iun)
      CLOSE(UNIT=iunout,STATUS='keep')
      STOP
      END
