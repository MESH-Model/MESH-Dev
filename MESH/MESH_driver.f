      PROGRAM RUNCLASS

C       MESH DRIVER
C
C
C     * AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
C     * MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
C       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO

C=======================================================================
C     * DIMENSION STATEMENTS.

C     * FIRST SET OF DEFINITIONS:
C     * BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
C     * VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
C     * THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
C     * MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
C     * "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
C     * A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
C     * ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
C     * GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
C     * DIAGNOSTIC VARIABLES.
C
C     * THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
C     * REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
C     * LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
C     * NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
C     * SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
C     * ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
C     * NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
C     * VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
C     * DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
C     * THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
C     * "ROW" VARIABLES.
C

CDAN  USE RTE SUBROUTINES FOR READING EVENT FILE AND SHD FILE, AND 
CDAN  WRITING R2C-FORMAT OUTPUT FILES
      USE AREA_WATFLOOD
      USE EF_MODULE

      IMPLICIT NONE
C
C     * INTEGER CONSTANTS.
!     FUTUREDO: Anything using NLAT needs to be allocatable.
!     For now, set it to 1500 for SSRB
      INTEGER :: NLAT,NMOS,ILG
!ANDY      INTEGER,PARAMETER :: NLAT=84,NMOS=4,ILG=NLAT*NMOS
      INTEGER,PARAMETER :: ICAN=4,IGND=3,ICP1=ICAN+1
      INTEGER,PARAMETER :: M_X=100,M_Y=100,M_S=40,M_R=3,M_C=5
C
C     WATERSHED RELATED VARIABLES
      INTEGER LATDEGMIN,LATMINMIN,LATDEGMAX,LATMINMAX,LONDEGMIN,
     +     LONMINMIN,LONDEGMAX,LONMINMAX
      INTEGER WF_IYMAX,
     +WF_JXMAX


      INTEGER, DIMENSION(:), ALLOCATABLE :: WF_IBN,
     +  WF_IROUGH, WF_ICHNL, WF_NEXT, WF_ELEV, WF_IREACH
!ANDY      INTEGER WF_IBN(NLAT),
!ANDY     +     WF_IROUGH(NLAT),WF_ICHNL(NLAT),WF_NEXT(NLAT),WF_ELEV(NLAT),
!ANDY     +     WF_IREACH(NLAT)
      REAL*8, DIMENSION(:), ALLOCATABLE :: WF_DA, WF_BNKFLL,
     +  WF_CHANNELSLOPE
      REAL*8 :: LATLENGTH, LONGLENGTH
!ANDY      REAL*8 WF_DA(NLAT),WF_BNKFLL(NLAT),
!ANDY     +     WF_CHANNELSLOPE(NLAT),
!ANDY     +     WF_FRAC(NLAT),LATLENGTH,LONGLENGTH
!      REAL*8, DIMENSION(:,:), ALLOCATABLE :: ACLASS
      REAL*8 WF_AL
!ANDY      REAL*8 WF_ACLASS(NLAT,NMOS), WF_AL
	REAL WF_LAND_MAX, WF_LAND_SUM
      INTEGER WF_LAND_COUNT

C     IOSTAT VARIABLE
      INTEGER IOS, IOS_EVT

C FOR OUTPUT
      CHARACTER*10 GENDIR_OUT


C     OTHER RANDOM VARIABLES
      INTEGER BASINSHORTWAVEFLAG, BASINLONGWAVEFLAG, BASINRAINFLAG,
     1        BASINTEMPERATUREFLAG, BASINWINDFLAG, BASINPRESFLAG,
     2        BASINHUMIDITYFLAG
      INTEGER HOURLYFLAG


c     sca variables
!     This is the fraction of each square that's in the basin
      REAL, DIMENSION(:), ALLOCATABLE :: BASIN_FRACTION
!ANDY      REAL BASIN_FRACTION(NLAT)

c 84 is the value for TVC, for another basin, figure out NLTEST and use that instead
C 39 is the value for WC
      REAL basin_SCA
      REAL basin_SWE
C     STREAMFLOW VARIABLES
      INTEGER WF_NO, WF_NL, WF_MHRD, WF_KT
      INTEGER WF_IY(M_S),WF_JX(M_S), WF_S(M_S)
      REAL WF_QHYD(M_S),WF_QHYD_AVG(M_S),WF_QSYN(M_S)
      CHARACTER WF_GAGE(M_S)*8

C     RESERVOIR VARIABLES
!Diane      INTEGER WF_NORESV, WF_NREL, WF_KTR, WF_NORESV_CTRL
	INTEGER WF_IRES(M_R), WF_JRES(M_R), WF_RES(M_R), WF_R(M_R)
	REAL WF_B1(M_R),WF_B2(M_R),WF_QREL(M_R), WF_RESSTORE(M_R)
	CHARACTER WF_RESNAME(M_R)*8

C FOR BASEFLOW INITIALIZATION
      INTEGER JAN

C     FOR ROUTING
!      INTEGER WF_ROUTETIMESTEP, WF_TIMECOUNT, DRIVERTIMESTEP
!ANDY	REAL WF_R1(M_C),WF_R2(M_C),WF_NHYD(NLAT),WF_QBASE(NLAT)
!ANDY	REAL WF_QI2(NLAT),WF_QO1(NLAT),WF_QO2(NLAT), WF_QR(NLAT)
!ANDY	REAL WF_STORE1(NLAT), WF_STORE2(NLAT), WF_QI1(NLAT)
      REAL WF_R1(M_C), WF_R2(M_C)
      REAL, DIMENSION(:), ALLOCATABLE :: WF_NHYD, WF_QBASE, WF_QI2,
     +  WF_QO1, WF_QO2, WF_QR, WF_STORE1, WF_STORE2, WF_QI1

   
C
C Saul=======
c IYEAR_START: Initial year for data at the bin file
c IDAY_START : Initial day for data at the bin file
c IHOUR_START: Initial hour for data at the bin file
c IMIN_START : Initial minute for data at the bin file
C ISTEP_START: Time step; 1:hour, 2:half of hour
C toskip   : The number of variables in the file per timestep
C HOURLY_START_*: Start day/year for recording hourly averaged data
C HOURLY_STOP_*: Stop day/year for recording hourly averaged data
C DAILY_START_*: Start day/year for recording daily averaged data
C DAILY_STOP_*: Stop day/year for recording daily averaged data
      INTEGER IHOUR_START,IMIN_START,IDAY_START,IYEAR_START,ISTEP_START
      INTEGER IHOUR_END,IMIN_END,IDAY_END,IYEAR_END
      INTEGER nyy,ndy,nmy,nhy,nrs,toskip
      INTEGER HOURLY_START_DAY, HOURLY_STOP_DAY, DAILY_START_DAY,
     1           DAILY_STOP_DAY
      INTEGER HOURLY_START_YEAR, HOURLY_STOP_YEAR, DAILY_START_YEAR,
     1           DAILY_STOP_YEAR
C===========


C     * LAND SURFACE DIAGNOSTIC VARIABLES.

      REAL, DIMENSION(:), ALLOCATABLE :: SNOGRD
!ANDY      REAL,DIMENSION(NLAT) :: SNOGRD


C BRUCE
C     * INTERNAL WORK ARRAYS FOR CLASSBHYD and Hydrology (iwf.ini and soil.ini).
C     * These are used if soil parameters are read in directly from soil.ini

      INTEGER SOIL_IOS

!ANDY      REAL wc_thpor (NLAT,NMOS,IGND),wc_thlret(NLAT,NMOS,IGND),
!ANDY     1     wc_thlmin(NLAT,NMOS,IGND),wc_bi    (NLAT,NMOS,IGND),
!ANDY     2     wc_psisat(NLAT,NMOS,IGND),wc_grksat(NLAT,NMOS,IGND),
!ANDY     3     wc_hcps  (NLAT,NMOS,IGND),wc_tcs   (NLAT,NMOS,IGND),
!ANDY     4     wc_algwet(NLAT,NMOS)     ,wc_algdry(NLAT,NMOS)
      REAL, DIMENSION(:,:,:), ALLOCATABLE :: wc_thpor, wc_thlret,
     +  wc_thlmin, wc_bi, wc_psisat, wc_grksat, wc_hcps, wc_tcs
      REAL, DIMENSION(:,:), ALLOCATABLE :: wc_algwet, wc_algdry

C==========

C
C
C     * START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
C
!      INTEGER,      ALLOCATABLE::wfo_pick(:)
!      CHARACTER*50, ALLOCATABLE::wfo_attributes(:)
      CHARACTER*10 wf_landclassname(10)
      INTEGER*4 wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss,
     *                   wfo_ms,nj, ensim_month, ensim_day
      INTEGER*4 WFO_SEQ, ENSIM_IOS
      INTEGER*4 CURREC

C
C End of ENSIM Changes == ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==
C
c  VARIABLES FOR INITIAL SOIL MOISTURE AND SOIL TEMPERATURE
c  Saul M. feb 26 2008
      REAL*4,       ALLOCATABLE::valuem(:,:,:)
      REAL*4,       ALLOCATABLE::valuet(:,:,:)
c
      INTEGER*4 s_ios, ix
c

C     * CONSTANTS AND TEMPORARY VARIABLES.
C
      REAL DEGLAT,DEGLON,FSDOWN1,FSDOWN2,FSDOWN3,RDAY,
     1     DECL,HOUR,COSZ,
     2     ALTOT,FSSTAR,FLSTAR,QH,QE,BEG,SNOMLT,ZSN,TCN,TSN,TPN,GTOUT
      INTEGER JLAT

      REAL, DIMENSION(:), ALLOCATABLE :: FSDOWN
!ANDY      REAL FSDOWN(NLAT)
      
      !variables for reading new_shd.r2c
      REAL TEMPARRAY(100)
      INTEGER junkInt, NUMATTRS
      INTEGER GRID(M_X,M_Y)
      CHARACTER*50 ATTRLINE, ATTRNAME
      CHARACTER*50 ATTRIBUTENAME(100)
      CHARACTER*10 PROJECTION

! *************************************************************
! For reading in options information from MESH_run_options.ini
! *************************************************************
      CHARACTER(20) :: IRONAME
      INTEGER       :: IROVAL

! *******************************************************************
! For reading in the last information in mesh_paramters_hyrology.ini
! *******************************************************************
      CHARACTER(30) :: NMTESTFORMAT

C=======================================================================
C     * DIMENSION STATEMENTS


C     * FIRST SET OF DEFINITIONS: 
C
C     * BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
C     * VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
C     * THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE 
C     * MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX 
C     * "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
C     * A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
C     * ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO 
C     * GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
C     * DIAGNOSTIC VARIABLES.
C
C     * THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES 
C     * REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT 
C     * LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS 
C     * NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
C     * SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION 
C     * ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
C     * NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
C     * VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST 
C     * DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
C     * THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
C     * "ROW" VARIABLES.


C     * CONSTANTS (PARAMETER DEFINITIONS): 
C
C     * NLAT: MAXIMUM ALLOWABLE NUMBER OF GRID SQUARES
C     * NMOS: MAXIMUM ALLOWABLE NUMBER OF GRUS
C     * ILG: MAXIMUM ALLOWABLE SINGLE-DIMENSION ARRAY LENGTH
C     * ICAN: MAXIMUM ALLOWABLE NUMBER OF LAND COVER TYPES
C     * ICP1: MAXIMUM ALLOWABLE NUMBER OF LAND COVER TYPES INCLUDING 
C     *         URBAN AREAS
C     * IGND: MAXIMUM ALLOWABLE NUMBER OF SOIL LAYERS
C     * M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
C     * M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
C     * M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
C     * M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
C     * M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
C     * M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS
CDAN  * VERSION: MESH_DRIVER VERSION
CDAN  * RELEASE: PROGRAM RELEASE
      INTEGER, PARAMETER :: M_G = 5
      CHARACTER :: VERSION*24 = "driver_04-20-2008", 
     1  RELEASE*8 = "1.1.a01"


C     * OPERATIONAL VARIABLES: 
C
C     * IOS: IOSTAT (ERROR) RETURN ON READ EXTERNAL FILE
C     * IY: Y-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
C     * JX: X-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
C     * NN: GRID SQUARE, USED TO READ DRAINAGE DATABASE
C     * II: GRU, USED TO READ DRAINAGE DATABASE
C     * JAN: IS USED TO INITIALISE BASEFLOW (WHEN JAN = 1)
C     * N: COUNTER USED BY CLASS
C     * NCOUNT: HALF-HOURLY BASED TIME STEP (200 LOOP)
C     * NSUM: NUMBER OF ITERATIONS, TIME STEPS PASSED (200 LOOP)
C     * I: COUNTER
C     * J: COUNTER
C     * K: COUNTER
C     * L: COUNTER
C     * M: COUNTER
C     * CONFLAGS: NUMBER OF CONTROL FLAGS
C     * OPTFLAGS: NUMBER OF OPTFLAGS
C     * INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
C     * DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
CDAN  * PAS: STAT (ERROR) RETURN ON ALLOCATE VARIABLE
CDAN  * OPN: OPENED RETURN ON INQUIRE STATEMENT (USED TO CHECK IF AN 
CDAN  *      EXTERNAL FILE HAS BEEN OPENED BY THE PROGRAM
CDAN  * FILE_VER: FILE VERSION USED TO SEEK INPUT FILE COMPATIBILITY 
CDAN  *           (COMPARED TO "RELEASE")
      CHARACTER :: FILE_VER*8
      INTEGER ::  N, NCOUNT, NSUM, I, J, K, L, M, 
     1  CONFLAGS, OPTFLAGS, INDEPPAR, DEPPAR, PAS
      LOGICAL :: OPN
CDAN      INTEGER :: NN, II !OLD DRAINAGE DATABASE METHODS REMOVED
CDAN      INTEGER :: SMOOTH !IS NOT USED IN MESH_DRIVER!
CDAN      INTEGER :: ISUM(6) !IS NOT USED IN MESH_DRIVER!


CDAN  * EVENT FILE (HOLDS FLAGS AND FILE NAMES) (EVENT/EVENT.EVT): 
CDAN
CDAN  * ALL: ARE DUMMY ARGUMENTS SET BY RDEVT FILE ITSELF
      CHARACTER :: DATE*14
      INTEGER :: NHG, NHF
      REAL*4 :: SMC5(16), CONV, SCALE


C     * DRAINAGE DATABASE (BASIN SHD) (DRAINAGE_DATABASE.TXT): 
CDAN  NO LONGER USED.  DRAINAGE_DATABASE.TXT HAS BEEN REPLACED WITH 
CDAN  THE BASIN SHD FILE.  READ_SHED_EF, FROM STAND-ALONE RTE.EXE 
CDAN  (WATROUTE), IS CALLED TO READ THE NEW FILE.
C
C     * BASIN INFORMATION AND COUNTS: 
C     * WF_NA: NUMBER OF GRID SQUARES
C     * NAA: NUMBER OF GRID OUTLETS
C     * WF_NTYPE: NUMBER OF GRUS
C     * NRVR: NUMBER OF RIVER CLASSES
C     * WF_IMAX: NUMBER OF GRID COLUMNS IN BASIN
C     * WF_JMAX: NUMBER OF GRID ROWNS IN BASIN
C     * AL: SINGLE-DIMENSION GRID SQUARE LENGTH
CDAN      INTEGER :: WF_NA, NAA, WF_NTYPE, NRVR, WF_IMAX, WF_JMAX
CDAN      REAL*8 :: AL
C
C     * LAT/LONG, SITE LOCATION INFORMATION: 
C     * IYMIN: MINIMUM Y-DIRECTION GRID CO-ORDINATE (UTM)
C     * WF_IYMAX: MAXIMUM Y-DIRECTION GRID CO-ORDINATE (UTM)
C     * JXMIN: MINIMUM X-DIRECTION GRID CO-ORDINATE (UTM)
C     * WF_JXMAX: MAXIMUM X-DIRECTION GRID CO-ORDINATE (UTM)
C     * GRDN: GRID NORTHING
C     * GRDE: GRID EASTING
C     * LATLENGTH: SINGLE SIDE LENGTH OF GRID SQUARE IN DEGREES 
C     *            LATITUDE
C     * LONGLENGTH: SINGLE SIDE LENGTH OF GRID SQUARE IN DEGREES 
C     *             LONGITUDE
CDAN      INTEGER :: LATDEGMIN, LATMINMIN, LATDEGMAX, LATMINMAX, LONDEGMIN, 
CDAN     1  LONMINMIN, LONDEGMAX, LONMINMAX, IYMIN, WF_IYMAX, JXMIN, 
CDAN     2  WF_JXMAX
CDAN      REAL :: GRDN, GRDE
      
C
C     * GRID SQUARE INFORMATION: 
C     * YYY: GRID COLUMN CO-ORDINATE IN BASIN
C     * XXX: GRID ROW CO-ORDINATE IN BASIN
C     * WF_ELEV: GRID SQUARE ELEVATION
C     * WF_ICHNL: RIVER CLASS
C     * WF_NEXT: RECEIVING GRID SQUARE
C     * WF_CHANNELSLOPE: INTERNAL CHANNEL SLOPE
C     * WF_FRAC: GRID SQUARE FRACTION
C     * ACLASS: %-GRU COVER PER GRID SQUARE
CDAN      INTEGER, DIMENSION(NLAT) :: YYY, XXX, WF_ELEV, WF_IBN, 
CDAN     1  WF_IROUGH, WF_ICHNL, WF_NEXT, WF_IREACH
CDAN      REAL*8, DIMENSION(NLAT) :: WF_DA, WF_BNKFLL, WF_CHANNELSLOPE, 
CDAN     2  WF_FRAC
CDAN      REAL*8, DIMENSION(NLAT, NMOS) :: WF_ACLASS
C
C     * GRU-COVER PERCENT CHECKERS: 
CDAN  * THESE CHECKS ARE INCLUDED IN READ_SHED_EF
CDAN      INTEGER :: WF_LAND_COUNT
CDAN      REAL :: WF_LAND_MAX, WF_LAND_SUM


C     * STREAMFLOW MEASUREMENTS: 
CDAN  NO LONGER USED.  WATROUTE HAS BEEN REMOVED AND REPLACED WITH 
CDAN  STAND-ALONE RTE.EXE (WATROUTE).
C
C     * WF_GAGE: GAUGE IDENTIFIER (8 CHARACTER STRING)
C     * WF_NO: NUMBER OF STREAMFLOW GAUGES
C     * WF_NL: NUMBER OF DATA POINTS
C     * WF_MHRD: NUMBER OF HOURS OF DATA PER MONTH
C     * WF_KT: HOURLY INCREMENT FOR STREAMFLOW INPUT (24 = DAILY)
C     * WF_IY: Y-DIRECTION GAUGE CO-ORDINATE (UTM OR LATLONG)
C     * WF_JX: X-DIRECTION GAUGE CO-ORDINATE (UTM OR LATLONG)
C     * WF_S: GAUGE'S PARENT GRID SQUARE
C     * WF_QHYD: STREAMFLOW VALUE (_AVG = DAILY AVERAGE)
C     * WF_QSYN: SIMULATED STREAFLOW VALUE
CDAN      CHARACTER, DIMENSION(M_S) :: WF_GAGE*8
CDAN      INTEGER :: WF_NO, WF_NL, WF_MHRD, WF_KT
CDAN      INTEGER, DIMENSION(M_S) :: WF_IY, WF_JX, WF_S
CDAN      REAL, DIMENSION(M_S) :: WF_QHYD, WF_QHYD_AVG, WF_QSYN


C     * RESERVOIR MEASUREMENTS: 
CDAN  NO LONGER USED.  WATROUTE HAS BEEN REMOVED AND REPLACED WITH 
CDAN  STAND-ALONE RTE.EXE (WATROUTE).
C
C     * WF_RESNAME: RESERVOIR IDENTIFIER (8 CHARACTER STRING)
C     * WF_NORESV: NUMBER OF RESERVOIRS
C     * WR_NREL: NUMBER OF DATA POINTS
C     * WF_KTR: HOURLY INCREMENT FOR RESERVOIR INPUR (24 = DAILY)
C     * WF_IRES: Y-DIRECTION GAUGE CO-ORDINATE
C     * WF_JRES: X-DIRECTION GAUGE CO-ORDINATE
C     * WF_R: RESERVOIR'S PARENT GRID SQUARE
C     * WF_QREL: RESERVOIR VALUE
CDAN      CHARACTER, DIMENSION(M_R) :: WF_RESNAME*8
CDAN      INTEGER :: WF_NORESV, WF_NREL, WF_KTR, WF_NORESV_CTRL
CDAN      INTEGER, DIMENSION(M_R) :: WF_IRES, WF_JRES, WF_RES, WF_R
CDAN      REAL, DIMENSION(M_R) :: WF_B1, WF_B2, WF_QREL, WF_RESSTORE


C     * WATROUTE (ROUTING): 
CDAN  NO LONGER USED.  WATROUTE HAS BEEN REMOVED AND REPLACE WITH 
CDAN  STAND-ALONE RTE.EXE (WATROUTE).  THE REMAINING VARIABLES ARE USED 
CDAN  TO SET INPUT FILES FOR STAND-ALONE RTE.EXE (WATROUTE).
C
C     * WF_R1: MANNING'S N FOR RIVER CHANNEL
C     * WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
C     * WF_QO2: SIMULATED STREAMFLOW VALUE
C      CHARACTER :: IHV*1
CDAN  * FRAME_NO: FRAME NUMBER BEING WRITTEN TO R2C-FORMAT FILE
CDAN  * NO_FRAMES: TOTAL NUMBER OF FRAMES IN R2C-FORMAT FILE (TOTAL 
CDAN  *            NUMBER OF FRAMES IS NEVER KNOWN, IS ALWAYS SET TO 
CDAN  *            FRAME_NO + 1)
CDAN  * RUNOFF: HOURLY SIMULATED RUNOFF
CDAN  * RECHARGE: HOURLY SIMULATED RECHARGE
CDAN  * LEAKAGE: UNKNOWN, BUT MAY BE USED IN THE FUTURE
CDAN      INTEGER :: WF_ROUTETIMESTEP, WF_TIMECOUNT, DRIVERTIMESTEP
CDAN      REAL, DIMENSION(M_C) :: WF_R1, WF_R2
CDAN      REAL, DIMENSION(NLAT) :: WF_NHYD, WF_QBASE, WF_QI1, WF_QI2, 
CDAN     1  WF_QO1, WF_QO2, WF_QR, WF_STORE1, WF_STORE2
      INTEGER :: FRAME_NO, NO_FRAMES
CDAN      REAL*4, DIMENSION(:, :), ALLOCATABLE :: RUNOFF, RECHARGE, LEAKAGE
      REAL*4, DIMENSION(:, :), ALLOCATABLE :: RUNOFF, RECHARGE


C     * GRID OUTPUT POINTS
C
C     * BNAM: TEMPORARY HOLD FOR OUTPUT DIRECTORY (12 CHARACTER STRING)
C     * DIR_OUT: OUTPUT DIRECTORY (10 CHARACTER STRING)
C     * WF_NUM_POINTS: NUMBER OF GRID OUTPUTS
C     * I_OUT: OUTPUT GRID SQUARE TEMPORARY STORE
C     * N_OUT: GRID SQUARE TO OUTPUT
C     * II_OUT: GRU TO OUTPUT
CDAN  * PRE_OUT: DAILY ACCUMULATIVE PRECIPITATION FOR OUTPUT
CDAN  * EVAP_OUT: DAILY ACCUMULATIVE EVAPORATION FOR OUTPUT
CDAN  * ROF_OUT: DAILY ACCUMULATIVE RUNOFF FOR OUTPUT
CDAN  CHARACTER :: BNAM*12, DIR_OUT(M_G)*10
	CHARACTER :: BNAM*12
	CHARACTER, DIMENSION(:), ALLOCATABLE :: DIR_OUT*10
      INTEGER :: WF_NUM_POINTS, I_OUT
CDAN  INTEGER, DIMENSION(M_G) :: N_OUT, II_OUT
      INTEGER, DIMENSION(:), ALLOCATABLE :: N_OUT, II_OUT
CDAN      REAL*4, DIMENSION(M_G) :: PRE_OUT, EVAP_OUT, ROF_OUT
      REAL*4, DIMENSION(:), ALLOCATABLE :: PRE_OUT, EVAP_OUT, ROF_OUT


C     * MET. FORCING DATA (FORCING.BIN): 
C     * THESE HAVE TO BE REAL*4 IN ORDER TO READ IN THE MET DATA 
C     * CORRECTLY.
C
C     * R4SHRTGRID2D: VISIBLE SHORTWAVE RADIATION [W m-2]
C     * R4LONGGRID2D: DOWNWELLING LONGWAVE RADIATION [W m-2]
C     * R4RAINGRID2D: PRECIPITATION [kg m-2 s-1]
C     * R4TEMPGRID2D: AMBIENT AIR TEMPERATURE [dC]
C     * R4WINDGRID2D: WIND SPEED AT REFERENCE HEIGHT [m s-1]
C     * R4PRESGRID2D: AIR PRESSURE AT SURFACE [Pa]
C     * R4HUMDGRID2D: SPECIFIC HUMIDITY AT REFERENCE HEIGHT [kg kg-1]
CDAN      REAL*4, DIMENSION(M_Y, M_X) :: R4SHRTGRID2D, 
      REAL*4, DIMENSION(:, :), ALLOCATABLE :: R4SHRTGRID2D, 
     1  R4LONGGRID2D, R4RAINGRID2D, R4TEMPGRID2D, R4WINDGRID2D, 
     2  R4PRESGRID2D, R4HUMDGRID2D


C     * LIMITING TIME STEPS (CLASS.INI): 
CDAN  NOT USED RIGHT NOW.  CONSIDER USING THEM TO LIMIT RUN INSTEAD 
CDAN  OF END OF FORCING.BIN FILE (IS ESPECIALLY USEFUL WHEN DEBUGGING).
C
C     * JOUT1: DAILY-AVERAGED OUTPUT START DAY (JULIAN FROM YEAR START)
C     * JOUT2: DAILY-AVERAGED OUTPUT STOP DAY (JULIAN FROM YEAR START)
C     * JAV1: DAILY-AVERAGED OUTPUT START YEAR
C     * JAV2: DAILY-AVERAGED OUTPUT STOP YEAR
C     * KOUT1: YEARLY-AVERAGED OUTPUT START DAY (JULIAN FROM YEAR START)
C     * KOUT2: YEARLY-AVERAGED OUTPUT STOP DAY (JULIAN FROM YEAR START)
C     * KAV1: YEARLY-AVERAGED OUTPUT START YEAR
C     * KAV2: YEARLY-AVERAGED OUTPUT STOP YEAR
      INTEGER :: JOUT1, JOUT2, JAV1, JAV2, KOUT1, KOUT2, KAV1, KAV2


C     * CLASS CONTROL FLAGS: 
CDAN  CONSIDER INCLUDING AS CONTROL FLAGS IN RUN_OPTIONS.INI FILE SO 
CDAN  THAT THEY ARE NO LONGER HARD-CODED.
C
C     * ALL: DESCRIPTIONS ARE WRITTEN WHERE RUN_OPTIONS.INI IS READ
      INTEGER :: IDISP, IZREF, ISLFD, IPCP, IWF, ILAI, IHGT, IALC, 
     1  IALS, IALG, ITG, ITC, ITCG


C     * GRID SQUARE COUNTS: 
C
C     * NLTEST: NUMBER OF GRID SQUARES (CLASS.INI)
C     * NMTEST: NUMBER OF GRUS (CLASS.INI)
C     * IHOUR: CURRENT HOUR OF MET. FORCING DATA (0 TO 23) (CLASS.INI)
C     * IMIN: CURRENT MINUTE OF MET. FORCING DATA (0 OR 30) (CLASS.INI)
C     * IDAY: CURRENT DAY OF MET. FORCING DATA (JULIAN FROM YEAR START)
C     *       (CLASS.INI)
C     * IYEAR: CURRENT YEAR OF MET. FORCING DATA (CLASS.INI)
C     * NML: NUMBER OF LAND-ORIENTED GRID SQUARES
C     * NMW: NUMBER OF WATER-ORIENTED GRID SQUARES
C     * NICE: NUMBER OF LARGE ICE-BODIED GRID SQUARES (GLACIERS)
C     * NWAT: NUMBER OF LARGE WATER-BODIED GRID SQUARES
      INTEGER :: ILW, NLTEST, NMTEST, IHOUR, IMIN, IDAY, IYEAR, NML, 
     1  NMW, NWAT, NICE, NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI


C     * LAND SURFACE PROGNOSTIC VARIABLES (CLASS.INI): 
C
C     * TBAR: INITIAL SOIL LAYER TEMPERATURE
C     * THLQ: INITIAL SOIL LAYER LIQUID WATER CONTENT
C     * THIC: INITIAL SOIL LAYER ICE WATER CONTENT
CDAN      REAL, DIMENSION(NLAT, NMOS, IGND) :: TBARROW, THLQROW, THICROW
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: TBARROW, THLQROW, THICROW
CDAN      REAL, DIMENSION(ILG, IGND) :: TBARGAT, THLQGAT, THICGAT
      REAL, DIMENSION(:, :), ALLOCATABLE :: TBARGAT, THLQGAT, THICGAT
C
C     * TPND: INITIAL PONDING TEMPERATURE (CLASS.INI)
C     * ZPND: INITIAL PONDING DEPTH (CLASS.INI)
C     * ALBS: ALBEDO OF SNOWPACK (CLASS.INI)
C     * TSNO: INITIAL SNOWPACK TEMPERATURE (CLASS.INI)
C     * RHOS: DENSITY OF SNOWPACK (CLASS.INI)
C     * SNO: SNOWPACK ON CANOPY LAYER (CLASS.INI)
C     * TCAN: INITIAL CANOPY TEMPERATURE (CLASS.INI)
C     * GRO: VEGETATION GROWTH INDEX (CLASS.INI)
CDAN      REAL, DIMENSION(NLAT, NMOS) :: TPNDROW, ZPNDROW, TBASROW, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: TPNDROW, ZPNDROW, TBASROW, 
     1  ALBSROW, TSNOROW, RHOSROW, SNOROW, TCANROW, RCANROW, SCANROW, 
     2  GROROW, CMAIROW, TACROW, QACROW, WSNOROW
CDAN      REAL, DIMENSION(ILG) :: TPNDGAT, ZPNDGAT, TBASGAT, 
      REAL, DIMENSION(:), ALLOCATABLE :: TPNDGAT, ZPNDGAT, TBASGAT, 
     1  ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, TCANGAT, RCANGAT, SCANGAT, 
     2  GROGAT, CMAIGAT, TACGAT, QACGAT, WSNOGAT
C
CDAN      REAL, DIMENSION(NLAT, NMOS, 4) :: TSFSROW
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: TSFSROW
CDAN      REAL, DIMENSION(ILG, 4) :: TSFSGAT
      REAL, DIMENSION(:, :), ALLOCATABLE :: TSFSGAT


C     * GATHER-SCATTER COUNTS: 
C
CDAN      INTEGER, DIMENSION(ILG) :: ILMOS, JLMOS, IWMOS, JWMOS
      INTEGER, DIMENSION(:), ALLOCATABLE :: ILMOS, JLMOS, IWMOS, JWMOS
CDAN      INTEGER, DIMENSION(NLAT) :: IWAT, IICE
      INTEGER, DIMENSION(:), ALLOCATABLE :: IWAT, IICE


C     * CANOPY AND SOIL INFORMATION (CLASS): 
C     * THE LENGTH OF THESE ARRAYS IS DETERMINED BY THE NUMBER
C     * OF SOIL LAYERS (3) AND THE NUMBER OF BROAD VEGETATION
C     * CATEGORIES (4, OR 5 INCLUDING URBAN AREAS).
C
C     * ALL: DEFINITIONS IN CLASS DOCUMENTATION (CLASS.INI)
CDAN      REAL, DIMENSION(NLAT, NMOS, ICP1) :: FCANROW, LNZ0ROW, 
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: FCANROW, LNZ0ROW, 
     1  ALVCROW, ALICROW
CDAN      REAL, DIMENSION(ILG, ICP1) :: FCANGAT, LNZ0GAT, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: FCANGAT, LNZ0GAT, 
     1  ALVCGAT, ALICGAT
C
C     * ALL: DEFINITIONS IN CLASS DOCUMENTATION (CLASS.INI)
CDAN      REAL, DIMENSION(NLAT, NMOS, ICAN) :: LAMXROW, LAMNROW, 
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: LAMXROW, LAMNROW, 
     1  CMASROW, ROOTROW, RSMNROW, QA50ROW, VPDAROW, VPDBROW, PSGAROW, 
     2  PSGBROW, AILDROW, HGTDROW, ACVDROW, ACIDROW
CDAN      REAL, DIMENSION(ILG, ICAN) :: LAMXGAT, LAMNGAT, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: LAMXGAT, LAMNGAT, 
     1  CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, VPDAGAT, VPDBGAT, PSGAGAT, 
     2  PSGBGAT, AILDGAT, HGTDGAT, ACVDGAT, ACIDGAT
C
C     * ALL: DEFINITIONS IN CLASS DOCUMENTATION
CDAN      REAL, DIMENSION(NLAT, NMOS, IGND) :: THPROW, THRROW, THMROW, 
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: THPROW, THRROW, THMROW, 
     1  BIROW, PSISROW, GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, 
     2  PSIWROW, DLZWROW, ZBTWROW
CDAN      REAL, DIMENSION(ILG, IGND) :: THPGAT, THRGAT, THMGAT, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: THPGAT, THRGAT, THMGAT, 
     1  BIGAT, PSISGAT, GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, 
     2  PSIWGAT, DLZWGAT, ZBTWGAT, GFLXGAT
C
C     * ALL: DEFINITIONS IN CLASS DOCUMENTATION (CLASS.INI)
CDAN      REAL, DIMENSION(NLAT, NMOS) :: DRNROW, XSLPROW, GRKFROW, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: DRNROW, XSLPROW, GRKFROW, 
     1  WFSFROW, WFCIROW, ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, 
     2  AGIDROW, ZSNLROW, ZPLGROW, ZPLSROW, SDEPROW, FAREROW
CDAN      REAL, DIMENSION(ILG) :: DRNGAT, XSLPGAT, GRKFGAT, 
      REAL, DIMENSION(:), ALLOCATABLE :: DRNGAT, XSLPGAT, GRKFGAT, 
     1  WFSFGAT, WFCIGAT, ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, 
     2  AGIDGAT, ZSNLGAT, ZPLGGAT, ZPLSGAT, SDEPGAT, FAREGAT
C
C     * SAND: PERCENT-CONTENT OF SAND IN SOIL LAYER (CLASS.INI)
C     * CLAY: PERCENT-CONTENT OF CLAY IN SOIL LAYER (CLASS.INI)
C     * ORGM: PERCENT-CONTENT OF ORGANIC MATTER IN SOIL LAYER (CLASS.INI)
CDAN      REAL, DIMENSION(NLAT, NMOS, IGND) :: SANDROW, CLAYROW, ORGMROW
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: SANDROW, CLAYROW, ORGMROW
C
C     * MIDROW: DEFINITION IN CLASS DOCUMENTATION (CLASS.INI)
CDAN      INTEGER, DIMENSION(NLAT, NMOS) :: MIDROW
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: MIDROW
C
CDAN      INTEGER, DIMENSION(NLAT, NMOS, IGND) :: ISNDROW, IORG
      INTEGER, DIMENSION(:, :, :), ALLOCATABLE :: ISNDROW, IORG
CDAN      INTEGER, DIMENSION(ILG, IGND) :: ISNDGAT
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: ISNDGAT
C
C     * DELZ: SOIL LAYER DEPTH (SOIL_LEVELS.TXT)
C     * ZBOT: CUMULATIVE SOIL DEPTH (SOIL_LEVELS.TXT)
CDAN      REAL, DIMENSION(IGND) :: DELZ, ZBOT
      REAL, DIMENSION(:), ALLOCATABLE :: DELZ, ZBOT


C     * WATROF FLAGS AND VARIABLES: 
C
C     * VICEFLG: VERTICAL ICE FLAG OR LIMIT
C     * HICEFLG: HORIZONTAL ICE FLAG OR LIMIT
C     * DD (DDEN): DRAINAGE DENSITY (CLASS.INI)
C     * MANN (WFSF): MANNING'S n (CLASS.INI)
	INTEGER :: LZFFLG, EXTFLG, IWFICE, ERRFLG, IWFOFLW
      REAL :: VICEFLG, PSI_LIMIT, HICEFLG
CDAN      REAL, DIMENSION(NLAT, NMOS) :: DDROW, MANNROW
      REAL, DIMENSION(:, :), ALLOCATABLE :: DDROW, MANNROW
CDAN      REAL, DIMENSION(ILG) :: DDGAT, MANNGAT
      REAL, DIMENSION(:), ALLOCATABLE :: DDGAT, MANNGAT


C     * CONTROL FLAGS
C
C     * ALL: DEFINITIONS ARE WRITTEN JUST BEFORE RUN_OPTIONS.INI IS
C     *      OPENED
CDAN  * BINFLG: FORCING.BIN STEP
CDAN  * RELFLG: RELEASE-MATCH STRICTNESS
      REAL :: BINFLG, RELFLG


C     * ATMOSPHERIC AND GRID-CONSTANT INPUT VARIABLES: 
C
CDAN      REAL, DIMENSION(NLAT) :: ZRFMGRD, ZRFHGRD, ZDMGRD, 
      REAL, DIMENSION(:), ALLOCATABLE :: ZRFMGRD, ZRFHGRD, ZDMGRD, 
     1  ZDHGRD, ZBLDGRD, FSVHGRD, FSIHGRD, RADJGRD, CSZGRD, FDLGRD, 
     2  ULGRD, VLGRD, TAGRD, QAGRD, PRESGRD, PREGRD, PADRGRD, VPDGRD, 
     3  TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, RHSIGRD, 
     4  FCLOGRD, DLONGRD, Z0ORGRD, GGEOGRD, UVGRD, XDIFFUS, GCGRD, 
     5  RPREGRD, SPREGRD
CDAN      REAL, DIMENSION(ILG) :: ZRFMGAT, ZRFHGAT, ZDMGAT, 
      REAL, DIMENSION(:), ALLOCATABLE :: ZRFMGAT, ZRFHGAT, ZDMGAT, 
     1  ZDHGAT, ZBLDGAT, FSVHGAT, FSIHGAT, RADJGAT, CSZGAT, FDLGAT, 
     2  ULGAT, VLGAT, TAGAT, QAGAT, PRESGAT, PREGAT, PADRGAT, VPDGAT, 
     3  TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, 
     4  FCLOGAT, DLONGAT, Z0ORGAT, GGEOGAT
C
CDAN      REAL, DIMENSION (ILG, 3) :: TBAR3
      REAL, DIMENSION (:, :), ALLOCATABLE :: TBAR3


C     * LAND SURFACE DIAGNOSTIC VARIABLES: 
C
CDAN      REAL, DIMENSION(NLAT, NMOS) :: CDHROW, CDMROW, HFSROW, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: CDHROW, CDMROW, HFSROW, 
     1  TFXROW, QEVPROW, QFSROW, QFXROW, PETROW, GAROW, EFROW, GTROW, 
     2  QGROW, TSFROW, ALVSROW, ALIRROW, FSNOROW, SFCTROW, SFCUROW, 
     3  SFCVROW, SFCQROW, FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, 
     4  FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, HEVSROW, HEVGROW, 
     5  HMFCROW, HMFNROW, HTCCROW, HTCSROW, PCFCROW, PCLCROW, PCPNROW, 
     6  PCPGROW, QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, ROFOROW, 
     7  ROFSROW, ROFBROW, ROFCROW, ROFNROW, ROVGROW, WTRCROW, WTRSROW, 
     8  WTRGROW, DRROW, WTABROW, ILMOROW, UEROW, HBLROW, TROFROW, 
     9  TROOROW, TROSROW, TROBROW
CDAN      REAL, DIMENSION(ILG) :: CDHGAT, CDMGAT, HFSGAT, 
      REAL, DIMENSION(:), ALLOCATABLE :: CDHGAT, CDMGAT, HFSGAT, 
     1  TFXGAT, QEVPGAT, QFSGAT, QFXGAT, PETGAT, GAGAT, EFGAT, GTGAT, 
     2  QGGAT, TSFGAT, ALVSGAT, ALIRGAT, FSNOGAT, SFCTGAT, SFCUGAT, 
     3  SFCVGAT, SFCQGAT, FSGVGAT, FSGSGAT, FSGGGAT, FLGVGAT, FLGSGAT, 
     4  FLGGGAT, HFSCGAT, HFSSGAT, HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, 
     5  HMFCGAT, HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, PCPNGAT, 
     6  PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, QFCFGAT, ROFGAT, ROFOGAT, 
     7  ROFSGAT, ROFBGAT, ROFCGAT, ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, 
     8  WTRGGAT, DRGAT, WTABGAT, ILMOGAT, UEGAT, HBLGAT, TROFGAT, 
     9  TROOGAT, TROSGAT, TROBGAT
CDAN      REAL, DIMENSION(NLAT) :: CDHGRD, CDMGRD, HFSGRD, 
      REAL, DIMENSION(:), ALLOCATABLE :: CDHGRD, CDMGRD, HFSGRD, 
     1  TFXGRD, QEVPGRD, QFSGRD, QFXGRD, PETGRD, GAGRD, EFGRD, GTGRD, 
     2  QGGRD, TSFGRD, ALVSGRD, ALIRGRD, FSNOGRD, SFCTGRD, SFCUGRD, 
     3  SFCVGRD, SFCQGRD, FSGVGRD, FSGSGRD, FSGGGRD, FLGVGRD, FLGSGRD, 
     4  FLGGGRD, HFSCGRD, HFSSGRD, HFSGGRD, HEVCGRD, HEVSGRD, HEVGGRD, 
     5  HMFCGRD, HMFNGRD, HTCCGRD, HTCSGRD, PCFCGRD, PCLCGRD, PCPNGRD, 
     6  PCPGGRD, QFGGRD, QFNGRD, QFCLGRD, QFCFGRD, ROFGRD, ROFOGRD, 
     7  ROFSGRD, ROFBGRD, ROFCGRD, ROFNGRD, ROVGGRD, WTRCGRD, WTRSGRD, 
     8  WTRGGRD, DRGRD, WTABGRD, ILMOGRD, UEGRD, HBLGRD
C
CDAN      REAL, DIMENSION(NLAT, NMOS, IGND) :: HMFGROW, HTCROW, QFCROW
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: HMFGROW, HTCROW, QFCROW
CDAN      REAL, DIMENSION(ILG, IGND) :: HMFGGAT, HTCGAT, QFCGAT
      REAL, DIMENSION(:, :), ALLOCATABLE :: HMFGGAT, HTCGAT, QFCGAT
CDAN      REAL, DIMENSION(NLAT, IGND) :: HMFGGRD, HTCGRD, QFCGRD
      REAL, DIMENSION(:, :), ALLOCATABLE :: HMFGGRD, HTCGRD, QFCGRD
C
CDAN      INTEGER, DIMENSION(NLAT, NMOS, 6, 50) :: ITCTROW
      INTEGER, DIMENSION(:, :, :, :), ALLOCATABLE :: ITCTROW
CDAN      INTEGER, DIMENSION(ILG, 6, 50) :: ITCTGAT
      INTEGER, DIMENSION(:, :, :), ALLOCATABLE :: ITCTGAT


C     * OUTPUT VARIABLES: 
C     * THE SUFFIX "ACC" REFERS TO THE ACCUMULATOR ARRAYS USED IN
C     * CALCULATING TIME AVERAGES.
C
C     * TITLE: PROJECT DESCRIPTOR (6 COLUMNS: 4 CHARACTER STRINGS)
C     * NAME: AUTHOR, RESEARCHER (6 COLUMNS: 4 CHARACTER STRINGS)
C     * PLACE: SITE LOCATION, BASIN (6 COLUMNS: 4 CHARACTER STRINGS)
      CHARACTER :: TITLE1*4, TITLE2*4, TITLE3*4, TITLE4*4, TITLE5*4, 
     1  TITLE6*4, NAME1*4, NAME2*4, NAME3*4, NAME4*4, NAME5*4, NAME6*4, 
     2  PLACE1*4, PLACE2*4, PLACE3*4, PLACE4*4, PLACE5*4, PLACE6*4
C
C     * ALL: DEFINITIONS IN CLASS DOCUMENTATION
CDAN      REAL, DIMENSION(NLAT) :: PREACC, GTACC, QEVPACC, 
      REAL, DIMENSION(:), ALLOCATABLE :: PREACC, GTACC, QEVPACC, 
     1  HFSACC, ROFACC, SNOACC, ALVSACC, ALIRACC, FSINACC, FLINACC, 
     2  TAACC, UVACC, PRESACC, QAACC, EVAPACC, FLUTACC, ROFOACC, 
     3  ROFSACC, ROFBACC, HMFNACC, WTBLACC, WSNOACC, RHOSACC, TSNOACC, 
     4  TCANACC, RCANACC, SCANACC, GROACC, CANARE, SNOARE
C
C     * ALL: DEFINITIONS IN CLASS DOCUMENTATION
CDAN      REAL, DIMENSION(NLAT, IGND) :: TBARACC, THLQACC, THICACC, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: TBARACC, THLQACC, THICACC, 
     1  THALACC
C
C     * TOTAL_ROFACC: TOTAL RUNOFF
C     * TOTAL_EVAPACC: TOTAL EVAPORATION
C     * TOTAL_PREACC: TOTAL PRECIPITATION
C     * INIT_STORE: INITIAL STORAGE
C     * FINAL_STORE: FINAL STORAGE
C     * TOTAL_AREA: TOTAL FRACTIONED DRAINAGE AREA
      REAL :: TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, 
     1  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, 
     2  FINAL_STORE, TOTAL_AREA


C     * CROSS-CLASS VARIABLES (CLASS): 
C     * ARRAYS DEFINED TO PASS INFORMATION BETWEEN THE THREE MAJOR
C     * SUBSECTIONS OF CLASS ("CLASSA", "CLASST" AND "CLASSW").
C
CDAN      REAL, DIMENSION(ILG, IGND) :: TBARC, TBARG, TBARCS, 
      REAL, DIMENSION(:, :), ALLOCATABLE :: TBARC, TBARG, TBARCS, 
     1  TBARGS, THLIQC, THLIQG, THICEC, THICEG, FROOT, HCPC, HCPG, 
     2  TCTOP, TCBOT
C
CDAN      REAL, DIMENSION(ILG) :: FC, FG, FCS, FGS, RBCOEF, 
      REAL, DIMENSION(:), ALLOCATABLE :: FC, FG, FCS, FGS, RBCOEF, 
     1  ZSNOW, AILCAN, AILCNS, FSVF, FSVFS, ALVSCN, ALIRCN, ALVSG, 
     2  ALIRG, ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, 
     3  ALIRSC, TRVSCN, TRIRCN, TRVSCS, TRIRCS, RC, RCS, FRAINC, 
     4  FSNOWC, CMASSC, CMASCS, DISP, DISPS, ZOMLNC, ZOELNC, ZOMLNG, 
     5  ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS, TRSNOW, CHCAP, CHCAPS, 
     6  GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, G12CS, G12GS, G23C, 
     7  G23G, G23CS, G23GS, QFREZC, QFREZG, QMELTC, QMELTG, EVAPC, 
     8  EVAPCG, EVAPG, EVAPCS, EVPCSG, EVAPGS, TCANO, TCANS, RAICAN, 
     9  SNOCAN, RAICNS, SNOCNS, CWLCAP, CWFCAP, CWLCPS, CWFCPS, TSNOCS, 
     A  TSNOGS, RHOSCS, RHOSGS, WSNOCS, WSNOGS, TPONDC, TPONDG, TPNDCS, 
     B  TPNDGS, ZPLMCS, ZPLMGS, ZPLIMC, ZPLIMG
C
CDAN      REAL, DIMENSION(ILG, 3, 2) :: ZTHRC, ZTHRG, ZTHRCS, 
      REAL, DIMENSION(:, :, :), ALLOCATABLE :: ZTHRC, ZTHRG, ZTHRCS, 
     1  ZTHRGS


C     * BALANCE ERRORS (CLASS): 
C     * DIAGNOSTIC ARRAYS USED FOR CHECKING ENERGY AND WATER 
C     * BALANCES.
C
CDAN      REAL, DIMENSION(ILG) :: CTVSTP, CTSSTP, CT1STP, 
      REAL, DIMENSION(:), ALLOCATABLE :: CTVSTP, CTSSTP, CT1STP, 
     1  CT2STP, CT3STP, WTVSTP, WTSSTP, WTGSTP



C     * COMMON BLOCK PARAMETERS (CLASS): 
C
      INTEGER :: K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11
C
      REAL :: X1, X2, X3, X4, G, GAS, X5, X6, CPRES, GASV, X7, CPI, X8, 
     1  CELZRO, X9, X10, X11, X12, X13, X14, X15, SIGMA, X16, DELTIM, 
     2  DELT, TFREZ, RGAS, RGASV, GRAV, SBC, VKC, CT, VMIN, TCW, TCICE, 
     3  TCSAND, TCCLAY, TCOM, TCDRYS, RHOSOL, RHOOM, HCPW, HCPICE, 
     4  HCPSOL, HCPOM, HCPSND, HCPCLY, SPHW, SPHICE, SPHVEG, SPHAIR, 
     5  RHOW, RHOICE, TCGLAC, CLHMLT, CLHVAP, PI, ZOLNG, ZOLNS, ZOLNI, 
     6  ZORATG, ALVSI, ALIRI, ALVSO, ALIRO, ALBRCK, DELTA, CGRAV, 
     7  CKARM, CPD, AS, ASX, CI, BS, BETA, FACTN, HMIN
C
      REAL, DIMENSION(ICAN) :: CANEXT, XLEAF, ZORAT
CDAN  * CONFLICTS WITH COMMON BLOCK DEFINITIONS (APR 20/08)
CDAN      REAL, DIMENSION(:), ALLOCATABLE :: CANEXT, XLEAF, ZORAT
C
      REAL, DIMENSION(3) :: THPORG, THRORG, THMORG, BORG, PSISORG, 
     1  GRKSORG
C
      REAL, DIMENSION(18, 4, 2) :: GROWYR


C=======================================================================
CDAN  * GLOBAL SUBROUTINES AND VARIABLES

CDAN  * SOME SUBROUTINES AND VARIABLES HAVE BEEN TAKEN FROM RTE.EXE TO 
CDAN  * READ THE BASIN SHD FILE AND WRITE THE RTE.EXE INPUT FILES 
CDAN  * (RUNOFF, RECHARGE, AND LEAKAGE VALUES).  TO FOLLOW THE 
CDAN  * PROGRAMMING METHODS USED BY RTE.EXE, THESE SUBROUTINES AND 
CDAN  * VARIABLES HAVE REMAINED GLOBAL AND ARE ACCESSIBLE BY CALLING 
CDAN  * AREA_WATFLOOD AND EF_MODULE USING THE "USE" COMMAND.  THE 
CDAN  * GLOBAL SUBROUTINES AND VARIABLES THAT ARE USED BY MESH_DRIVER 
CDAN  * ARE LISTED BELOW.

CDAN  * SUBROUTINES AND MODULES: 
CDAN
CDAN  * RDEVT: SUBROUTINE USED TO READ THE EVENT FILE (EVENT/EVENT.EVT)
CDAN  * READ_SHED_EF: SUBROUTINE USED TO READ THE BASIN SHD FILE
CDAN  * WRITE_R2C: SUBROUTINE USED TO WRITE R2C-FORMAT RTE.EXE INPUT 
CDAN  *            FILES (RUNOFF, RECHARGE, AND LEAKAGE VALUES)
CDAN  * AREA_WATFLOOD: MODULE CONTAINING VARIABLE DEFINITIONS
CDAN  * EF_MODULE: MODULE CONTAINING FORMATTING FUNCTIONS AND 
CDAN  *            SUBROUTINES
CDAN  * EF_PARSEUTILITIES: MODULE CONTAINING FORMATTING FUNCTIONS AND 
CDAN  *                    SUBROUTINES CALLED BY EF_MODULE
CDAN  * FIND_MONTH: SUBROUTINE USED TO CONVERT JULIAN DAY FROM YEAR 
CDAN  *             START INTO MONTH FROM YEAR START (1 TO 12)
CDAN  * FIND_DAY: SUBROUTINE USED TO CONVERT JULIAN DAY FROM YEAR START 
CDAN  *           INTO DAY FROM MONTH START (1 TO 31)

CDAN  * VARIABLES: 
CDAN
CDAN  * FLN: CONTAINS BASIN SHD AND RTE.EXE INPUT FILES' FILE NAMES
CDAN  * XCOUNT_TEMP, XCOUNT: NUMBER OF GRID SQUARES IN X-DIRECTION OF 
CDAN  *                      BASIN (COLUMNS) (JMAX)
CDAN  * YCOUNT_TEMP, YCOUNT: NUMBER OF GRID SQUARES IN Y-DIRECTION OF 
CDAN  *                      BASIN (ROWS) (IMAX)
CDAN  * AL: SINGLE GRID SIDE LENGTH IN METRES (AL)
CDAN  * NA: NUMBER OF GRID SQUARES IN BASIN (WF_NA)
CDAN  * NAA: NUMBER OF GRID SQUARE OUTLETS IN BASIN (NAA)
CDAN  * NTYPE: NUMBER OF GRUS (WF_NTYPE)
CDAN  * FRAC: GRID FRACTION (WF_FRAC)
CDAN  * ACLASS: PERCENT-GRU FRACTION FOR EACH GRID SQUARE (WF_ACLASS)
CDAN  * OUTARRAY: USED TO PASS DATA TO WRITE_R2C
CDAN  * AUTHOR: PROGRAM NAME = 'MESH_DRIVER' (PASSED TO WRITE_R2C)
CDAN  * MODELFLG: WATROUTE CONFIGURATION (FROM EVENT FILE)
CDAN  * COORDSYS_TEMP, COORDSYS1: CO-ORDINATE SYSTEM (FROM BASIN SHD 
CDAN  *                           FILE) (PASSED TO WRITE_R2C)
CDAN  * ZONE_TEMP, ZONE1: CO-ORDINATE SYSTEM (FROM BASIN SHD FILE) 
CDAN  *                   (PASSED TO WRITE_R2C)
CDAN  * DATUM_TEMP, DATUM1: CO-ORDINATE SYSTEM (FROM BASIN SHD FILE) 
CDAN  *                     (PASSED TO WRITE_R2C)
CDAN  * XORIGIN_TEMP, XORIGIN: X-DIRECTION CO-ORDINATE OF BASIN GRID 
CDAN  *                        (FROM BASIN SHD FILE) (PASSED TO 
CDAN  *                        WRITE_R2C)
CDAN  * YORIGIN_TEMP, YORIGIN: Y-DIRECTION CO-ORDINATE OF BASIN GRID 
CDAN  *                        (FROM BASIN SHD FILE) (PASSED TO 
CDAN  *                        WRITE_R2C)
CDAN  * XDELTA_TEMP, XDELTA: AVERAGE DIFFERENCE BETWEEN TWO X-DIRECTION 
CDAN  *                      SIDES OF GRID SQUARE (FROM BASIN SHD FILE) 
CDAN  *                      (PASSED TO WRITE_R2C)
CDAN  * YDELTA_TEMP, YDELTA: AVERAGE DIFFERENCE BETWEEN TWO Y-DIRECTION 
CDAN  *                      SIDES OF GRID SQUARE (FROM BASIN SHD FILE) 
CDAN  *                      (PASSED TO WRITE_R2C)
CDAN  * SOURCE_FILE_NAME: DATA SOURCE = 'CLASS' (PASSED TO WRITE_R2C)
CDAN  * NAME: R2C-FORMAT DATA FILE NAME (PASSED TO WRITE_R2C)
CDAN  * ATTRIBUTE_NAME: R2C-FORMAT DATA IDENTIFER (PASSED TO WRITE_R2C)
CDAN  * ATTRIBUTE_UNITS: R2C-FORMAT DATA UNITS (PASSED TO WRITE_R2C)
CDAN  * ATTRIBUTE_TYPE: R2C-FORMAT DATA TYPE (PASSED TO WRITE_R2C)
CDAN  * YEAR1: YEAR OF CURRENT TIME STEP (IYEAR) (PASSED TO WRITE_R2C)
CDAN  * MONTH_NOW: MONTH OF CURRENT TIME STEP (1 TO 12) (PASSED TO 
CDAN  *            WRITE_R2C)
CDAN  * DAY_NOW: DAY OF CURRENT TIME STEP (1 TO 31) (PASSED TO 
CDAN  *          WRITE_R2C)
CDAN  * HOUR_NOW: HOUR OF CURRENT TIME STEP (IHOUR + 1) (1 TO 24) 
CDAN  *           (PASSED TO WRITE_R2C)
CDAN  * YYY: Y-DIRECTION GRID SQUARE CO-ORDINATE (YYY)
CDAN  * XXX: X-DIRECTION GRID SQUARE CO-ORDIANTE (XXX)


C=======================================================================
C     * SET PHYSICAL CONSTANTS AND COMMON BLOCKS

      COMMON    /PARAMS/    X1, X2, X3, X4, G, GAS, X5, X6, CPRES, 
     1                      GASV, X7
      COMMON    /PARAM1/    CPI, X8, CELZRO, X9, X10, X11
      COMMON    /PARAM3/    X12, X13, X14, X15, SIGMA, X16
      COMMON    /TIMES/     DELTIM, K1, K2, K3, K4, K5, K6, K7, K8, K9, 
     1                      K10, K11

C     * THE FOLLOWING COMMON BLOCKS ARE DEFINED SPECIFICALLY FOR USE 
C     * IN CLASS, VIA BLOCK DATA AND THE SUBROUTINE "CLASSD".
      COMMON    /CLASS1/    DELT, TFREZ
      COMMON    /CLASS2/    RGAS, RGASV, GRAV, SBC, VKC, CT, VMIN
      COMMON    /CLASS3/    TCW, TCICE, TCSAND, TCCLAY, TCOM, TCDRYS, 
     1                      RHOSOL, RHOOM
      COMMON    /CLASS4/    HCPW, HCPICE, HCPSOL, HCPOM, HCPSND, 
     1                      HCPCLY, SPHW, SPHICE, SPHVEG, SPHAIR, RHOW, 
     2                      RHOICE, TCGLAC, CLHMLT, CLHVAP
      COMMON    /CLASS5/    THPORG, THRORG, THMORG, BORG, PSISORG, 
     1                      GRKSORG
      COMMON    /CLASS6/    PI, GROWYR, ZOLNG, ZOLNS, ZOLNI, ZORAT, 
     1                      ZORATG
      COMMON    /CLASS7/    CANEXT, XLEAF
      COMMON    /CLASS8/    ALVSI, ALIRI, ALVSO, ALIRO, ALBRCK
      COMMON    /PHYCON/    DELTA, CGRAV, CKARM, CPD
      COMMON    /SURFCON/   AS, ASX, CI, BS, BETA, FACTN, HMIN

C     * THE FOLLOWING COMMON BLOCKS ARE DEFINED FOR WATROF
      COMMON    /WATFLGS/   VICEFLG, PSI_LIMIT, HICEFLG, LZFFLG, 
     1                      EXTFLG, IWFICE, ERRFLG, IMIN, IHOUR, IDAY, 
     2                      IYEAR

      DATA VICEFLG/3.0/, PSI_LIMIT/1.0/, HICEFLG/1.0/, LZFFLG/0/, 
     1  EXTFLG/0/, IWFICE/3/, ERRFLG/1/


C=======================================================================
C     * PROGRAM START

      WRITE (6, 8100), TRIM (RELEASE), TRIM (VERSION) !MESH VERSION
8100  FORMAT (' MESH 'A, ' ('A')'/)

C=======================================================================
C     * INITIALIZE CLASS VARIABLES
C     * SET COMMON CLASS PARAMETERS.

      CALL CLASSD


C=======================================================================
C     * SET RUN OPTIONS
C     * READ THE RUN_OPTIONS.INI INPUT FILE TO SET OR RESET ANY CONTROL 
C     * FLAGS AND READ THE GRID OUTPUT DIRECTORIES.

C     * IF IDISP = 0, VEGETATION DISPLACEMENT HEIGHTS ARE IGNORED,
C     * BECAUSE THE ATMOSPHERIC MODEL CONSIDERS THESE TO BE PART OF THE 
C     * "TERRAIN".
C     * IF IDISP = 1, VEGETATION DISPLACEMENT HEIGHTS ARE CALCULATED.
      IDISP = 1

C     * IF IZREF = 1, THE BOTTOM OF THE ATMOSPHERIC MODEL IS TAKEN TO 
C     * LIE AT THE GROUND SURFACE.
C     * IF IZREF = 2, THE BOTTOM OF THE ATMOSPHERIC MODEL IS TAKEN TO 
C     * LIE AT THE LOCAL ROUGHNESS HEIGHT.
      IZREF = 1

C     * IF ISLFD = 0, DRCOEF IS CALLED FOR SURFACE STABILITY 
C     * CORRECTIONS AND THE ORIGINAL GCM SET OF SCREEN-LEVEL DIAGNOSTIC 
C     * CALCULATIONS IS DONE.
C     * IF ISLFD = 1, DRCOEF IS CALLED FOR SURFACE STABILITY 
C     * CORRECTIONS AND SLDIAG IS CALLED FOR SCREEN-LEVEL DIAGNOSTIC 
C     * CALCULATIONS. 
C     * IF ISLFD = 2, FLXSURFZ IS CALLED FOR SURFACE STABILITY 
C     * CORRECTIONS AND DIASURF IS CALLED FOR SCREEN-LEVEL DIAGNOSTIC 
C     * CALCULATIONS. 
      ISLFD = 2

C     * IF IPCP = 1, THE RAINFALL-SNOWFALL CUTOFF IS TAKEN TO LIE AT 
C     * 0 dC.
C     * IF IPCP = 2, A LINEAR PARTITIONING OF PRECIPITATION BETWEEEN 
C     * RAINFALL AND SNOWFALL IS DONE BETWEEN 0 dC AND 2 dC.
C     * IF IPCP = 3, RAINFALL AND SNOWFALL ARE PARTITIONED ACCORDING TO 
C     * A POLYNOMIAL CURVE BETWEEN 0 dC AND 6 dC.
      IPCP = 1

C     * ITC, ITCG AND ITG ARE SWITCHES TO CHOOSE THE ITERATION SCHEME 
C     * TO BE USED IN CALCULATING THE CANOPY OR GROUND SURFACE 
C     * TEMPERATURE RESPECTIVELY.  IF THE SWITCH IS SET TO 1, A 
C     * COMBINATION OF SECANT AND BISECTION METHODS IS USED; IF TO 2, 
C     * THE NEWTON-RAPHSON METHOD IS USED.
      ITC = 2
      ITCG = 2
      ITG = 2

C     * IF IWF = 0, ONLY OVERLAND FLOW AND BASEFLOW ARE MODELLED, AND 
C     * THE GROUND SURFACE SLOPE IS NOT MODELLED.
C     * IF IWF = n (0 < n < 4), THE MODIFIED CALCULATIONS OF OVERLAND 
C     * FLOW AND INTERFLOW ARE PERFORMED; INTERFLOW IS DRAWN FROM THE 
C     * TOP n SOIL LAYERS.
      IWF = 3

C     * IF ILAI, IHGT, IALC, IALS AND IALG ARE ZERO, THE VALUES OF 
C     * LEAF ARE INDEX, VEGETATION HEIGHT, CANOPY ALBEDO, SNOW ALBEDO 
C     * AND SOIL ALBEDO RESPECTIVELY CALCULATED BY CLASS ARE USED.
C     * IF ANY OF THESE SWITCHES IS SET TO 1, THE VALUE OF THE 
C     * CORRESPONDING PARAMETER CALCULATED BY CLASS IS OVERRIDDEN BY 
C     * A USER-SUPPLIED INPUT VALUE.
      ILAI = 0
      IHGT = 0
      IALC = 0
      IALS = 0
      IALG = 0

C     * SET N = 0 RESETS THE CLASS COUNTER.
      N = 0

CDAN  * IF BINFLG = 1.0, FORCING DATA IS READ EVERY TWO TIME STEPS 
CDAN  * (HOURLY) FROM THE FORCING.BIN FILE.
CDAN  * IF BINFLG = 2.0, FORCING DATA IS READ EVERY TIME STEP 
CDAN  * (HALF-HOURLY) FROM THE FORCING.BIN FILE.
CDAN  * BINFLG MAY BE RESET IN RUN_OPTIONS.INI
      BINFLG = 1.0

CDAN  * IF RELFLG = 0.0, ANY CONFIGURATION FILE IS READ THAT MATCHES 
CDAN  * THE FILE NAME IN THE OPEN STATEMENT.
CDAN  * IF RELFLG = 1.0, ONLY CONFIGURATION FILES WHOSE VERSION MATCHES 
CDAN  * THE RELEASE OF MESH_DRIVER ARE READ.  THE PROGRAM STOPS IF THE 
CDAN  * TWO STRINGS DO NOT MATCH.
CDAN  * THIS FLAG IS NOT APPLICABLE TO RUN_OPTIONS.INI, WHERE THIS FLAG 
CDAN  * MAY BE RESET).
      RELFLG = 1.0

CDAN  * IF ID = 1, RDEVT WILL READ THE NEW FORMAT EVENT FILE (VERSION 
CDAN  * 9.7 OF THE EVENT FILE WAS USED IN TESTING).
      ID = 1


      !set HOURLYFLAG to 1 for hourly forcing data
      !set HOURLYFLAG to 0 for 30 minute forcing data
      ! 30 minute forcing data should be the default
      HOURLYFLAG = 0

! The above parameter values are defaults, to change to a different
! value, use the MESH_input_run_options.ini file


! Set the default value of BASIN_FRACTION so that it will be initialised
! correctly later
!ANDY      BASIN_FRACTION(1) = -1
      
c *********************************************************************
c Open and read in values from MESH_input_run_options.ini file
c *********************************************************************

      OPEN (53, FILE="MESH_input_run_options.ini", STATUS="OLD", 
     1  IOSTAT=IOS)
      IF (IOS .NE. 0) THEN !CHECK FILE FOR IOSTAT ERRORS
        WRITE (6, 8400)
        WRITE (6, *) "MESH_input_run_options.ini ", 
     1      "could not be opened.  Ensure that the file exists and ", 
     2      "restart the program."
        STOP
      ELSE
        WRITE (6, 8200, ADVANCE="NO"), 
     +   "MESH_input_run_options.ini"
      END IF

      DO I=1,3
        READ(53,*)
      ENDDO

      READ(53,"(I5)") CONFLAGS

      ! Set flag values based on given input
      IF(CONFLAGS>0) THEN
        DO I=1,CONFLAGS
          READ(53,"(A20, I4)") IRONAME, IROVAL
          IF (IRONAME == "IDISP") THEN
            IDISP = IROVAL
          ELSE IF (IRONAME == "IZREF") THEN
            IZREF = IROVAL
          ELSE IF (IRONAME == "ISLFD") THEN
            ISLFD = IROVAL
          ELSE IF (IRONAME == "IPCP") THEN
            IPCP = IROVAL
          ELSE IF (IRONAME == "ITC") THEN
            ITC = IROVAL
          ELSE IF (IRONAME == "ITCG") THEN
            ITCG = IROVAL
          ELSE IF (IRONAME == "ITG") THEN
            ITG = IROVAL
          ELSE IF (IRONAME == "IWF") THEN
            IWF = IROVAL
          ELSE IF (IRONAME == "ILAI") THEN
            ILAI = IROVAL
          ELSE IF (IRONAME == "IHGT") THEN
            IHGT = IROVAL
          ELSE IF (IRONAME == "IALC") THEN
            IALC = IROVAL
          ELSE IF (IRONAME == "IALS") THEN
            IALS = IROVAL
          ELSE IF (IRONAME == "IALG") THEN
            IALG = IROVAL
          ELSE IF (IRONAME == "N") THEN
            N = IROVAL
          ELSE IF (IRONAME == "HOURLYFLAG") THEN
            HOURLYFLAG = IROVAL
          ELSE IF (IRONAME == "RELFLG") THEN
            RELFLG = IROVAL
          ELSE
            ! Error when reading the input file
            WRITE (*, *)
     *        "The input file is corrupted in the flags information."
          END IF
        ENDDO
      ENDIF

      DO I=1,2
        READ(53,*)
      ENDDO
      
      READ (53, "(I5)") WF_NUM_POINTS !READ GRID OUTPUT POINTS
      IF (WF_NUM_POINTS .GT. M_G) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Number of grid output points supported: ", M_G
        WRITE (6, *) "Grid output points from ", 
     1      "MESH_input_run_options.ini: ", WF_NUM_POINTS
        WRITE (6, *) "Please adjust the number of grid output points ", 
     1      "in this file."
        CLOSE (53)
        STOP
      END IF
	
      READ (53, *) !BLANK LINES: FIELD HEADER

C     * DIMENSION GRID OUTPUT POINT VARIABLES
      IF (WF_NUM_POINTS .GT. 0) THEN
        ALLOCATE (DIR_OUT(WF_NUM_POINTS), N_OUT(WF_NUM_POINTS), 
     1      II_OUT(WF_NUM_POINTS), STAT=PAS)
        IF (PAS. NE. 0) THEN
            WRITE (6, 8400)
            WRITE (6, *) "Error allocating grid output point ", 
     1          "variables.  Check that these bounds are within an ", 
     1          "acceptable range."
            WRITE (6, *) "Bound 1 (grid output points): ", WF_NUM_POINTS
            CLOSE (53)
            STOP
        END IF
        READ (53, "(5I10)") (N_OUT(I), I=1, WF_NUM_POINTS)
        READ (53, "(5I10)") (II_OUT(I), I=1, WF_NUM_POINTS)
        READ (53, "(5A10)") (DIR_OUT(I), I=1, WF_NUM_POINTS)
      ELSE !FOR GENERAL PURPOSES
        READ(53,*)
        READ(53,*)
        READ(53,*)
        ALLOCATE (DIR_OUT(1), N_OUT(1), II_OUT(1))
      END IF !(WF_NUM_POINTS .GT. 0)
      
      DO I = 1, WF_NUM_POINTS
CDAN (MAY 12 2008): BASIN WATERSHED FILE HAS NOT BEEN READ
CDAN        IF (N_OUT(I) .GT. NLTEST) THEN !IF EXISTS IN BASIN
CDAN            WRITE (6, 8400)
CDAN            WRITE (6, *) "Grids from basin watershed file: ", NLTEST
CDAN            WRITE (6, *) "Grid output point ", I, " is in Grid: ", 
CDAN     1          N_OUT(I)
CDAN            WRITE (6, *) "Please adjust this grid output point in ", 
CDAN     1          "MESH_input_run_options.ini"
CDAN            STOP
CDAN        ELSEIF (I .LT. WF_NUM_POINTS) THEN !IF IS REPEATED
        IF (I .LT. WF_NUM_POINTS) THEN !IF IS REPEATED
          DO J = I + 1, WF_NUM_POINTS
            IF (N_OUT(I).EQ.N_OUT(J) .AND. 
     1        II_OUT(I).EQ.II_OUT(J)) THEN
              WRITE (6, 8400)
	        WRITE (6, *) "Output for Grid ", N_OUT(I), " and GRU ", 
     1          II_OUT(I)
	        WRITE (6, *) "is repeated in grid output point ", J, "."
              WRITE (6, *) "Please adjust this grid output ", 
     1          "point in MESH_input_run_options.ini"
	        STOP
	      END IF
          END DO
        ELSE !IF DIRECTORY EXISTS
          OPEN (17, FILE=".\"// TRIM (ADJUSTL (DIR_OUT(I)))// 
     1      "\fort.17", STATUS="UNKNOWN", IOSTAT=IOS)
          IF (IOS .NE. 0) THEN !TRY WRITING DUMMY FILE TO DIRECTORY
            WRITE (6, 8400)
            WRITE (6, *) "Grid output point ", I
            WRITE (6, *) "The output directory does not exist: ", 
     1        TRIM (ADJUSTL (DIR_OUT(I)))
            WRITE (6, *) "Please adjust this grid output point ", 
     1        "in MESH_input_run_options.ini or create the ", 
     2        "folder."
            STOP
          ELSE
            CLOSE (17, STATUS="DELETE") !DELETE DUMMY FILE
          END IF
	  END IF
	END DO

      !This is the directory to output the mesh_output* files and the basin_swe/sca files
      READ(53,*)
      READ(53,*)
      READ(53,'(A10)') GENDIR_OUT
      PRINT *, GENDIR_OUT

!PARAMESH
      !This section is used to start part way through the bin file
      READ(53,*) !P
      READ(53,*) !P
      READ(53,'(I4, I4, I4, I4)') IYEAR_START, IDAY_START, !P
     +  IHOUR_START, IMIN_START !P
      READ(53,'(I4, I4, I4, I4)') IYEAR_END, IDAY_END, !P
     +  IHOUR_END, IMIN_END !P

      CLOSE(UNIT=53)
      WRITE (6, FMT=*) " READ: SUCCESSFUL, FILE: CLOSED"

C=======================================================================
CDAN  * READ EVENT FILE
CDAN  * GATHER FILE NAMES THAT ARE REQUIRED TO READ THE BASIN SHD FILE, 
CDAN  * AND WRITE THE RTE.EXE INPUT FILES (RUNOFF, RECHARGE, LEAKAGE).

CDAN  * MUST ALLOCATE AND ADD "EVENT/EVENT.EVT" TO FLN.  FLN IS 
CDAN  * ALLOCATED TO THE SAME LIMIT AS IN RTE.EXE
c 
! And 
c Open and read in values from new_shd.r2c file
c *********************************************************************
 
      ALLOCATE (FLN(999))
      FLN(99) = "event/event.evt"
      
      OPEN(UNIT=12,FILE='event/event.evt',STATUS='OLD',IOSTAT=IOS_EVT)
      OPEN(UNIT=20,FILE='new_shd.r2c',STATUS='OLD',IOSTAT=IOS)
      IF (IOS_EVT == 0 .and. IOS == 0) THEN
        CLOSE(12)
CDAN  * CALL RDEVT TO READ THE EVENT FILE
        WRITE (6, 8200, ADVANCE="NO") "event/event.evt"
        CALL RDEVT (DATE, CONV, SCALE, SMC5, NHG, NHF)
        WRITE (6, *) " READ: SUCCESSFUL, FILE: CLOSED"
      
     
!        OPEN(UNIT=20,FILE='new_shd.r2c',STATUS='OLD',IOSTAT=IOS)
      
!        IF (IOS /= 0) THEN
        PRINT *, "Reading Drainage Database from new_shd.r2c"
!        WRITE (6, 8200, ADVANCE="NO") TRIM (ADJUSTL (FLN(1)))
        CALL READ_SHED_EF (31, 1)
        WRITE (6, *) " READ: SUCCESSFUL, FILE: CLOSED"
!        ALLOCATE (FRAC(NA), 
        ALLOCATE (FSDOWN(NA),SNOGRD(NA),BASIN_FRACTION(NA))
        
        BASIN_FRACTION(1) = -1
      
      ELSE

c *********************************************************************
c Open and read in values from MESH_input_drainage_database.txt file
c   if new_shd.r2c file was not found
c *********************************************************************
      OPEN(UNIT=20,FILE='MESH_input_drainage_database.txt',STATUS='OLD')
      PRINT *, "Reading Drainage Database from ",
     +   "MESH_input_drainage_database.txt"
      
      READ(20,'(I5,50X,I5)') NA,NAA
      READ(20,'(F10.0,5X,2I5)') AL,NRVR,NTYPE
      GRDN=0.0
      GRDE=0.0
      
      
!ANDY Set NLAT, NMOS, and ILG from the read-in values
      NLAT = NA
      NMOS = NTYPE
      ILG = NLAT*NMOS
      PRINT*,"NLAT",NLAT,"NMOS",NMOS,"ILG",ILG


c     IOSTAT capture prevents error when not all values present
      READ(20,'(12I5,2F5.0)',IOSTAT=IOS) IYMIN,WF_IYMAX,
     +  JXMIN,WF_JXMAX,LATDEGMIN,LATMINMIN,LATDEGMAX,LATMINMAX,
     +  LONDEGMIN,LONMINMIN,LONDEGMAX,LONMINMAX,GRDN,GRDE

c     Condition for Lat/Long by Frank S Sept/1999
      IF( GRDN>0.0 ) THEN
        IYMIN=LATDEGMIN*60+LATMINMIN
        WF_IYMAX=LATDEGMAX*60+LATMINMAX
        JXMIN=LONDEGMIN*60+LONMINMIN
        WF_JXMAX=LONDEGMAX*60+LONMINMAX

      ELSE
c       Define GRDN & GRDE for UTM
        GRDN=AL/1000.
        GRDE=AL/1000.
      ENDIF

      READ(20,'(2I5)') YCOUNT, XCOUNT

c check if we are going to get an "array bounds out of range" error
      IF(YCOUNT>M_Y) THEN
        PRINT *, 'size of grid arrays in MESH: ',M_Y
        PRINT *, 'number up/down (north/south) ',
     +           'grids from MESH_drainage_database.txt'
	  PRINT *, ' file: ',YCOUNT
        PRINT *, 'Please adjust these values.'
        STOP
	ENDIF

      IF(XCOUNT>M_X) THEN
        PRINT *, 'size of grid arrays in MESH: ',M_X
        PRINT *, 'no. of east/west (left/right) grids from ',
     +           'MESH_drainage_database.txt'
	  PRINT *, ' file: ',XCOUNT
        PRINT *, 'Please adjust these values.'
        STOP
	ENDIF

	
      !ANDY Allocation of variables that use NLAT and NMOS
      ALLOCATE(WF_IBN(NA), WF_IROUGH(NA),
     +  WF_ICHNL(NA), WF_NEXT(NA), WF_ELEV(NA), WF_IREACH(NA),
     +  WF_DA(NA), WF_BNKFLL(NA), WF_CHANNELSLOPE(NA),
     +  FRAC(NA), BASIN_FRACTION(NA), WF_NHYD(NA), WF_QR(NA),
     +  WF_QBASE(NA), WF_QI2(NA), WF_QO1(NA), WF_QO2(NA),
     +  WF_STORE1(NA), WF_STORE2(NA), WF_QI1(NA), SNOGRD(NA),
     +  FSDOWN(NA))
      ALLOCATE(ACLASS(NA,NTYPE), wc_algwet(NA,NTYPE),
     +  wc_algdry(NA,NTYPE))
      ALLOCATE(wc_thpor(NA,NTYPE,IGND), wc_thlret(NA,NTYPE,IGND),
     +  wc_thlmin(NA,NTYPE,IGND), wc_bi(NA,NTYPE,IGND),
     +  wc_psisat(NA,NTYPE,IGND), wc_grksat(NA,NTYPE,IGND),
     +  wc_hcps(NA,NTYPE,IGND), wc_tcs(NA,NTYPE,IGND))
      
!ANDY Zero everything we just allocated
      DO I=1,NLAT
        DO J=1,NMOS
          DO K=1,IGND
            wc_thpor(I,J,K) = 0
            wc_thlret(I,J,K) = 0
            wc_thlmin(I,J,K) = 0
            wc_bi(I,J,K) = 0
            wc_psisat(I,J,K) = 0
            wc_grksat(I,J,K) = 0
            wc_hcps(I,J,K) = 0
            wc_tcs(I,J,K) = 0
          ENDDO
          ACLASS(I,J) = 0
          wc_algwet(I,J) = 0
          wc_algdry(I,J) = 0
        ENDDO
        WF_IBN(I) = 0
        WF_IROUGH(I) = 0
        WF_ICHNL(I) = 0
        WF_NEXT(I) = 0
        WF_ELEV(I) = 0
        WF_IREACH(I) = 0
        WF_DA(I) = 0
        WF_BNKFLL(I) = 0
        WF_CHANNELSLOPE(I) = 0
        FRAC(I) = 0
        BASIN_FRACTION(I) = 0
        WF_NHYD(I) = 0
        WF_QBASE(I) = 0
        WF_QI2(I) = 0
        WF_QO1(I) = 0
        WF_QO2(I) = 0
        WF_QR(I) = 0
        WF_STORE1(I) = 0
        WF_STORE2(I) = 0
        WF_QI1(I) = 0
      ENDDO

      !Set this to ensure basin fraction will be set later on
      BASIN_FRACTION(1) = -1
      
      
      ALLOCATE(YYY(NA),XXX(NA))
	


      DO I = 1, YCOUNT
        READ(20,*)
      ENDDO

      DO I = 1,NA
        READ(20,'(5X,2I5,3F10.5,I7,5I5,F5.2,5X,15F5.2)')YYY(I),
     +    XXX(I),WF_DA(I),WF_BNKFLL(I),WF_CHANNELSLOPE(I),
     +    WF_ELEV(I),WF_IBN(I),WF_IROUGH(I),WF_ICHNL(I),
     +    WF_NEXT(I),WF_IREACH(I),FRAC(I),
     +    (ACLASS(I,J),J=1,NTYPE)
C check to make sure land cover areas sum to 100%
        WF_LAND_COUNT=1
        WF_LAND_MAX=0.0
        WF_LAND_SUM=0.0
        DO J=1,NTYPE
          WF_LAND_SUM=WF_LAND_SUM+ACLASS(I,J)
          IF(ACLASS(I,J)>WF_LAND_MAX) THEN
            WF_LAND_COUNT=J
    	      WF_LAND_MAX=ACLASS(I,J)
          ENDIF
        ENDDO
	  IF(WF_LAND_SUM/=1.0)THEN
	    ACLASS(I,WF_LAND_COUNT)=
     +    ACLASS(I,WF_LAND_COUNT)-(WF_LAND_SUM-1.0)
        ENDIF
      ENDDO

      CLOSE(UNIT=20)
      ENDIF            

      IF (XCOUNT .GT. M_X) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Number of x-direction cells supported: ", M_X
        WRITE (6, *) "x-direction cells from basin watershed file: ", 
     1      XCOUNT
        WRITE (6, *) "Please adjust x-direction cells in ", 
     1      "the basin watershed file."
CDAN        CLOSE (20)
        STOP
      END IF
      IF (YCOUNT .GT. M_Y) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Number of y-direction cells supported: ", M_Y
        WRITE (6, *) "y-direction cells from basin watershed file: ", 
     1      YCOUNT
        WRITE (6, *) "Please adjust y-direction cells in ", 
     1      "the basin watershed file."
CDAN        CLOSE (20)
        STOP
      END IF

C     * CHECK THAT GRID OUTPUT POINTS ARE IN THE BASIN
      DO I = 1, WF_NUM_POINTS
        IF (N_OUT(I) .GT. NA) THEN !IF EXISTS IN BASIN
            WRITE (6, 8400)
            WRITE (6, *) "Grids from basin watershed file: ", NA
            WRITE (6, *) "Grid output point ", I, " is in Grid: ", 
     1          N_OUT(I)
            WRITE (6, *) "Please adjust this grid output point in ", 
     1          "MESH_input_run_options.ini"
            STOP
        END IF
      END DO

C     * CHECK THAT NUMBER OF GRID SQUARES IS WITHIN PROGRAMMED BOUNDS
CDAN      IF (WF_NA .GT. NLAT) THEN
!      IF (NA .GT. NLAT) THEN
!        WRITE (6, 8400)
!        WRITE (6, *) "Number of grid squares supported: ", NLAT
!        WRITE (6, *) "Grid squares from basin watershed file: ", NA
!        WRITE (6, *) "Please adjust the grid squares in ", 
!CDAN     1      "MESH_input_drainage_database.txt"
!     1      "the basin watershed file."
!	  STOP
!	ENDIF

!C     * CHECK THAT NUMBER OF GRUS IS WITHIN PROGRAMMED BOUNDS
!      IF (NTYPE .GT. NMOS) THEN
!        WRITE (6, 8400)
!        WRITE (6, *) "Number of GRUs supported: ", NMOS
!        WRITE (6, *) "GRUs from basin watershed file: ", NTYPE
!        WRITE (6, *) "Please adjust the GRUs in ", 
!CDAN     1      "MESH_input_drainage_database.txt"
!     1      "the basin watershed file."
!	  STOP
!	ENDIF
  
C=======================================================================
C     * ALLOCATE ALL VARIABLES
CDAN  IGND, ICAN, AND ICP1 HAVE BEEN INCLUDED IN CASE THEY WILL BE  
CDAN  CONFIGURABLE IN THE FUTURE (IF IN THE RUN_OPTIONS.INI FILE)
CDAN  (APR 20/08).

C     * GRID OUTPUT SUMMARY VARIABLES: 
      IF (WF_NUM_POINTS .GT. 0) THEN
        ALLOCATE (PRE_OUT(WF_NUM_POINTS), EVAP_OUT(WF_NUM_POINTS), 
     1      ROF_OUT(WF_NUM_POINTS), STAT=PAS)
        IF (PAS. NE. 0) THEN
            WRITE (6, 8400)
            WRITE (6, *) "Error allocating grid output summary ", 
     1          "variables.  Check that these bounds are within an ", 
     2          "acceptable range."
            WRITE (6, *) "Bound 1 (grid output points): ", WF_NUM_POINTS
            STOP
        END IF
      ELSE !FOR GENERAL PURPOSES
        ALLOCATE (PRE_OUT(1), EVAP_OUT(1), ROF_OUT(1))
      END IF !(WF_NUM_POINTS .GT. 0)

C     * WATROUTE INPUT FILES: 
      ALLOCATE (OUTARRAY(YCOUNT, XCOUNT), RUNOFF(YCOUNT, XCOUNT), 
CDAN     1  RECHARGE(YCOUNT, XCOUNT), LEAKAGE(YCOUNT, XCOUNT), STAT = PAS)
     1  RECHARGE(YCOUNT, XCOUNT), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating WATROUTE input variables.  ", 
     1      "Check that these bounds are within an acceptable range."
        WRITE (6, *) "Bound 1 (grid square rows): ", YCOUNT
        WRITE (6, *) "Bound 2 (grid square columns): ", XCOUNT
        STOP
      END IF

C     * MET. FORCING DATA: 
      ALLOCATE (R4SHRTGRID2D(YCOUNT, XCOUNT), 
     1  R4LONGGRID2D(YCOUNT, XCOUNT), R4RAINGRID2D(YCOUNT, XCOUNT), 
     2  R4TEMPGRID2D(YCOUNT, XCOUNT), R4WINDGRID2D(YCOUNT, XCOUNT), 
     3  R4PRESGRID2D(YCOUNT, XCOUNT), R4HUMDGRID2D(YCOUNT, XCOUNT), 
     4  STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating met. forcing data ", 
     1      "variables.  Check that bounds are within an acceptable ", 
     2      "range."
        WRITE (6, *) "Bound 1 (grid square rows): ", YCOUNT
        WRITE (6, *) "Bound 2 (grid square columns): ", XCOUNT
        STOP
      END IF

C     * LAND SURFACE PROGNOSTIC VARIABLES (CLASS.INI): 
      ALLOCATE (TBARROW(NA, NTYPE, IGND), 
     1  THLQROW(NA, NTYPE, IGND), THICROW(NA, NTYPE, IGND), 
     2  TBARGAT(NA*NTYPE, IGND), 
     3  THLQGAT(NA*NTYPE, IGND), THICGAT(NA*NTYPE, IGND), 
     4  TPNDROW(NA, NTYPE), ZPNDROW(NA, NTYPE), TBASROW(NA, NTYPE), 
     5  ALBSROW(NA, NTYPE), TSNOROW(NA, NTYPE), RHOSROW(NA, NTYPE), 
     6  SNOROW(NA, NTYPE), TCANROW(NA, NTYPE), RCANROW(NA, NTYPE), 
     7  SCANROW(NA, NTYPE), 
     8  GROROW(NA, NTYPE), CMAIROW(NA, NTYPE), TACROW(NA, NTYPE), 
     9  QACROW(NA, NTYPE), WSNOROW(NA, NTYPE), 
     A  TPNDGAT(NA*NTYPE), ZPNDGAT(NA*NTYPE), TBASGAT(NA*NTYPE), 
     B  ALBSGAT(NA*NTYPE), TSNOGAT(NA*NTYPE), RHOSGAT(NA*NTYPE), 
     C  SNOGAT(NA*NTYPE), TCANGAT(NA*NTYPE), RCANGAT(NA*NTYPE), 
     D  SCANGAT(NA*NTYPE), 
     E  GROGAT(NA*NTYPE), CMAIGAT(NA*NTYPE), TACGAT(NA*NTYPE), 
     F  QACGAT(NA*NTYPE), WSNOGAT(NA*NTYPE), 
     G  TSFSROW(NA, NTYPE, 4), 
     H  TSFSGAT(NA*NTYPE, 4), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating land surface prognostic ", 
     1      "variables.  Check that bounds are within an acceptable ", 
     2      "range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        WRITE (6, *) "Bound 3 (soil layers): ", IGND
        STOP
      END IF

C     * GATHER-SCATTER COUNTS: 
      ALLOCATE (ILMOS(NA*NTYPE), JLMOS(NA*NTYPE), IWMOS(NA*NTYPE), 
     1  JWMOS(NA*NTYPE), 
     2  IWAT(NA), IICE(NA), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating gather-scatter count ", 
     1      "variables.  Check that bounds are within an acceptable ", 
     2      "range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        STOP
      END IF

C     * CANOPY AND SOIL INFORMATION (CLASS): 
      ALLOCATE (FCANROW(NA, NTYPE, ICP1), LNZ0ROW(NA, NTYPE, ICP1), 
     1  ALVCROW(NA, NTYPE, ICP1), ALICROW(NA, NTYPE, ICP1), 
     2  FCANGAT(NA*NTYPE, ICP1), LNZ0GAT(NA*NTYPE, ICP1), 
     3  ALVCGAT(NA*NTYPE, ICP1), ALICGAT(NA*NTYPE, ICP1), 
     4  LAMXROW(NA, NTYPE, ICAN), LAMNROW(NA, NTYPE, ICAN), 
     5  CMASROW(NA, NTYPE, ICAN), ROOTROW(NA, NTYPE, ICAN), 
     6  RSMNROW(NA, NTYPE, ICAN), QA50ROW(NA, NTYPE, ICAN), 
     7  VPDAROW(NA, NTYPE, ICAN), VPDBROW(NA, NTYPE, ICAN), 
     8  PSGAROW(NA, NTYPE, ICAN), 
     9  PSGBROW(NA, NTYPE, ICAN), AILDROW(NA, NTYPE, ICAN), 
     A  HGTDROW(NA, NTYPE, ICAN), ACVDROW(NA, NTYPE, ICAN), 
     B  ACIDROW(NA, NTYPE, ICAN), 
     C  LAMXGAT(NA*NTYPE, ICAN), LAMNGAT(NA*NTYPE, ICAN), 
     D  CMASGAT(NA*NTYPE, ICAN), ROOTGAT(NA*NTYPE, ICAN), 
     E  RSMNGAT(NA*NTYPE, ICAN), QA50GAT(NA*NTYPE, ICAN), 
     F  VPDAGAT(NA*NTYPE, ICAN), VPDBGAT(NA*NTYPE, ICAN), 
     G  PSGAGAT(NA*NTYPE, ICAN), 
     H  PSGBGAT(NA*NTYPE, ICAN), AILDGAT(NA*NTYPE, ICAN), 
     I  HGTDGAT(NA*NTYPE, ICAN), ACVDGAT(NA*NTYPE, ICAN), 
     J  ACIDGAT(NA*NTYPE, ICAN), 
     K  THPROW(NA, NTYPE, IGND), THRROW(NA, NTYPE, IGND), 
     L  THMROW(NA, NTYPE, IGND), 
     M  BIROW(NA, NTYPE, IGND), PSISROW(NA, NTYPE, IGND), 
     N  GRKSROW(NA, NTYPE, IGND), THRAROW(NA, NTYPE, IGND), 
     O  HCPSROW(NA, NTYPE, IGND), TCSROW(NA, NTYPE, IGND), 
     P  THFCROW(NA, NTYPE, IGND), 
     Q  PSIWROW(NA, NTYPE, IGND), DLZWROW(NA, NTYPE, IGND), 
     R  ZBTWROW(NA, NTYPE, IGND), 
     S  THPGAT(NA*NTYPE, IGND), THRGAT(NA*NTYPE, IGND), 
     T  THMGAT(NA*NTYPE, IGND), 
     U  BIGAT(NA*NTYPE, IGND), PSISGAT(NA*NTYPE, IGND), 
     V  GRKSGAT(NA*NTYPE, IGND), THRAGAT(NA*NTYPE, IGND), 
     W  HCPSGAT(NA*NTYPE, IGND), TCSGAT(NA*NTYPE, IGND), 
     X  THFCGAT(NA*NTYPE, IGND), 
     Y  PSIWGAT(NA*NTYPE, IGND), DLZWGAT(NA*NTYPE, IGND), 
     Z  ZBTWGAT(NA*NTYPE, IGND), GFLXGAT(NA*NTYPE, IGND), 
     A  DRNROW(NA, NTYPE), XSLPROW(NA, NTYPE), GRKFROW(NA, NTYPE), 
     B  WFSFROW(NA, NTYPE), WFCIROW(NA, NTYPE), ALGWROW(NA, NTYPE), 
     C  ALGDROW(NA, NTYPE), ASVDROW(NA, NTYPE), ASIDROW(NA, NTYPE), 
     D  AGVDROW(NA, NTYPE), 
     E  AGIDROW(NA, NTYPE), ZSNLROW(NA, NTYPE), ZPLGROW(NA, NTYPE), 
     F  ZPLSROW(NA, NTYPE), SDEPROW(NA, NTYPE), FAREROW(NA, NTYPE), 
     G  DRNGAT(NA*NTYPE), XSLPGAT(NA*NTYPE), GRKFGAT(NA*NTYPE), 
     H  WFSFGAT(NA*NTYPE), WFCIGAT(NA*NTYPE), ALGWGAT(NA*NTYPE), 
     I  ALGDGAT(NA*NTYPE), ASVDGAT(NA*NTYPE), ASIDGAT(NA*NTYPE), 
     J  AGVDGAT(NA*NTYPE), 
     K  AGIDGAT(NA*NTYPE), ZSNLGAT(NA*NTYPE), ZPLGGAT(NA*NTYPE), 
     L  ZPLSGAT(NA*NTYPE), SDEPGAT(NA*NTYPE), FAREGAT(NA*NTYPE), 
     M  SANDROW(NA, NTYPE, IGND), CLAYROW(NA, NTYPE, IGND), 
     N  ORGMROW(NA, NTYPE, IGND), 
     O  MIDROW(NA, NTYPE), 
     P  ISNDROW(NA, NTYPE, IGND), IORG(NA, NTYPE, IGND), 
     Q  ISNDGAT(NA*NTYPE, IGND), 
     R  DELZ(IGND), ZBOT(IGND), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating canopy and soil info. ", 
     1      "variables.  Check that bounds are within an acceptable ", 
     2      "range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        WRITE (6, *) "Bound 3 (canopy types with urban areas): ", ICP1
        WRITE (6, *) "Bound 4 (canopy types): ", ICAN
        WRITE (6, *) "Bound 5 (soil layers): ", IGND
        STOP
      END IF

C     * WATROF FLAGS AND VARIABLES: 
      ALLOCATE (DDROW(NA, NTYPE), MANNROW(NA, NTYPE), 
     1  DDGAT(NA*NTYPE), MANNGAT(NA*NTYPE), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating WATROF variables.  Check ", 
     1      "that bounds are within an acceptable range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        STOP
      END IF

C     * ATMOSPHERIC AND GRID-CONSTANT INPUT VARIABLES: 
      ALLOCATE (ZRFMGRD(NA), ZRFHGRD(NA), ZDMGRD(NA), 
     1  ZDHGRD(NA), ZBLDGRD(NA), FSVHGRD(NA), FSIHGRD(NA), RADJGRD(NA), 
     2  CSZGRD(NA), FDLGRD(NA), 
     3  ULGRD(NA), VLGRD(NA), TAGRD(NA), QAGRD(NA), PRESGRD(NA), 
     4  PREGRD(NA), PADRGRD(NA), VPDGRD(NA), 
     5  TADPGRD(NA), RHOAGRD(NA), RPCPGRD(NA), TRPCGRD(NA), 
     6  SPCPGRD(NA), TSPCGRD(NA), RHSIGRD(NA), 
     7  FCLOGRD(NA), DLONGRD(NA), Z0ORGRD(NA), GGEOGRD(NA), UVGRD(NA), 
     8  XDIFFUS(NA), GCGRD(NA), 
     9  RPREGRD(NA), SPREGRD(NA), 
     A  ZRFMGAT(NA*NTYPE), ZRFHGAT(NA*NTYPE), ZDMGAT(NA*NTYPE), 
     B  ZDHGAT(NA*NTYPE), ZBLDGAT(NA*NTYPE), FSVHGAT(NA*NTYPE), 
     C  FSIHGAT(NA*NTYPE), RADJGAT(NA*NTYPE), CSZGAT(NA*NTYPE), 
     D  FDLGAT(NA*NTYPE), 
     E  ULGAT(NA*NTYPE), VLGAT(NA*NTYPE), TAGAT(NA*NTYPE), 
     F  QAGAT(NA*NTYPE), PRESGAT(NA*NTYPE), PREGAT(NA*NTYPE), 
     G  PADRGAT(NA*NTYPE), VPDGAT(NA*NTYPE), 
     H  TADPGAT(NA*NTYPE), RHOAGAT(NA*NTYPE), RPCPGAT(NA*NTYPE), 
     I  TRPCGAT(NA*NTYPE), SPCPGAT(NA*NTYPE), TSPCGAT(NA*NTYPE), 
     J  RHSIGAT(NA*NTYPE), 
     K  FCLOGAT(NA*NTYPE), DLONGAT(NA*NTYPE), Z0ORGAT(NA*NTYPE), 
     L  GGEOGAT(NA*NTYPE), 
     M  TBAR3(NA*NTYPE, 3), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating atmospheric and grid-cst. ", 
     1      "variables.  Check that bounds are within an acceptable ", 
     2      "range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        STOP
      END IF
      
C     * LAND SURFACE DIAGNOSTIC VARIABLES: 
      ALLOCATE (CDHROW(NA, NTYPE), CDMROW(NA, NTYPE), 
     1  HFSROW(NA, NTYPE), 
     2  TFXROW(NA, NTYPE), QEVPROW(NA, NTYPE), QFSROW(NA, NTYPE), 
     3  QFXROW(NA, NTYPE), PETROW(NA, NTYPE), GAROW(NA, NTYPE), 
     4  EFROW(NA, NTYPE), GTROW(NA, NTYPE), 
     5  QGROW(NA, NTYPE), TSFROW(NA, NTYPE), ALVSROW(NA, NTYPE), 
     6  ALIRROW(NA, NTYPE), FSNOROW(NA, NTYPE), SFCTROW(NA, NTYPE), 
     7  SFCUROW(NA, NTYPE), 
     8  SFCVROW(NA, NTYPE), SFCQROW(NA, NTYPE), FSGVROW(NA, NTYPE), 
     9  FSGSROW(NA, NTYPE), FSGGROW(NA, NTYPE), FLGVROW(NA, NTYPE), 
     A  FLGSROW(NA, NTYPE), 
     B  FLGGROW(NA, NTYPE), HFSCROW(NA, NTYPE), HFSSROW(NA, NTYPE), 
     C  HFSGROW(NA, NTYPE), HEVCROW(NA, NTYPE), HEVSROW(NA, NTYPE), 
     D  HEVGROW(NA, NTYPE), 
     E  HMFCROW(NA, NTYPE), HMFNROW(NA, NTYPE), HTCCROW(NA, NTYPE), 
     F  HTCSROW(NA, NTYPE), PCFCROW(NA, NTYPE), PCLCROW(NA, NTYPE), 
     G  PCPNROW(NA, NTYPE), 
     H  PCPGROW(NA, NTYPE), QFGROW(NA, NTYPE), QFNROW(NA, NTYPE), 
     I  QFCLROW(NA, NTYPE), QFCFROW(NA, NTYPE), ROFROW(NA, NTYPE), 
     J  ROFOROW(NA, NTYPE), 
     K  ROFSROW(NA, NTYPE), ROFBROW(NA, NTYPE), ROFCROW(NA, NTYPE), 
     L  ROFNROW(NA, NTYPE), ROVGROW(NA, NTYPE), WTRCROW(NA, NTYPE), 
     M  WTRSROW(NA, NTYPE), 
     N  WTRGROW(NA, NTYPE), DRROW(NA, NTYPE), WTABROW(NA, NTYPE), 
     O  ILMOROW(NA, NTYPE), UEROW(NA, NTYPE), HBLROW(NA, NTYPE), 
     P  TROFROW(NA, NTYPE), 
     Q  TROOROW(NA, NTYPE), TROSROW(NA, NTYPE), TROBROW(NA, NTYPE), 
     R  CDHGAT(NA*NTYPE), CDMGAT(NA*NTYPE), HFSGAT(NA*NTYPE), 
     S  TFXGAT(NA*NTYPE), QEVPGAT(NA*NTYPE), QFSGAT(NA*NTYPE), 
     T  QFXGAT(NA*NTYPE), PETGAT(NA*NTYPE), GAGAT(NA*NTYPE), 
     U  EFGAT(NA*NTYPE), GTGAT(NA*NTYPE), 
     V  QGGAT(NA*NTYPE), TSFGAT(NA*NTYPE), ALVSGAT(NA*NTYPE), 
     W  ALIRGAT(NA*NTYPE), FSNOGAT(NA*NTYPE), SFCTGAT(NA*NTYPE), 
     X  SFCUGAT(NA*NTYPE), 
     Y  SFCVGAT(NA*NTYPE), SFCQGAT(NA*NTYPE), FSGVGAT(NA*NTYPE), 
     Z  FSGSGAT(NA*NTYPE), FSGGGAT(NA*NTYPE), FLGVGAT(NA*NTYPE), 
     A  FLGSGAT(NA*NTYPE), 
     B  FLGGGAT(NA*NTYPE), HFSCGAT(NA*NTYPE), HFSSGAT(NA*NTYPE), 
     C  HFSGGAT(NA*NTYPE), HEVCGAT(NA*NTYPE), HEVSGAT(NA*NTYPE), 
     D  HEVGGAT(NA*NTYPE), 
     E  HMFCGAT(NA*NTYPE), HMFNGAT(NA*NTYPE), HTCCGAT(NA*NTYPE), 
     F  HTCSGAT(NA*NTYPE), PCFCGAT(NA*NTYPE), PCLCGAT(NA*NTYPE), 
     G  PCPNGAT(NA*NTYPE), 
     H  PCPGGAT(NA*NTYPE), QFGGAT(NA*NTYPE), QFNGAT(NA*NTYPE), 
     I  QFCLGAT(NA*NTYPE), QFCFGAT(NA*NTYPE), ROFGAT(NA*NTYPE), 
     J  ROFOGAT(NA*NTYPE), 
     K  ROFSGAT(NA*NTYPE), ROFBGAT(NA*NTYPE), ROFCGAT(NA*NTYPE), 
     L  ROFNGAT(NA*NTYPE), ROVGGAT(NA*NTYPE), WTRCGAT(NA*NTYPE), 
     M  WTRSGAT(NA*NTYPE), 
     N  WTRGGAT(NA*NTYPE), DRGAT(NA*NTYPE), WTABGAT(NA*NTYPE), 
     O  ILMOGAT(NA*NTYPE), UEGAT(NA*NTYPE), HBLGAT(NA*NTYPE), 
     P  TROFGAT(NA*NTYPE), 
     Q  TROOGAT(NA*NTYPE), TROSGAT(NA*NTYPE), TROBGAT(NA*NTYPE), 
     R  CDHGRD(NA), CDMGRD(NA), HFSGRD(NA), 
     S  TFXGRD(NA), QEVPGRD(NA), QFSGRD(NA), QFXGRD(NA), PETGRD(NA), 
     T  GAGRD(NA), EFGRD(NA), GTGRD(NA), 
     U  QGGRD(NA), TSFGRD(NA), ALVSGRD(NA), ALIRGRD(NA), FSNOGRD(NA), 
     V  SFCTGRD(NA), SFCUGRD(NA), 
     W  SFCVGRD(NA), SFCQGRD(NA), FSGVGRD(NA), FSGSGRD(NA), 
     X  FSGGGRD(NA), FLGVGRD(NA), FLGSGRD(NA), 
     Y  FLGGGRD(NA), HFSCGRD(NA), HFSSGRD(NA), HFSGGRD(NA), 
     Z  HEVCGRD(NA), HEVSGRD(NA), HEVGGRD(NA), 
     A  HMFCGRD(NA), HMFNGRD(NA), HTCCGRD(NA), HTCSGRD(NA), 
     B  PCFCGRD(NA), PCLCGRD(NA), PCPNGRD(NA), 
     C  PCPGGRD(NA), QFGGRD(NA), QFNGRD(NA), QFCLGRD(NA), QFCFGRD(NA), 
     D  ROFGRD(NA), ROFOGRD(NA), 
     E  ROFSGRD(NA), ROFBGRD(NA), ROFCGRD(NA), ROFNGRD(NA), 
     F  ROVGGRD(NA), WTRCGRD(NA), WTRSGRD(NA), 
     G  WTRGGRD(NA), DRGRD(NA), WTABGRD(NA), ILMOGRD(NA), UEGRD(NA), 
     H  HBLGRD(NA), 
     I  HMFGROW(NA, NTYPE, IGND), HTCROW(NA, NTYPE, IGND), 
     J  QFCROW(NA, NTYPE, IGND), 
     K  HMFGGAT(NA*NTYPE, IGND), HTCGAT(NA*NTYPE, IGND), 
     L  QFCGAT(NA*NTYPE, IGND), 
     M  HMFGGRD(NA, IGND), HTCGRD(NA, IGND), QFCGRD(NA, IGND), 
     N  ITCTROW(NA, NTYPE, 6, 50), 
     O  ITCTGAT(NA*NTYPE, 6, 50), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating land surface diagnostic ", 
     1      "variables.  Check that bounds are within an acceptable ", 
     2      "range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        WRITE (6, *) "Bound 3 (soil layers): ", IGND
        STOP
      END IF

C     * OUTPUT VARIABLES: 
      ALLOCATE (PREACC(NA), GTACC(NA), QEVPACC(NA), 
     1  HFSACC(NA), ROFACC(NA), SNOACC(NA), ALVSACC(NA), ALIRACC(NA), 
     2  FSINACC(NA), FLINACC(NA), 
     3  TAACC(NA), UVACC(NA), PRESACC(NA), QAACC(NA), EVAPACC(NA), 
     4  FLUTACC(NA), ROFOACC(NA), 
     5  ROFSACC(NA), ROFBACC(NA), HMFNACC(NA), WTBLACC(NA), 
     6  WSNOACC(NA), RHOSACC(NA), TSNOACC(NA), 
     7  TCANACC(NA), RCANACC(NA), SCANACC(NA), GROACC(NA), CANARE(NA), 
     8  SNOARE(NA), 
     9  TBARACC(NA, IGND), THLQACC(NA, IGND), THICACC(NA, IGND), 
     A  THALACC(NA, IGND), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating accumulator variables.  ", 
     1      "Check that bounds are within an acceptable range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (soil layers): ", IGND
        STOP
      END IF

C     * CROSS-CLASS VARIABLES (CLASS): 
      ALLOCATE (TBARC(NA*NTYPE, IGND), TBARG(NA*NTYPE, IGND), 
     1  TBARCS(NA*NTYPE, IGND), 
     2  TBARGS(NA*NTYPE, IGND), THLIQC(NA*NTYPE, IGND), 
     3  THLIQG(NA*NTYPE, IGND), THICEC(NA*NTYPE, IGND), 
     4  THICEG(NA*NTYPE, IGND), FROOT(NA*NTYPE, IGND), 
     5  HCPC(NA*NTYPE, IGND), HCPG(NA*NTYPE, IGND), 
     6  TCTOP(NA*NTYPE, IGND), TCBOT(NA*NTYPE, IGND), 
     7  FC(NA*NTYPE), FG(NA*NTYPE), FCS(NA*NTYPE), 
     8  FGS(NA*NTYPE), RBCOEF(NA*NTYPE), 
     9  ZSNOW(NA*NTYPE), AILCAN(NA*NTYPE), AILCNS(NA*NTYPE), 
     A  FSVF(NA*NTYPE), FSVFS(NA*NTYPE), ALVSCN(NA*NTYPE), 
     B  ALIRCN(NA*NTYPE), ALVSG(NA*NTYPE), 
     C  ALIRG(NA*NTYPE), ALVSCS(NA*NTYPE), ALIRCS(NA*NTYPE), 
     D  ALVSSN(NA*NTYPE), ALIRSN(NA*NTYPE), ALVSGC(NA*NTYPE), 
     E  ALIRGC(NA*NTYPE), ALVSSC(NA*NTYPE), 
     F  ALIRSC(NA*NTYPE), TRVSCN(NA*NTYPE), TRIRCN(NA*NTYPE), 
     G  TRVSCS(NA*NTYPE), TRIRCS(NA*NTYPE), RC(NA*NTYPE), 
     H  RCS(NA*NTYPE), FRAINC(NA*NTYPE), 
     I  FSNOWC(NA*NTYPE), CMASSC(NA*NTYPE), CMASCS(NA*NTYPE), 
     J  DISP(NA*NTYPE), DISPS(NA*NTYPE), ZOMLNC(NA*NTYPE), 
     K  ZOELNC(NA*NTYPE), ZOMLNG(NA*NTYPE), 
     L  ZOELNG(NA*NTYPE), ZOMLCS(NA*NTYPE), ZOELCS(NA*NTYPE), 
     M  ZOMLNS(NA*NTYPE), ZOELNS(NA*NTYPE), TRSNOW(NA*NTYPE), 
     N  CHCAP(NA*NTYPE), CHCAPS(NA*NTYPE), 
     O  GZEROC(NA*NTYPE), GZEROG(NA*NTYPE), GZROCS(NA*NTYPE), 
     P  GZROGS(NA*NTYPE), G12C(NA*NTYPE), G12G(NA*NTYPE), 
     Q  G12CS(NA*NTYPE), G12GS(NA*NTYPE), G23C(NA*NTYPE), 
     R  G23G(NA*NTYPE), G23CS(NA*NTYPE), G23GS(NA*NTYPE), 
     S  QFREZC(NA*NTYPE), QFREZG(NA*NTYPE), QMELTC(NA*NTYPE), 
     T  QMELTG(NA*NTYPE), EVAPC(NA*NTYPE), 
     U  EVAPCG(NA*NTYPE), EVAPG(NA*NTYPE), EVAPCS(NA*NTYPE), 
     V  EVPCSG(NA*NTYPE), EVAPGS(NA*NTYPE), TCANO(NA*NTYPE), 
     W  TCANS(NA*NTYPE), RAICAN(NA*NTYPE), 
     X  SNOCAN(NA*NTYPE), RAICNS(NA*NTYPE), SNOCNS(NA*NTYPE), 
     Y  CWLCAP(NA*NTYPE), CWFCAP(NA*NTYPE), CWLCPS(NA*NTYPE), 
     Z  CWFCPS(NA*NTYPE), TSNOCS(NA*NTYPE), 
     A  TSNOGS(NA*NTYPE), RHOSCS(NA*NTYPE), RHOSGS(NA*NTYPE), 
     B  WSNOCS(NA*NTYPE), WSNOGS(NA*NTYPE), TPONDC(NA*NTYPE), 
     C  TPONDG(NA*NTYPE), TPNDCS(NA*NTYPE), 
     D  TPNDGS(NA*NTYPE), ZPLMCS(NA*NTYPE), ZPLMGS(NA*NTYPE), 
     E  ZPLIMC(NA*NTYPE), ZPLIMG(NA*NTYPE), 
     F  ZTHRC(NA*NTYPE, 3, 2), ZTHRG(NA*NTYPE, 3, 2), 
     G  ZTHRCS(NA*NTYPE, 3, 2), 
     H  ZTHRGS(NA*NTYPE, 3, 2), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating cross-CLASS variables.  ", 
     1      "Check that bounds are within an acceptable range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        WRITE (6, *) "Bound 3 (soil layers): ", IGND
        STOP
      END IF

C     * BALANCE ERRORS (CLASS): 
      ALLOCATE (CTVSTP(NA*NTYPE), CTSSTP(NA*NTYPE), 
     1  CT1STP(NA*NTYPE), 
     2  CT2STP(NA*NTYPE), CT3STP(NA*NTYPE), WTVSTP(NA*NTYPE), 
     3  WTSSTP(NA*NTYPE), WTGSTP(NA*NTYPE), STAT=PAS)
      IF (PAS .NE. 0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "Error allocating balance error variables.  ", 
     1      "Check that bounds are within an acceptable range."
        WRITE (6, *) "Bound 1 (grid squares): ", NA
        WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
        STOP
      END IF
      
8200  FORMAT (' READING: 'A)
8300  FORMAT (' 'A, T30' (mm) = ', 3F11.3)
8400  FORMAT (/' 'A)



c *********************************************************************
c Open and read in values from MESH_input_soil_levels.txt file
c *********************************************************************

      OPEN (52, FILE="MESH_input_soil_levels.txt", STATUS="OLD", 
     1  IOSTAT=IOS)
      IF (IOS .NE. 0)THEN !CHECK FILE FOR IOSTAT ERRORS
        WRITE (6, 8400)
        WRITE (6, *) "MESH_input_soil_levels.txt could not be ", 
     1      "opened.  Ensure that the file exists and restart the ", 
     2      "program."
        STOP
      ELSE
        WRITE (6, 8200, ADVANCE="NO") "MESH_input_soil_levels.txt"
      END IF

      DO I=1,IGND
        READ(52,'(2X,F8.2)') DELZ(I)
      ENDDO

      ZBOT(1) = DELZ(1)
      DO I=2,IGND
         ZBOT(I) = ZBOT(I-1) + DELZ(I)
      ENDDO

	CLOSE(UNIT=52)
      WRITE (6, *) " READ: SUCCESSFUL, FILE: CLOSED"


c *********************************************************************
c Open basin_shortwave.csv
c *********************************************************************
      OPEN(unit=90,file='basin_shortwave.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN  
        !IOS returns 0 on successful file open
        !no basin shortwave file exists, use 'default' c05 behaviour
        BASINSHORTWAVEFLAG = 0
        PRINT *, 'basin_shortwave.csv not found'
      ELSE
        !basin shortwave files does exist, use Pablo's code related
        !to shortwave
        BASINSHORTWAVEFLAG = 1
        PRINT *, 'basin_shortwave.csv found'
      ENDIF

c *********************************************************************
c Open basin_longwave.csv
c *********************************************************************
      OPEN(unit=91,file='basin_longwave.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN 
        !IOS returns 0 on successful file open
        !no basin longwave file exists, use 'default' c05 behaviour
        BASINLONGWAVEFLAG = 0
        PRINT *, 'basin_longwave.csv not found'
      ELSE
        !basin longwave files does exist, use Pablo's code related
        !to longwave
        BASINLONGWAVEFLAG = 1
        PRINT *, 'basin_longwave.csv found'
      ENDIF

c *********************************************************************
c Open basin_rain.csv
c *********************************************************************
      OPEN(unit=92,file='basin_rain.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN
        !IOS returns 0 on successful file open
        !no basin rain file exists, use 'default' c05 behaviour
        BASINRAINFLAG = 0
        PRINT *, 'basin_rain.csv not found'
      ELSE
        !basin rain files does exist, use Pablo's code related
        !to rain
        BASINRAINFLAG = 1
        PRINT *, 'basin_rain.csv found'
      ENDIF

c *********************************************************************
c Open basin_temperature.csv
c *********************************************************************
      OPEN(unit=93,file='basin_temperature.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN
        !IOS returns 0 on successful file open
        !no basin temperature file exists, use 'default' c05 behaviour
        BASINTEMPERATUREFLAG = 0
        PRINT *, 'basin_temperature.csv not found'
      ELSE
        !basin temperature files does exist, use Pablo's code related
        !to temperature
        BASINTEMPERATUREFLAG = 1
        PRINT *, 'basin_temperature.csv found'
      ENDIF

c *********************************************************************
c Open basin_wind.csv
c *********************************************************************
      OPEN(unit=94,file='basin_wind.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN
        !IOS returns 0 on successful file open
        !no basin wind file exists, use 'default' c05 behaviour
        BASINWINDFLAG = 0
        PRINT *, 'basin_wind.csv not found'
      ELSE
        !basin wind files does exist, use Pablo's code related
        !to wind
        BASINWINDFLAG = 1
        PRINT *, 'basin_wind.csv found'
      ENDIF

c *********************************************************************
c Open basin_pres.csv
c *********************************************************************
      OPEN(unit=95,file='basin_pres.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN
        !IOS returns 0 on successful file open
        !no basin pres file exists, use 'default' c05 behaviour
        BASINPRESFLAG = 0
        PRINT *, 'basin_pres.csv not found'
      ELSE
        !basin pres files does exist, use Pablo's code related
        !to pres
        BASINPRESFLAG = 1
        PRINT *, 'basin_pres.csv found'
      ENDIF

c *********************************************************************
c Open basin_humidity.csv
c *********************************************************************
      OPEN(unit=96,file='basin_humidity.csv',
     +  STATUS='OLD',IOSTAT=IOS)

      IF(IOS/=0)THEN
        !IOS returns 0 on successful file open
        !no basin humidity file exists, use 'default' c05 behaviour
        BASINHUMIDITYFLAG = 0
        PRINT *, 'basin_humidity.csv not found'
      ELSE
        !basin humidity files does exist, use Pablo's code related
        !to humidity
        BASINHUMIDITYFLAG = 1
        PRINT *, 'basin_humidity.csv found'
      ENDIF


c *********************************************************************
c Open additional output files
c *********************************************************************
      OPEN(unit=85,file=".\" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) //
     +                  '\basin_SCA_alldays.csv')
      OPEN(unit=86,file=".\" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) //
     +                  '\basin_SWE_alldays.csv')

c *********************************************************************
c Open and read in values from MESH_parameters_CLASS.ini file
c *********************************************************************

      OPEN (50, FILE="MESH_parameters_CLASS.ini", STATUS="OLD", 
     1  IOSTAT=IOS)
      IF (IOS .NE. 0)THEN !CHECK FILE FOR IOSTAT ERRORS
        WRITE (6, 8400)
        WRITE (6, *) "MESH_parameters_CLASS.ini could not be ", 
     1      "opened.  Ensure that the file exists and restart the ", 
     2      "program."
        STOP
      ELSE
        WRITE (6, 8200, ADVANCE="NO") "MESH_parameters_CLASS.ini"
      ENDIF

      READ (50,'(2X,6A4)') TITLE1,TITLE2,TITLE3,TITLE4,TITLE5,TITLE6
      READ (50,'(2X,6A4)') NAME1,NAME2,NAME3,NAME4,NAME5,NAME6
      READ (50,'(2X,6A4)') PLACE1,PLACE2,PLACE3,PLACE4,PLACE5,PLACE6
      READ(50,'(5F10.2,F7.1,3I5)') DEGLAT,DEGLON,ZRFMGRD(1),ZRFHGRD(1),
     +  ZBLDGRD(1),GCGRD(1),ILW,NLTEST,NMTEST
     
      IF(NTYPE.NE.NMTEST .AND. NTYPE.GT.0) THEN
        WRITE (6, 8400)
        WRITE (6, *) "GRUs from MESH_parameters_CLASS.ini: ", NMTEST
        WRITE (6, *) "GRUs from basin watershed file: ", NTYPE
        WRITE (6, *) "These values must be equal."
        CLOSE (50)
	  STOP
	END IF
     

c set NLTEST to wf_na no matter what value was read in from the CLASS.INI file
      NLTEST=NA

      JLAT=NINT(DEGLAT)

      I=1
      DO M=1,NMTEST
        READ(50,'(9F8.3)') (FCANROW(1,M,J),J=1,ICAN+1),(LAMXROW(1,M,J),
     1                  J=1,ICAN)
        READ(50,'(9F8.3)') (LNZ0ROW(1,M,J),J=1,ICAN+1),(LAMNROW(1,M,J),
     1                  J=1,ICAN)
        READ(50,'(9F8.3)') (ALVCROW(1,M,J),J=1,ICAN+1),(CMASROW(1,M,J),
     1                  J=1,ICAN)
        READ(50,'(9F8.3)') (ALICROW(1,M,J),J=1,ICAN+1),(ROOTROW(1,M,J),
     1                  J=1,ICAN)
        READ(50,'(4F8.3,8X,4F8.3)') (RSMNROW(1,M,J),J=1,ICAN),
     1                  (QA50ROW(1,M,J),J=1,ICAN)
        READ(50,'(4F8.3,8X,4F8.3)') (VPDAROW(1,M,J),J=1,ICAN),
     1                  (VPDBROW(1,M,J),J=1,ICAN)
        READ(50,'(4F8.3,8X,4F8.3)') (PSGAROW(1,M,J),J=1,ICAN),
     1                  (PSGBROW(1,M,J),J=1,ICAN)
        READ(50,'(3F8.3,F8.2)') DRNROW(1,M),SDEPROW(1,M),FAREROW(1,M),
     1                  DDROW(1,M)
        READ(50,'(4E8.1,I8)') XSLPROW(1,M),GRKFROW(1,M),MANNROW(1,M),
     1                  WFCIROW(1,M),MIDROW(1,M)
        READ(50,'(3F10.1)') (SANDROW(1,M,J),J=1,IGND) !soil layers
        READ(50,'(3F10.1)') (CLAYROW(1,M,J),J=1,IGND)
        READ(50,'(3F10.1)') (ORGMROW(1,M,J),J=1,IGND)
        READ(50,'(6F10.2)') (TBARROW(1,M,J),J=1,IGND),TCANROW(1,M),
     1                  TSNOROW(1,M),TPNDROW(1,M)
        READ(50,'(7F10.3)') (THLQROW(1,M,J),J=1,IGND),(THICROW(1,M,J),
     1                  J=1,IGND),ZPNDROW(1,M)
        READ(50,'(2F10.4,F10.2,F10.3,F10.4,F10.3)')
     +                  RCANROW(1,M),SCANROW(1,M),SNOROW(1,M),
     1                  ALBSROW(1,M),RHOSROW(1,M),GROROW(1,M)
      ENDDO

!PARAMESH
      READ(50,*) HOURLY_START_DAY, HOURLY_STOP_DAY, DAILY_START_DAY,
     1           DAILY_STOP_DAY !P, IDAY_START, IDAY_END
      READ(50,*) HOURLY_START_YEAR, HOURLY_STOP_YEAR, DAILY_START_YEAR,
     1           DAILY_STOP_YEAR !P, IYEAR_START, IYEAR_END
C READ IN HOUR, MINUTE, DAY AND YEAR FROM CLASS.INI FILE AS IT IS
C NOT PRESENT IN THE MET FILES
      READ(50,'(4I10)') IHOUR,IMIN,IDAY,IYEAR

C CLOSE UNIT 50 AS WE DON'T NEED ANYTHING ELSE FROM THE CLASS.INI FILE
      CLOSE(UNIT=50)
      WRITE (6, *) " READ: SUCCESSFUL, FILE: CLOSED"
      
c CLASS requires that each GRU for each grid square has its own parameter value,
c for MESH the value read in from the parameter file is assumed to be valid for
c all grid squares in the study area - Frank Seglenieks Aug 2007

c bjd - This would be a good spot for setting pre-distributed values

      DO I=2,NLTEST
        DO M=1,NMTEST
          DO J=1, ICP1
            FCANROW(I,M,J)=   FCANROW(1,M,J)
            LNZ0ROW(I,M,J)=   LNZ0ROW(1,M,J)
            ALVCROW(I,M,J)=   ALVCROW(1,M,J)
            ALICROW(I,M,J)=   ALICROW(1,M,J)
          ENDDO

          DO J=1, ICAN
            LAMXROW(I,M,J)=   LAMXROW(1,M,J)
            LAMNROW(I,M,J)=   LAMNROW(1,M,J)
            CMASROW(I,M,J)=   CMASROW(1,M,J)
            ROOTROW(I,M,J)=   ROOTROW(1,M,J)
            RSMNROW(I,M,J)=   RSMNROW(1,M,J)
            QA50ROW(I,M,J)=   QA50ROW(1,M,J)
            VPDAROW(I,M,J)=   VPDAROW(1,M,J)
            VPDBROW(I,M,J)=   VPDBROW(1,M,J)
            PSGAROW(I,M,J)=   PSGAROW(1,M,J)
            PSGBROW(I,M,J)=   PSGBROW(1,M,J)
          ENDDO

          DO J=1,IGND
            SANDROW(I,M,J)=   SANDROW(1,M,J)
            CLAYROW(I,M,J)=   CLAYROW(1,M,J)
            ORGMROW(I,M,J)=   ORGMROW(1,M,J)
            TBARROW(I,M,J)=   TBARROW(1,M,J)
            THLQROW(I,M,J)=   THLQROW(1,M,J)
            THICROW(I,M,J)=   THICROW(1,M,J)
          ENDDO

          TCANROW(I,M)=     TCANROW(1,M)
          TSNOROW(I,M)=     TSNOROW(1,M)
          DRNROW(I,M)=      DRNROW(1,M)
          SDEPROW(I,M)=     SDEPROW(1,M)
          FAREROW(I,M)=     FAREROW(1,M)
          MANNROW(I,M)=     MANNROW(1,M)
          XSLPROW(I,M)=     XSLPROW(1,M)
          GRKFROW(I,M)=     GRKFROW(1,M)
          DDROW(I,M)=       DDROW(1,M)
          WFSFROW(I,M)=     WFSFROW(1,M)
          WFCIROW(I,M)=     WFCIROW(1,M)
          MIDROW(I,M)=      MIDROW(1,M)
          TPNDROW(I,M)=     TPNDROW(1,M)
          ZPNDROW(I,M)=     ZPNDROW(1,M)
          RCANROW(I,M)=     RCANROW(1,M)
          SCANROW(I,M)=     SCANROW(1,M)
          SNOROW(I,M)=      SNOROW(1,M)
          ALBSROW(I,M)=     ALBSROW(1,M)
          RHOSROW(I,M)=     RHOSROW(1,M)
          GROROW(I,M)=      GROROW(1,M)
        ENDDO  !DO M=1,NMTEST
      ENDDO  !DO I=2,NLTEST


c *********************************************************************
c Open and read in values from soil.ini file
c
c Bruce Davison, August 13, 2004
c Changes to the soil parameters so that they're read-in directly.
c
c Read in the soil parameters that used to be calculated from %sand, %clay
c *********************************************************************

      OPEN(UNIT=23,file='soil.ini',status='old',iostat=SOIL_IOS)
C     * CHECK TO SEE IF THERE IS A new_soil.ini FILE

      IF(soil_ios/=0)THEN !IOS returns 0 on successful file open
        PRINT*,'The soil.ini file was NOT found'
        PRINT*,'%sand, %clay, %organic from class.ini will be used'
        PRINT*,'(i.e. CLASSB.f will be used)'
        PRINT*,'-----------------------------------'
      ELSE
        PRINT*,'The soil.ini file WAS found'
        PRINT*,'CLASSBHYD.f will be used'
        PRINT*,'-----------------------------------'
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thpor (1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thpor (1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thpor (1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thlret(1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thlret(1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thlret(1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thlmin(1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thlmin(1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_thlmin(1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_bi    (1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_bi    (1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_bi    (1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_psisat(1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_psisat(1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_psisat(1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10E12.5)") (wc_grksat(1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10E12.5)") (wc_grksat(1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10E12.5)") (wc_grksat(1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10E12.5)") (wc_hcps  (1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10E12.5)") (wc_hcps  (1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10E12.5)") (wc_hcps  (1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_tcs   (1,m,1),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_tcs   (1,m,2),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_tcs   (1,m,3),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_algwet(1,m),m=1,NMTEST)
        READ (23,*)
        READ (23,"(10F8.5)") (wc_algdry(1,m),m=1,NMTEST)
      ENDIF

      CLOSE(unit=23)



c     ==============================
c *********************************************************************
c Open and read INITIAL SOIL MOSITURE AND SOIL TEMPERATURE values
c when data is available
C files: S_moisture.txt : soil moisture in layer 1, 2 and 3
C files: T_temperature.txt : soil temperature in layer 1, 2 and 3
c *********************************************************************
C SOIL MOSITURE
      ALLOCATE (valuem(YCOUNT,XCOUNT,ignd))
      OPEN(UNIT=59,FILE='s_moisture.txt',STATUS='old',IOSTAT=s_ios)
      !IOSTAT returns 0 on successful file open
      IF(s_ios==0)THEN
        DO J=1,IGND
          READ(59,*)
          DO i=1,YCOUNT
             READ(59,*)(valuem(i,k,j),k=1,XCOUNT)
          ENDDO
        ENDDO
        DO I=1,NLTEST     !number of cells
          DO M=1,NMTEST   !number of classes
            DO J=1,IGND   !soil layers
              THLQROW(I,M,J)= valuem(YYY(I),XXX(I),J)
            ENDDO
          ENDDO
        ENDDO
      ELSE
         PRINT*,'...S_MOSITURE.TXT file do not exist...'
         PRINT*,'...Running without gridded initial soil moisture...'
      ENDIF
         CLOSE(59)
C
C SOIL TEMPERATURE
      ALLOCATE (valuet(YCOUNT,XCOUNT,ignd))
      OPEN(UNIT=59,FILE='s_temperature.txt',STATUS='old',IOSTAT=s_ios)
      !IOS returns 0 on successful file open
      IF(s_ios==0)THEN
        DO J=1,IGND
          READ(59,*)
          DO i=1,YCOUNT
             READ(59,*)(valuet(i,k,j),k=1,XCOUNT)
          ENDDO
        ENDDO
        DO I=1,NLTEST     !number of cells
          DO M=1,NMTEST   !number of classes
            DO J=1,IGND   !soil layers
              TBARROW(I,M,J)=   valuet(YYY(I),XXX(I),J)
            ENDDO
          ENDDO
        ENDDO
      ELSE
         PRINT*,'...S_TEMPERATURE.TXT file do not exist...'
         PRINT*,'...Running without gridded initial soil temperature...'
      ENDIF
         CLOSE(59)
C     ==================================
C
c *********************************************************************
c Open and read in values from MESH_parameters_hydrology.ini file
c *********************************************************************

      OPEN (23, FILE="MESH_parameters_hydrology.ini", STATUS="OLD", 
     1  IOSTAT=IOS)
      IF (IOS .NE. 0)THEN !CHECK FILE FOR IOSTAT ERRORS
        WRITE (6, 8400)
        WRITE (6, *) "MESH_parameters_hydrology.ini could not be ", 
     1      "opened.  Ensure that the file exists and restart the ", 
     2      "program."
        STOP
      ELSE
        WRITE (6, 8200, ADVANCE="NO") "MESH_parameters_hydrology.ini"
      END IF

CDAN  CHECK FILE VERSION (IF RELFLG = 1.0) AS THE NEW FILE FORMATS 
CDAN  ALLOW VARIABLES AND VARIABLE PLACEMENT FILE VERSIONS TO CHANGE      
      IF (RELFLG .EQ. 1.0) THEN
        READ (23, "(A8)") FILE_VER !READ FILE VERSION
        IF (INDEX (FILE_VER, ":") .GT. 0) THEN !FOLLOWED BY COLON
            FILE_VER = TRIM (ADJUSTL (FILE_VER(1:INDEX (FILE_VER, 
     1          ":") - 1)))
        ELSEIF (INDEX (FILE_VER, " ") .GT. 0) THEN !FOLLOWED BY SPACE
            FILE_VER = TRIM (ADJUSTL (FILE_VER(1:INDEX (FILE_VER, 
     1          " ") - 1)))
        ELSE !ANYTHING ELSE
            FILE_VER = TRIM (ADJUSTL (FILE_VER))
        END IF
        IF (FILE_VER .NE. RELEASE) THEN !WRONG FILE VERSION
            WRITE (6, 8400)
            IF (LEN (TRIM (ADJUSTL (FILE_VER))) .GT. 0) THEN
                WRITE (6, *) "File version: ", FILE_VER
            ELSE
                WRITE (6, *) "This file is out of date."
            END IF
            WRITE (6, *) "MESH requires file version: ", RELEASE
            WRITE (6, *) "Please update MESH_parameters_hydrology.ini."
            WRITE (6, *) "The file must contain the version number"
            WRITE (6, *) "on the first line, followed by a colon."
            WRITE (6, *) "EXAMPLE:"
            WRITE (6, *) RELEASE,": MESH_parameters_hydrology.ini"
            WRITE (6, *) " "
            WRITE (6, *) "Please insure that all other parameters"
            WRITE (6, *) "are also updated."
            
            CLOSE (23)
            STOP
        END IF
      ELSE
        READ (23, *)
      END IF
      DO I=2,3
        READ(23,*)
      ENDDO

      READ(23,"(I5)") OPTFLAGS

      IF(OPTFLAGS>0) THEN
        DO I=1,OPTFLAGS
          READ(23,*)
        ENDDO
      ENDIF

      DO I=1,2
        READ(23,*)
      ENDDO

      READ (23,"(5F6.3)") (WF_R2(i),I=1,5)

      DO I=1,2
        READ(23,*)
      ENDDO

      READ(23,"(I8)") INDEPPAR
      IF(INDEPPAR>0) THEN
        DO I=1,INDEPPAR
          READ(23,"(F8.3)")
        ENDDO
      ENDIF

      DO I=1,2
        READ(23,*)
      ENDDO

      READ(23,"(I8)") I
	  IF(I/=NTYPE) THEN
          PRINT *, 'Number of GRUs in hydrology file: ',I
          PRINT *, 'Number of GRUs in drainage database: ',NTYPE
          PRINT *, 'Please adjust these values.'
          STOP
	  ENDIF

      READ(23,"(I8)") DEPPAR
      READ(23,*)
      IF(DEPPAR>0) THEN
        READ(23,*) (ZSNLROW(1,M),M=1,NMTEST)
        READ(23,*) (ZPLSROW(1,M),M=1,NMTEST)
        READ(23,*) (ZPLGROW(1,M),M=1,NMTEST)
      ENDIF

      DO I=2,NLTEST
        DO M=1,NMTEST
          ZSNLROW(I,M)=ZSNLROW(1,M)
          ZPLSROW(I,M)=ZPLSROW(1,M)
          ZPLGROW(I,M)=ZPLGROW(1,M)
        ENDDO
      ENDDO

      CLOSE(UNIT=23)

c *********************************************************************
c Open and read in values from MESH_input_reservoir.txt file
c *********************************************************************

!Diane      OPEN(UNIT=21,FILE='MESH_input_reservoir.txt',STATUS='OLD')
!Diane	READ(21,'(3I5)') WF_NORESV,WF_NREL,WF_KTR
!Diane      WF_NORESV_CTRL=0

!Diane      IF( WF_NORESV>0 ) THEN
!Diane        DO I=1,WF_NORESV
!Diane          READ(21,'(2I5,2G10.3,25X,A12,I2)') WF_IRES(I),WF_JRES(I),
!Diane     +      WF_B1(I),WF_B2(I),WF_RESNAME(I), WF_RES(I)
!Diane          WF_IRES(I)=INT((REAL(WF_IRES(I))-REAL(IYMIN))/GRDN+1.0)
!Diane          WF_JRES(I)=INT((REAL(WF_JRES(I))-REAL(JXMIN))/GRDE+1.0)
c check if point is in watershed and in river reaches
!Diane          WF_R(I)=0
!Diane          DO J=1,NLTEST
!Diane            IF( WF_IRES(I)==YYY(J).AND.WF_JRES(I)==XXX(J))THEN
!Diane              WF_R(I)=J
!Diane            ENDIF
!Diane          ENDDO
!Diane          IF(WF_R(I)==0) THEN
!Diane            PRINT *, 'Reservoir Station: ',I,' is not in the basin'
!Diane	      PRINT *, 'Up/Down Coordinate: ', wf_ires(I)
!Diane	      PRINT *, 'Left/Right Coordinate: ', wf_jres(I)
!Diane            STOP
!Diane          ENDIF
!Diane          IF(WF_IREACH(WF_R(I))/=I) THEN
!Diane            PRINT *, 'Reservoir Station: ',I,
!Diane     +        ' is not in the correct reach'
!Diane	      PRINT *, 'Up/Down Coordinate: ', wf_ires(I)
!Diane	      PRINT *, 'Left/Right Coordinate: ', wf_jres(I)
!Diane	      PRINT *, 'ireach value at station: ', wf_iy(I)
!Diane            STOP
!Diane	    ENDIF
!Diane          IF( WF_B1(I)==0.0 ) THEN
!Diane            WF_NORESV_CTRL=WF_NORESV_CTRL+1
!Diane          ENDIF
!Diane        ENDDO
!Diane      ENDIF
c leave file open and read in the reservoir files when needed



!c *********************************************************************
!c Open and read in values from MESH_input_streamflow.txt file
!c *********************************************************************

!      OPEN(UNIT=22,FILE='MESH_input_streamflow.txt',STATUS='OLD')
!      READ(22,*)
!      READ(22,'(4I5)') WF_NO,WF_NL,WF_MHRD,WF_KT
!      DO I=1,WF_NO
!        READ(22,'(2I5,1X,A12)')WF_IY(I),WF_JX(I),WF_GAGE(I)
!        WF_IY(I)=INT((REAL(WF_IY(I))-REAL(IYMIN))/GRDN+1.0)
!        WF_JX(I)=INT((REAL(WF_JX(I))-REAL(JXMIN))/GRDE+1.0)

!      ENDDO

!      DO I=1,WF_NO
!        WF_S(I)=0
!        DO J=1,NLTEST
!          IF( WF_IY(I)==YYY(J).AND.WF_JX(I)==XXX(J) ) THEN
!            WF_S(I)=J
!          ENDIF
!        ENDDO
!        IF(WF_S(I)==0) THEN
!          PRINT *, 'STREAMFLOW GAUGE: ',I,' IS NOT IN THE BASIN'
!	    PRINT *, 'UP/DOWN COORDINATE: ', WF_IY(I)
!	    PRINT *, 'LEFT/RIGHT COORDINATE: ', WF_JX(I)
!          STOP
!	  ENDIF
	
	  !note: this assumes streamflow data will be daily,
	  !if WF_KT is something other than 24 there will be a
	  !problem
	  !TODO: find out if WF_KT can/will be a value other than 24
!	  nrs =( (IYEAR_START - IYEAR)*365 + (IDAY_START-IDAY) )
!	  PRINT*, NRS
!	  IF (NRS > 0) THEN
!	    DO J=1, NRS
!	      READ(22,*,IOSTAT=IOS)
!	      IF (IOS < 0) THEN
!	        PRINT *, 'ERROR: end of file reached when reading ',
!     +          ' MESH_input_streamflow.txt, The start date in ',
!     +          ' MESH_input_run_options.ini may be out of range'
!              STOP
!	      ENDIF
!	    ENDDO
!	  ENDIF

!cric     initialise smoothed variables
!        wf_qsyn(I)=0.0
!	  wf_qhyd_avg(I)=0.0
!      ENDDO

c leave unit open and read new streamflow each hour

c *********************************************************************
c Check to make sure input values are consistent
c *********************************************************************

c compare land classes in class.ini and drainage database files
      IF(NTYPE/=NMTEST.AND.NTYPE>0) THEN
        PRINT *, 'land classes from MESH_parameters_CLASS.ini: ',NMTEST
        PRINT *, 'land classes from MESH_drainage_database.txt:',
     +            NTYPE
        PRINT *, 'Please adjust these values.'
	  STOP
	ENDIF

c check if we are going to get an "array bounds out of range" error
!      IF(NA>NLAT) THEN
!        PRINT *, 'NLAT value in declaration statement : ',NLAT
!        PRINT *, 'No. of grids from MESH_drainage_database.txt: ',NA
!        PRINT *, 'Please adjust these values.'
!	  STOP
!	ENDIF

!      IF(NTYPE>NMOS) THEN
!        PRINT *, 'NMOS value in declaration statement : ',NMOS
!        PRINT *, 'No. of grids from MESH_drainage_database.txt: ',
!     +            NTYPE
!        PRINT *, 'Please adjust these values.'
!	  STOP
!	ENDIF

c check that run points are in the basin and that there are no repeats

      DO I=1, WF_NUM_POINTS
        IF(N_OUT(I)>NLTEST) THEN
         PRINT *, 'No. of grids from MESH_drainage_database.txt:',NLTEST
         PRINT *, 'out point ',i,' is: ',N_OUT(I)
         PRINT *, 'please adjust MESH_run_options.ini file'
	   STOP
	  ENDIF

        IF(I<WF_NUM_POINTS) THEN
	    DO J=I+1,WF_NUM_POINTS
            IF(N_OUT(I)==N_OUT(J)) THEN
	        PRINT *, 'grid number ', n_out(i)
	        PRINT *, 'is repeated in MESH_run_options.ini file'
              PRINT *, 'please adjust MESH_run_options.ini file'
	        STOP
	      ENDIF
          ENDDO
	  ENDIF

	ENDDO



c *********************************************************************
c Set some more intial values and clear accumulators
c *********************************************************************

c assign values of lat/long to each square
! there are a bunch of magic numbers here, this should get cleaned up
! or documented
      DO I=1, NLTEST
        LATLENGTH=AL/1000./(111.136-0.5623*COS(2*(DEGLAT*PI/180.0))+
     +  0.0011*COS(4*(DEGLAT*PI/180.0)))
        LONGLENGTH=AL/1000./(111.4172*COS((DEGLAT*PI/180.0))-
     +  0.094*COS(3*(DEGLAT*PI/180.0))+0.0002*COS(5*(DEGLAT*PI/180.0)))
        RADJGRD(I)=( (DEGLAT-(REAL(YCOUNT)/2.0)*LATLENGTH)
     +  +(YYY(I)-0.5)*LATLENGTH)*PI/180.
        DLONGRD(I)=(DEGLON-(REAL(XCOUNT)/2.0)*LONGLENGTH)
     +  +(XXX(I)-0.5)*LONGLENGTH
        ZRFMGRD(I)=ZRFMGRD(1)
        ZRFHGRD(I)=ZRFHGRD(1)
        ZBLDGRD(I)=ZBLDGRD(1)
        GCGRD(i)=GCGRD(1)
        Z0ORGRD(I)=0.0
        GGEOGRD(I)=0.0
        ZDMGRD(I)=10.0
        ZDHGRD(I)=2.0
      ENDDO

c adjust NAA to the be number of outlet squares
      NAA=NLTEST-NAA

c set initial values of ncount and nsum
! NCOUNT = which half-hour period the current time is:
! The first period (0:00-0:30) is #1, the last period (23:30-0:00) is #48
      NCOUNT=IHOUR*2+IMIN/30+1
      NSUM=1

c Set value of FAREROW

      TOTAL_AREA=0.0
      DO I=1,NLTEST
        DO M=1,NMTEST
!          FAREROW(I,M)= WF_ACLASS(I,M) * WF_FRAC(I)
          FAREROW(I, M) = ACLASS(I, M)*FRAC(I)
          TOTAL_AREA=TOTAL_AREA+FAREROW(I,M)
          !FUTUREDO: Bruce, WF_FRAC is calculated by EnSim
          ! using Dan Princz's instructions for EnSim
          ! WF_FRAC can be greater than 1.00
          ! So, we cannot use FAREROW in place of BASIN_FRACTION
        ENDDO
      ENDDO

c routing parameters
!      WF_ROUTETIMESTEP=900
!      WF_TIMECOUNT=0
!      DRIVERTIMESTEP=DELT    ! Be sure it's REAL*8
	JAN=1  !jan=1 first time through, jan=2 after that

      DO I=1,NLTEST
        DO M=1,NMTEST
          DO J=1,IGND
            TBARROW(I,M,J)=TBARROW(I,M,J)+TFREZ
          END DO
          TSNOROW(I,M)=TSNOROW(I,M)+TFREZ
          TCANROW(I,M)=TCANROW(I,M)+TFREZ
          TPNDROW(I,M)=TPNDROW(I,M)+TFREZ
          TBASROW(I,M)=TBARROW(I,M,3)
          CMAIROW(I,M)=0.
          WSNOROW(I,M)=0.
          TSFSROW(I,M,1)=TFREZ
          TSFSROW(I,M,2)=TFREZ
          TSFSROW(I,M,3)=TBARROW(I,M,1)
          TSFSROW(I,M,4)=TBARROW(I,M,1)
          TACROW (I,M)=TCANROW(I,M)
          QACROW (I,M)=0.5E-2
          IF(IGND>3)THEN ! should stay this way to work with class
            DO J=4,IGND
              THLQROW(I,M,J)=THLQROW(I,M,3)
              THICROW(I,M,J)=THICROW(I,M,3)
              TBARROW(I,M,J)=TBARROW(I,M,3)
              IF(SDEPROW(I,M)<(ZBOT(J-1)+0.001) .AND.
     1          SANDROW(I,M,3)>-2.5)THEN
                SANDROW(I,M,J)=-3.0
                CLAYROW(I,M,J)=-3.0
                ORGMROW(I,M,J)=-3.0
              ELSE
                SANDROW(I,M,J)=SANDROW(I,M,3)
                CLAYROW(I,M,J)=CLAYROW(I,M,3)
                ORGMROW(I,M,J)=ORGMROW(I,M,3)
              ENDIF
            ENDDO
          ENDIF
          DO K=1,6
            DO L=1,50
              ITCTROW(I,M,K,L)=0
            ENDDO
          ENDDO

        ENDDO !DO M=1,NMTEST
      ENDDO !DO I=1,NLTEST

c clear accumulating variables
      TOTAL_ROFACC=0.0
      TOTAL_ROFOACC=0.0
      TOTAL_ROFSACC=0.0
      TOTAL_ROFBACC=0.0
      TOTAL_EVAPACC=0.0
      TOTAL_PREACC=0.0

      DO I=1,NLTEST
        PREACC(I)=0.
        GTACC(I)=0.
        QEVPACC(I)=0.
        EVAPACC(I)=0.
        HFSACC(I)=0.
        HMFNACC(I)=0.
        ROFACC(I)=0.
        ROFOACC(I)=0.
        ROFSACC(I)=0.
        ROFBACC(I)=0.
        WTBLACC(I)=0.
        ALVSACC(I)=0.
        ALIRACC(I)=0.
        RHOSACC(I)=0.
        SNOACC(I)=0.
        WSNOACC(I)=0.
        CANARE(I)=0.
        SNOARE(I)=0.
        TSNOACC(I)=0.
        TCANACC(I)=0.
        RCANACC(I)=0.
        SCANACC(I)=0.
        GROACC(I)=0.
        FSINACC(I)=0.
        FLINACC(I)=0.
        FLUTACC(I)=0.
        TAACC(I)=0.
        UVACC(I)=0.
        PRESACC(I)=0.
        QAACC(I)=0.
        DO J=1,IGND
          TBARACC(I,J)=0.
          THLQACC(I,J)=0.
          THICACC(I,J)=0.
          THALACC(I,J)=0.
        ENDDO
      ENDDO
      
C     * SET GRID-FORMAT WATROUTE OUTPUT
      DO 300 I = 1, YCOUNT
        DO 300 J = 1, XCOUNT
            RUNOFF(I, J) = 0.0
            RECHARGE(I, J) = 0.0
CDAN            LEAKAGE(I, J) = 0.0
300   CONTINUE !(I = 1, YCOUNT) (J = 1, XCOUNT)

C     * SET GRID OUPUT SUMMARY
      IF (WF_NUM_POINTS .GT. 1) THEN
        DO I = 1, WF_NUM_POINTS
            PRE_OUT(I) = 0.0
            EVAP_OUT(I) = 0.0
            ROF_OUT(I) = 0.0
        END DO
      ELSE
        PRE_OUT(1) = 0.0
        EVAP_OUT(1) = 0.0
        ROF_OUT(1) = 0.0
      END IF

C     * SET FRAME COUNT FOR WRITE_R2C
      FRAME_NO = 1
      NO_FRAMES = FRAME_NO + 1

c ******************************************************
c echo print information to MESH_output_echo_print.txt
c ******************************************************

      OPEN(UNIT=58,FILE=".\" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) //
     +                  '\MESH_output_echo_print.txt')

      WRITE(58,"('MESH_input_run_options.ini')")
      WRITE(58,*)
      WRITE(58,"('Configuration flags:')")
      IF(CONFLAGS>0) THEN
        DO I=1,CONFLAGS
          WRITE (58,*)
        ENDDO
      ENDIF
	WRITE(58,"('WF_NUM_POINTS: ',I5)") WF_NUM_POINTS
      WRITE(58,"('Out directory:',5A10)") (DIR_OUT(I),I=1,WF_NUM_POINTS)
      WRITE(58,"('Grid number:  ',5I10)") (N_OUT(I),I=1,WF_NUM_POINTS)
      WRITE(58,"('Land class:   ',5I10)") (II_OUT(I),I=1,WF_NUM_POINTS)
      WRITE (58,*)

      WRITE(58,"('MESH_parameters_hydrology.ini')")
      WRITE(58,*)
      WRITE(58,"('Option flags:')")
      IF(OPTFLAGS>0) THEN
        DO I=1,OPTFLAGS
          WRITE (58,*)
        ENDDO
      ENDIF
!      WRITE(58,"('River roughnesses:')")
!      WRITE(58,"(5F6.3)") (WF_R2(I),I=1,5) ! MAGIC NUMBER
      WRITE(58,"('Land class independent hydrologic parameters:')")
      IF(INDEPPAR>0) THEN
        DO I=1,INDEPPAR
          WRITE (58,*)
        ENDDO
      ENDIF
      WRITE(58,"('Land class dependent hydrologic parameters:')")
      IF(DEPPAR>0) THEN
      WRITE(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZSNLROW'", NMTEST
      WRITE(58,NMTESTFORMAT) (ZSNLROW(1,M),M=1,NMTEST)
      WRITE(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZPLSROW'", NMTEST
      WRITE(58,NMTESTFORMAT) (ZPLSROW(1,M),M=1,NMTEST)
      WRITE(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZPLGROW'", NMTEST
      WRITE(58,NMTESTFORMAT) (ZPLGROW(1,M),M=1,NMTEST)
      ENDIF

      WRITE (58,*)


      WRITE(58,"('MESH_parameters_CLASS.ini')")
      WRITE(58,*)
      WRITE(58,'(2X,6A4)') TITLE1,TITLE2,TITLE3,TITLE4,TITLE5,TITLE6
      WRITE(58,'(2X,6A4)') NAME1,NAME2,NAME3,NAME4,NAME5,NAME6
      WRITE(58,'(2X,6A4)') PLACE1,PLACE2,PLACE3,PLACE4,PLACE5,PLACE6
      WRITE(58,'(5F10.2,F7.1,3I5)') DEGLAT,DEGLON,ZRFMGRD(1),ZRFHGRD(1),
     +  ZBLDGRD(1), GCGRD(1),ILW,NLTEST,NMTEST
      I=1
      DO M=1,NMTEST
      WRITE(58,'(9F8.3)') (FCANROW(I,M,J),J=1,ICAN+1),(LAMXROW(I,M,J),
     +	J=1,ICAN)
      WRITE(58,'(9F8.3)') (LNZ0ROW(I,M,J),J=1,ICAN+1),(LAMNROW(I,M,J),
     1                  J=1,ICAN)
      WRITE(58,'(9F8.3)') (ALVCROW(I,M,J),J=1,ICAN+1),(CMASROW(I,M,J),
     1                  J=1,ICAN)
      WRITE(58,'(9F8.3)') (ALICROW(I,M,J),J=1,ICAN+1),(ROOTROW(I,M,J),
     1                  J=1,ICAN)
      WRITE(58,'(4F8.3,8X,4F8.3)') (RSMNROW(I,M,J),J=1,ICAN),
     1                  (QA50ROW(I,M,J),J=1,ICAN)
      WRITE(58,'(4F8.3,8X,4F8.3)') (VPDAROW(I,M,J),J=1,ICAN),
     1                  (VPDBROW(I,M,J),J=1,ICAN)
      WRITE(58,'(4F8.3,8X,4F8.3)') (PSGAROW(I,M,J),J=1,ICAN),
     1                  (PSGBROW(I,M,J),J=1,ICAN)
      WRITE(58,'(3F8.3,F8.4)') DRNROW(I,M),SDEPROW(I,M),FAREROW(I,M),
     1                  DDROW(I,M)
      WRITE(58,'(4E8.1,I8)') XSLPROW(I,M),GRKFROW(I,M),MANNROW(I,M),
     1                  WFCIROW(I,M),MIDROW(I,M)
      WRITE(58,'(3F10.1)') (SANDROW(I,M,J),J=1,IGND)
      WRITE(58,'(3F10.1)') (CLAYROW(I,M,J),J=1,IGND)
      WRITE(58,'(3F10.1)') (ORGMROW(I,M,J),J=1,IGND)
      WRITE(58,'(6F10.2)') (TBARROW(I,M,J),J=1,IGND),TCANROW(I,M),
     1                  TSNOROW(I,M),TPNDROW(I,M)
      WRITE(58,'(7F10.3)') (THLQROW(I,M,J),J=1,IGND),(THICROW(I,M,J),
     1                  J=1,IGND),ZPNDROW(I,M)
      WRITE(58,'(2F10.4,F10.2,F10.3,F10.4,F10.3)') 
     +                  RCANROW(I,M),SCANROW(I,M),SNOROW(I,M),
     1                  ALBSROW(I,M),RHOSROW(I,M),GROROW(I,M)
      WRITE(58,*)
      ENDDO

C     * R2C-FORMAT OUTPUT FILES (RUNOFF, RECHARGE, AND LEAKAGE VALUES)
C     * CALL WRITE_R2C TO WRITE R2C-FORMAT FILES
      AUTHOR = "MESH_DRIVER"
      IF (MODELFLG .EQ. "i") AUTHOR="MESH_DRIVER (rte -i)"
      IF (MODELFLG .EQ. "r") AUTHOR="MESH_DRIVER (rte -r)"
      IF (MODELFLG .EQ. "l") AUTHOR="MESH_DRIVER (rte -l)"
      COORDSYS_TEMP = COORDSYS1
      ZONE_TEMP = ZONE1
      DATUM_TEMP = DATUM1
      XORIGIN_TEMP = XORIGIN
      YORIGIN_TEMP = YORIGIN
      XCOUNT_TEMP = XCOUNT
      YCOUNT_TEMP = YCOUNT
      XDELTA_TEMP = XDELTA
      YDELTA_TEMP = YDELTA
      SOURCE_FILE_NAME = "CLASS"

C     * OPEN RTE.EXE INPUT FILES (UNIT 261, UNIT 262)
CDAN  UNIT NUMBERS HAVE BEEN PULLED FROM RTE.EXE SUBROUTINES, THEIR 
CDAN  FILE NAMES (FLN(31), FLN(32)) ARE READ FROM THE EVENT FILE
CDAN  FILES ARE OPENED ACCORDING TO MODELFLG IN THE EVENT FILE

      IF (MODELFLG.EQ."i" .OR. MODELFLG.EQ."r" .OR. MODELFLG.EQ."l") 
     1  THEN !WRITE RUNOFF HEADER
        NAME = "Gridded Channel Inflow"
        ATTRIBUTE_NAME = "channel_inflow"
        ATTRIBUTE_UNITS = "mm"
        ATTRIBUTE_TYPE = "flow"
        CALL WRITE_R2C (261, 31, 0, 1, 0, 1, 1)
      END IF

      IF (MODELFLG .EQ. "r") THEN !WRITE RECHARGE HEADER
        NAME = "Gridded Recharge"
        ATTRIBUTE_NAME = "recharge"
        ATTRIBUTE_UNITS = "mm"
        ATTRIBUTE_TYPE = "flow"
        CALL WRITE_R2C (262, 32, 0, 1, 0, 1, 1)
      END IF

CDAN      IF (MODELFLG .EQ. "l") THEN !WRITE RECHARGE HEADER
CDAN        NAME = "Gridded Leakage"
CDAN        ATTRIBUTE_NAME = "leakage"
CDAN        ATTRIBUTE_UNITS = "cms"
CDAN        ATTRIBUTE_TYPE = " "
CDAN        CALL WRITE_R2C (263, 33, 0, 1, 0, 1, 1)
CDAN      END IF

c *********************************************************************
c Open the MESH_input_forcing.bin file
c *********************************************************************

      OPEN(UNIT=51,FILE='MESH_input_forcing.bin',STATUS='OLD',
     +           FORM='UNFORMATTED')

      !IYEAR is set in the MESH_parameters_CLASS.ini file
      !IYEAR_START is set in the MESH_input_run_options.ini file
!P      !IYEAR_START is set in the MESH_parameters_class.ini file

      !the following code is used to skip entries at the start
      !of the bin file

!PARAMESH

      nyy = IYEAR_START - IYEAR
      ndy = IDAY_START  - IDAY
      nmy = IMIN_START  - IMIN !P
      nhy = IHOUR_START - IHOUR !P
!P      nmy = IMIN
!P      nhy = 24 - IHOUR
      ! set ISTEP_START based on HOURLYFLAG
      !  (could be optimised as ISTEP_START = 2 - HOURLYFLAG)
      IF (HOURLYFLAG == 1) THEN
        ISTEP_START = 1
      ELSE
        ISTEP_START = 2
      ENDIF
      nrs =(nyy*365+ndy)*24*istep_START + nhy*istep_START + nmy/30 !P
!P      nrs =(nyy*365+ndy)*24*istep_START + nhy*istep_START - nmy/30
      IF (IYEAR_START == 0 .AND. IDAY_START == 0 .AND. IMIN_START == 0
     +    .AND. IHOUR_START == 0) THEN !P
!P      IF ((IYEAR_START == 0 .AND. IDAY_START == 0) .OR.
!P     1    (IYEAR_START == IYEAR .AND. IDAY_START == IDAY)) THEN
        !Special case, all 0s. Automatically start at the beginning.
!P        Another special case, starting date is the start date
        IYEAR_START = IYEAR
        IDAY_START = IDAY
        IHOUR_START = IHOUR !P
        IMIN_START = IMIN !P
        nrs = 0
      ELSEIF (nrs<0) THEN
        PRINT*,'Desired start date is before the start of the ',
     +    'data in MESH_input_forcing.bin'
        PRINT *, 'Please adjust the start date in ',
     +    'MESH_input_run_options.ini'
        STOP
      ENDIF

      PRINT *, 'Skipping',NRS,'Registers in bin file'
      IYEAR = IYEAR_START
      IDAY = IDAY_START
!      IHOUR = IHOUR_START
!      IMIN = IMIN_START

      !calculate number of data values that will be in the file
      toskip = BASINSHORTWAVEFLAG + BASINLONGWAVEFLAG + BASINRAINFLAG +
     +         BASINTEMPERATUREFLAG + BASINWINDFLAG + BASINPRESFLAG +
     +         BASINHUMIDITYFLAG
      toskip = 7 - toskip
      DO i=1,nrs
        DO J=1,toskip
          READ(51,END=999)
        ENDDO
      ENDDO



c *********************************************************************
c Open and print header information to the output files
c *********************************************************************
      OPEN(UNIT=70,FILE=".\" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) //
     +                  '\MESH_output_streamflow.csv')

c Set up the CLASSOF* files to print out into the correct directory
      DO I=1, wf_num_points
        BNAM=DIR_OUT(i)
        OPEN(UNIT=150+i*10+1,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF1.csv")
        OPEN(UNIT=150+i*10+2,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF2.csv")
        OPEN(UNIT=150+i*10+3,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF3.csv")
        OPEN(UNIT=150+i*10+4,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF4.csv")
        OPEN(UNIT=150+i*10+5,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF5.csv")
        OPEN(UNIT=150+i*10+6,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF6.csv")
        OPEN(UNIT=150+i*10+7,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF7.csv")
        OPEN(UNIT=150+i*10+8,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF8.csv")
        OPEN(UNIT=150+i*10+9,FILE=".\"//BNAM(1:INDEX(BNAM," ")-1)//
     +   "\CLASSOF9.csv")
        
        DO j=1, 9
          WRITE(150+i*10+j,'("CLASS TEST RUN:     ",6A4)') TITLE1,
     +                           TITLE2,TITLE3,TITLE4,TITLE5,TITLE6
          WRITE(150+i*10+j,'("RESEARCHER:         ",6A4)') NAME1,
     +                           NAME2,NAME3,NAME4,NAME5,NAME6
          WRITE(150+i*10+j,'("INSTITUTION:        ",6A4)') PLACE1,
     +                           PLACE2,PLACE3,PLACE4,PLACE5,PLACE6
        ENDDO
        
        WRITE(150+i*10+1,6011)
 6011   FORMAT('IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,SNOMLT,BEG,GTOUT,
     1   SNOACC(I),RHOSACC(I),WSNOACC(I),ALTOT,ROFACC(I),ROFOACC(I),
     2   ROFSACC(I),ROFBACC(I)')
        WRITE(150+i*10+2,6012)
 6012   FORMAT('IDAY,IYEAR,TBARACC(I 1)-TFREZ,THLQACC(I 1),THICACC(I 1),
     1   TBARACC(I 2)-TFREZ,THLQACC(I 2),THICACC(I 2),
     2   TBARACC(I 3)-TFREZ,THLQACC(I 3),THICACC(I 3),TCN,RCANACC(I),
     3   SCANACC(I),TSN,ZSN')
        WRITE(150+i*10+3,6013)
 6013   FORMAT('IDAY,IYEAR,FSINACC(I),FLINACC(I),TAACC(I)-TFREZ,
     1   UVACC(I),PRESACC(I),QAACC(I),PREACC(I),EVAPACC(I)')
        WRITE(150+i*10+4,6014)
 6014   FORMAT('IHOUR,IMIN,IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,SNOMLT,BEG,
     1   GTOUT,SNOROW(I M),RHOSROW(I M),WSNOROW(I M),ALTOT,ROFROW(I M),
     2   TPN,ZPNDROW(I M)')
        WRITE(150+i*10+5,6015)
 6015   FORMAT('IHOUR,IMIN,IDAY,IYEAR,TBARROW(I M 1)-TFREZ,
     1   THLQROW(I M 1),THICROW(I M 1),TBARROW(I M 2)-TFREZ,
     2   THLQROW(I M 2),THICROW(I M 2),TBARROW(I M 3)-TFREZ,
     3   THLQROW(I M 3),THICROW(I M 3),TCN,RCANROW(I M),SCANROW(I M),
     4   TSN,ZSN')
        WRITE(150+i*10+6,6016)
 6016   FORMAT('IHOUR,IMIN,IDAY,FSDOWN(I),FDLGRD(I),PREGRD(I),
     1   TAGRD(I)-TFREZ,UVGRD(I),PRESGRD(I),QAGRD(I)')
        WRITE(150+i*10+7,6017)
 6017   FORMAT('TROFROW(I M),TROOROW(I M),TROSROW(I M),TROBROW(I M),
     1   ROFROW(I M),ROFOROW(I M),ROFSROW(I M),ROFBROW(I M),
     2   FCS(I),FGS(I),FC(I),FG(I)')
        WRITE(150+i*10+8,6018)
 6018   FORMAT('FSGVROW(I M),FSGSROW(I M),FSGGROW(I M),FLGVROW(I M),
     1   FLGSROW(I M),FLGGROW(I M),HFSCROW(I M),HFSSROW(I M),
     2   HFSGROW(I M),HEVCROW(I M),HEVSROW(I M),HEVGROW(I M),
     3   HMFCROW(I M),HMFNROW(I M),HMFGROW(I M 1),HMFGROW(I M 2),
     4   HMFGROW(I M 3),HTCCROW(I M),HTCSROW(I M),HTCROW(I M 1),
     5   HTCROW(I M 2),HTCROW(I M 3)')
        WRITE(150+I*10+9,6019)
 6019   FORMAT('PCFCROW(I M),PCLCROW(I M),PCPNROW(I M),PCPGROW(I M),
     1   QFCFROW(I M),QFCLROW(I M),QFNROW(I M),QFGROW(I M),
     2   QFCROW(I M 1),QFCROW(I M 2),QFCROW(I M 3),ROFCROW(I M),
     3   ROFNROW(I M),ROFOROW(I M),ROFROW(I M),WTRCROW(I M),
     4   WTRSROW(I M),WTRGROW(I M)')
      ENDDO


c *********************************************************************
c Open and read in values from wfo_spec.txt file
c *********************************************************************

C     * ENSIM: Open wfo_spec.txt to read in which parameters to output
        OPEN(unit=56,file='wfo_spec.txt',status='old',iostat=ensim_ios)
        !IOSTAT returns 0 on successful file open
        IF(ensim_ios==0)THEN
          READ(56,'(I5)',iostat=ios)nj
          READ(56,'(I5)',iostat=ios)ireport

C         Allocate the necessary arrays
          ALLOCATE (wfo_pick(nj))
          ALLOCATE (wfo_attributes(nj))

          IF(ios/=0)THEN
            PRINT*,' Problem reading the first two lines of the'
            PRINT*,' wfo_spec.txt file'
            PRINT*
            STOP
          ENDIF
          PRINT*,' WFO_SPEC.TXT file found,'
          PRINT*,' The following EnSim output will be written:'

          DO j=1,nj
            READ(56,'(i1,5x,a50)',iostat=ios)wfo_pick(j),
     +        wfo_attributes(j)
            !IOSTAT returns 0 on successful file open
            IF(ios/=0)THEN
              PRINT*,'iostat code =',ios
              PRINT*,' Read to line ',j,' in wfo_spec.txt'
              PRINT*,' then a problem was found'
              STOP
            ENDIF
            IF(wfo_pick(j)==1)THEN
              PRINT*,wfo_attributes(j)
            ENDIF
          ENDDO
          CLOSE(unit=56,status='keep')
        ELSE
          PRINT*,'WFO_SPEC.TXT file not found, no EnSim output'//
     +           ' will be written'
        ENDIF
        PRINT *


!>>>>>>>>>>>>>>>>>> AB:  ENSIM HEADERS
C
C
C         WRITE THE HEADER FOR ENSIM FILES:

      IF(ensim_ios==0)THEN
       CALL write_both_headers('UTM     ',XCOUNT,YCOUNT,3000.0,
     *         477000.0,6699000.0,NMTEST,jan,wfo_pick,wf_landclassname,
     *         NMOS,currec)
      ENDIF
C
C For the ENSIM timestamp
      wfo_seq=0

C End of ENSIM Changes




c *********************************************************************
c Output information to screen
c *********************************************************************

      PRINT *, 'NUMBER OF GRID SQUARES: ',NLTEST
	PRINT *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NMTEST
	PRINT *, 'NUMBER OF RIVER CLASSES: ', NRVR
	PRINT *, 'MINIMUM NUMBER FOR ILG: ',NLTEST*NMTEST
      PRINT *, 'NUMBER OF GRID SQUARES IN X DIRECTION: ', YCOUNT
      PRINT *, 'NUMBER OF GRID SQUARES IN Y DIRECTION: ', XCOUNT
      PRINT *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', AL
	PRINT *, 'NUMBER OF DRAINAGE OUTLETS: ', NAA
!	PRINT *, 'NUMBER OF STREAMFLOW GUAGES: ', WF_NO
!      DO I=1,WF_NO
!        PRINT *,'STREAMFLOW STATION: ',I,'I: ',WF_IY(I),'J: ',WF_JX(I)
!      ENDDO
!Diane      PRINT *, 'NUMBER OF RESERVOIR STATIONS: ', WF_NORESV
!Diane      IF( WF_NORESV>0 ) THEN
!Diane        DO I=1,WF_NORESV
!Diane       PRINT *,'RESERVOIR STATION: ',I,'I: ',WF_IRES(I),'J: ',WF_JRES(I)
!Diane        ENDDO
!Diane      ENDIF

      PRINT *
      PRINT *, 'Found these output locations:'
      PRINT *, 'Output Directory, grid number, land class number'
      DO I=1, WF_NUM_POINTS
        PRINT *, DIR_OUT(I),N_OUT(I),II_OUT(I)
      ENDDO
      PRINT *


	PRINT *
	PRINT *, 'DONE INTITIALIZATION'
      PRINT *
	WRITE (6, 8400) "STARTING MESH (PRECIP, EVAP, RUNOFF)"

c *********************************************************************
c Call CLASSB to set more CLASS variables
c *********************************************************************
!bjd - July 25, 2005: For inputting field measured soil properties.

      IF(soil_ios/=0) THEN

      CALL CLASSB(THPROW,THRROW,THMROW,BIROW,PSISROW,GRKSROW,
     1            THRAROW,HCPSROW,TCSROW,THFCROW,PSIWROW,
     2            DLZWROW,ZBTWROW,ALGWROW,ALGDROW,
     3            SANDROW,CLAYROW,ORGMROW,DELZ,ZBOT,
     4            SDEPROW,ISNDROW,
     5            IORG,NA,NTYPE,NLTEST,NMTEST,IGND)

      ELSE

      CALL CLASSBHYD(THPROW,THRROW,THMROW,BIROW,PSISROW,GRKSROW,
     1            THRAROW,HCPSROW,TCSROW,THFCROW,PSIWROW,
     2            DLZWROW,ZBTWROW,ALGWROW,ALGDROW,
     3            SANDROW,CLAYROW,ORGMROW,DELZ,ZBOT,
     4            SDEPROW,ISNDROW,
     5            IORG,NLAT,NMOS,NLTEST,NMTEST,IGND,wc_thpor,wc_thlret,
     6            wc_thlmin,wc_bi,wc_psisat,wc_grksat,wc_hcps,wc_tcs,
     7            wc_algwet,wc_algdry)

      ENDIF

c *********************************************************************
c Start of main loop that is run each half hour
c *********************************************************************



200   CONTINUE

      N=N+1
C
c *********************************************************************
c Read in Meteorological forcing data
c *********************************************************************

C     * READ IN METEOROLOGICAL FORCING DATA FOR CURRENT TIME STEP;
C     * CALCULATE SOLAR ZENITH ANGLE AND COMPONENTS OF INCOMING SHORT-
C     * WAVE RADIATION FLUX; ESTIMATE FLUX PARTITIONS IF NECESSARY.
C
      

      IF( (HOURLYFLAG == 1 .AND. IMIN==0) !hourly forcing data
     +  .OR.
     +     HOURLYFLAG == 0) THEN !half-hourly forcing data

        IF(BASINSHORTWAVEFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4SHRTGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        IF(BASINLONGWAVEFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4LONGGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        IF(BASINRAINFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4RAINGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        IF(BASINTEMPERATUREFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4TEMPGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        IF(BASINWINDFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4WINDGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        IF(BASINPRESFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4PRESGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        IF(BASINHUMIDITYFLAG==0)THEN !use c05 code
          READ(51,END=999) ((R4HUMDGRID2D(I,J),J=1,XCOUNT),I=1,YCOUNT)
        ENDIF
        DO I=1,NLTEST
          IF(BASINSHORTWAVEFLAG==0)THEN !use c05 code
            FSDOWN(I)=R4SHRTGRID2D(YYY(I),XXX(I))
            FSVHGRD(I)=0.5*R4SHRTGRID2D(YYY(I),XXX(I))
            FSIHGRD(I)=FSVHGRD(I)
          ENDIF
          IF (BASINLONGWAVEFLAG == 0) THEN !use c05 code
            FDLGRD(I)=R4LONGGRID2D(YYY(I),XXX(I))
          ENDIF
          IF (BASINRAINFLAG == 0) THEN !use c05 code
            PREGRD(I)=R4RAINGRID2D(YYY(I),XXX(I)) !c05
          ENDIF
!c         to convert precipitation in mm/s - S.M. Feb 25, 2008
!         PREGRD(I)=R4RAINGRID2D(IY,JX)*ISTEP_START/3600
          IF (BASINTEMPERATUREFLAG == 0) THEN !use c05 code
            TAGRD(I)=R4TEMPGRID2D(YYY(I),XXX(I))
          ENDIF
          IF (BASINWINDFLAG == 0) THEN !use c05 code
            ULGRD(I)=R4WINDGRID2D(YYY(I),XXX(I))
          ENDIF
          VLGRD(I)=0.0
          UVGRD(I)=MAX(VMIN,ULGRD(I))
          IF (BASINPRESFLAG == 0) THEN !use c05 code
            PRESGRD(I)=R4PRESGRID2D(YYY(I),XXX(I))
          ENDIF
          IF (BASINHUMIDITYFLAG == 0) THEN !use c05 code
            QAGRD(I)=R4HUMDGRID2D(YYY(I),XXX(I))
          ENDIF
        END DO
      ENDIF


c *********************************************************************
c Read in current reservoir release value
c *********************************************************************

!Diane This is only for watroute
c only read in current value if we are on the correct time step
c however put in an exception if this is the first time through (ie. jan=1),
c otherwise depending on the hour of the first time step
c there might not be any data in wf_qrel, wf_qhyd
c make sure we have a controlled reservoir (if not the mod(IHOUR,wf_ktr)
c may give an error Frank S Jun 2007
!Diane      IF(WF_NORESV_CTRL>0) THEN
!Diane        IF(MOD(IHOUR,WF_KTR)==0.AND.IMIN==0) THEN
c         READ in current reservoir value
!Diane          READ(21,'(100F10.3)',IOSTAT=IOS)(WF_QREL(I),
!Diane     +		I=1,WF_NORESV_CTRL)
!Diane          IF(IOS/=0) THEN
!Diane            PRINT *, 'ran out of reservoir data before met data'
!Diane            STOP
!Diane	    ENDIF
!Diane        ELSE
!Diane          IF (JAN==1.AND.WF_NORESV_CTRL>0) THEN
!Diane            READ(21,'(100F10.3)',IOSTAT=IOS)(WF_QREL(I),
!Diane     +	      I=1,WF_NORESV_CTRL)
!Diane            REWIND 21
!Diane            READ(21,*)
!Diane            DO I=1,WF_NORESV
!Diane              READ(21,*)
!Diane   	      ENDDO
!Diane          ENDIF
!Diane        ENDIF
!Diane      ENDIF

!c *********************************************************************
!c Read in current streamflow value
!c *********************************************************************

!c only read in current value if we are on the correct time step
!c also read in the first value if this is the first time through
!      IF(MOD(IHOUR,WF_KT)==0.AND.IMIN==0) THEN
!c       read in current streamflow value
!        READ(22,'(100F10.3)',IOSTAT=IOS) (WF_QHYD(I),I=1,WF_NO)
!        IF(IOS/=0) THEN
!          PRINT *, 'ran out of streamflow data before met data'
!	    STOP
!		ENDIF
!      ELSE
!	    IF(JAN==1) THEN
!          READ(22,'(100F10.3)',IOSTAT=IOS) (WF_QHYD(I),I=1,WF_NO)
!          REWIND 22
!          READ(22,*)
!          READ(22,*)
!	    DO I=1,WF_NO
!            READ(22,*)
!          ENDDO
!	    ENDIF
!      ENDIF

c *********************************************************************
c Set some more CLASS parameters
c *********************************************************************

      !This estimates the fractional cloud cover (FCLOGRD) by the basis
      ! of the solar zenith angle and the occurrence of precipitation.
      ! Assumed to be 1 (100%) when precipitation occurs and somewhere
      ! in the range of [0.1,1] based on the location of the sun in the
      ! sky when precipitation is not occuring. (0.1 when the sun is at
      ! the zenith, 1 when the sun is at the horizon).
      RDAY=REAL(IDAY)+(REAL(IHOUR)+REAL(IMIN)/60.)/24.
      DECL=SIN(2.*PI*(284.+RDAY)/365.)*23.45*PI/180.
      HOUR=(REAL(IHOUR)+REAL(IMIN)/60.)*PI/12.-PI
      COSZ=SIN(RADJGRD(1))*SIN(DECL)+COS(RADJGRD(1))*COS(DECL)*COS(HOUR)

      DO I=1,NLTEST
        CSZGRD(I)=SIGN(MAX(ABS(COSZ),1.0E-3),COSZ)
        IF(PREGRD(I)>0.) THEN
          XDIFFUS(I)=1.0
        ELSE
          XDIFFUS(I)=MAX(0.0,MIN(1.0-0.9*COSZ,1.0))
        ENDIF
        FCLOGRD(I)=XDIFFUS(I)
      ENDDO

c *********************************************************************
c Start of calls to CLASS subroutines
c *********************************************************************
C
      CALL CLASSI(VPDGRD,TADPGRD,PADRGRD,RHOAGRD,RHSIGRD,
     1            RPCPGRD,TRPCGRD,SPCPGRD,TSPCGRD,TAGRD,QAGRD,
     2            PREGRD,RPREGRD,SPREGRD,PRESGRD,
     3            IPCP,NA,1,NLTEST)
C
      CALL GATPREP(ILMOS,JLMOS,IWMOS,JWMOS,IWAT,IICE,
     1             NML,NMW,NWAT,NICE,GCGRD,FAREROW,MIDROW,
     2             NA,NTYPE,ILG,1,NLTEST,NMTEST)

C Calculate initial storage (after reading in resume.txt file if applicable)

      IF(JAN==1) THEN
        INIT_STORE=0.0
        DO I=1,NLTEST
        DO M=1,NMTEST
          IF(FRAC(I)>0.0)THEN
            INIT_STORE=INIT_STORE+(RCANROW(I,M)+SCANROW(I,M)+SNOROW(I,M)
     1      +(THLQROW(I,M,1)*RHOW+THICROW(I,M,1)*RHOICE)*
     2            DLZWROW(I,M,1)+ZPNDROW(I,M)*RHOW
     3      +(THLQROW(I,M,2)*RHOW+THICROW(I,M,2)*RHOICE)*DLZWROW(I,M,2)
     4      +(THLQROW(I,M,3)*RHOW+THICROW(I,M,3)*RHOICE)*DLZWROW(I,M,3))
     5      *FAREROW(I,M)
	    ENDIF
        ENDDO
        ENDDO
      ENDIF

C
      CALL CLASSG (TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT,
     1             TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT,
     2             TCANGAT,RCANGAT,SCANGAT,GROGAT, CMAIGAT,
     3             FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,LAMXGAT,
     4             LAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT,
     5             VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,AILDGAT,
     6             HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT,
     7             THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT,
     8             GRKSGAT,THRAGAT,HCPSGAT,TCSGAT,
     9             THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT,
     A             ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT,
     B             DRNGAT, XSLPGAT,GRKFGAT,WFSFGAT,WFCIGAT,
     C             ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT,
     D             AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT,
     E             ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT,
     F             FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT,
     G             TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT,
     H             VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT,
     I             SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT,
     J             GGEOGAT,
     K             CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT,
     L             QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT,
     M             GTGAT,  QGGAT,  TSFGAT, ALVSGAT,ALIRGAT,
     N             SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT,
     O             FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT,
     P             FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT,
     Q             HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT,
     R             HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT,
     S             QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT,
     T             ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT,
     U             TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT,
     V             WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,
     W             HMFGGAT,HTCGAT, QFCGAT, ITCTGAT,
     X             ILMOS,JLMOS,IWMOS,JWMOS,
     Y             NML,NA,NTYPE,NA*NTYPE,IGND,ICAN,ICP1,
     Z             TBARROW,THLQROW,THICROW,TPNDROW,ZPNDROW,
     +             TBASROW,ALBSROW,TSNOROW,RHOSROW,SNOROW,
     +             TCANROW,RCANROW,SCANROW,GROROW, CMAIROW,
     +             FCANROW,LNZ0ROW,ALVCROW,ALICROW,LAMXROW,
     +             LAMNROW,CMASROW,ROOTROW,RSMNROW,QA50ROW,
     +             VPDAROW,VPDBROW,PSGAROW,PSGBROW,AILDROW,
     +             HGTDROW,ACVDROW,ACIDROW,TSFSROW,WSNOROW,
     +             THPROW, THRROW, THMROW, BIROW,  PSISROW,
     +             GRKSROW,THRAROW,HCPSROW,TCSROW,
     +             THFCROW,PSIWROW,DLZWROW,ZBTWROW,
     +             ZSNLROW,ZPLGROW,ZPLSROW,TACROW, QACROW,
     +             DRNROW, XSLPROW,GRKFROW,WFSFROW,WFCIROW,
     +             ALGWROW,ALGDROW,ASVDROW,ASIDROW,AGVDROW,
     +             AGIDROW,ISNDROW,RADJGRD,ZBLDGRD,Z0ORGRD,
     +             ZRFMGRD,ZRFHGRD,ZDMGRD, ZDHGRD, FSVHGRD,
     +             FSIHGRD,CSZGRD, FDLGRD, ULGRD,  VLGRD,
     +             TAGRD,  QAGRD,  PRESGRD,PREGRD, PADRGRD,
     +             VPDGRD, TADPGRD,RHOAGRD,RPCPGRD,TRPCGRD,
     +             SPCPGRD,TSPCGRD,RHSIGRD,FCLOGRD,DLONGRD,
     +             GGEOGRD,MANNROW,MANNGAT,DDROW,DDGAT  )
      IF(BASINSHORTWAVEFLAG==1)THEN !use Pablo's code
        READ(90,'(3f11.5)'),FSDOWN1,FSDOWN2,FSDOWN3
        DO I=1,NML
C READ FROM FILE THE INCOMING SHORT WAVE (NF=fsdown1,SF=fsdown2,FLAT=fsdown3)
C AND APPLY THOSE VALUES TO THE 13 TILES (GRUs)
c 1F+NF,2F+SF,3F+EF,4F+flat,5S+NF,6S+SF,7S+EF,8S+flat
c 9A+NF,10A+SF,11A+EF,12A+flat,13WATER+flat

! THIS IS A TERRIBLE HACK TO PABLO'S TERRIBLE HACK BECAUSE I DON'T UNDERSTAND
! HOW TO RESOLVE THIS CONFLICT INVOLVING FSDOWN
          IF(jlmos(I)==1.or.jlmos(I)==5.or.jlmos(I)==9) THEN
            IF(ihour==7) THEN
              CONTINUE
            ENDIF
            !fsdown=fsdown1
            !FSVHGAT(I)=0.5*FSDOWN
            !FSIHGAT(I)=0.5*FSDOWN
            FSVHGAT(I)=0.5*FSDOWN1
            FSIHGAT(I)=0.5*FSDOWN1
          ELSEIF(jlmos(I)==2.or.jlmos(I)==6
     +           .or.jlmos(I)==10) THEN
            !fsdown=fsdown2
            !FSVHGAT(I)=0.5*FSDOWN
            !FSIHGAT(I)=0.5*FSDOWN
            FSVHGAT(I)=0.5*FSDOWN2
            FSIHGAT(I)=0.5*FSDOWN2
          ELSE
            !fsdown=fsdown3
            !FSVHGAT(I)=0.5*FSDOWN
            !FSIHGAT(I)=0.5*FSDOWN
            FSVHGAT(I)=0.5*FSDOWN3
            FSIHGAT(I)=0.5*FSDOWN3
          ENDIF
        END DO
      ENDIF

! FUTUREDO: Ensure assumptions on reading the longwave/rain/etc. data
! is correct.

! *********************************************************************
! basin_shortwave.csv -- is this a better version than above?
!                        assuming we change the input files to this
! *********************************************************************
C      IF (BASINSHORTWAVEFLAG == 1) THEN
C        DO I = 1, NLTEST
C          READ (90, *) FSVHGAT(I)
C          FSIHGAT(I) = FSVHGAT(I)
C        END DO
C      ENDIF

! *********************************************************************
! basin_longwave.csv
! *********************************************************************
      IF (BASINLONGWAVEFLAG == 1) THEN
        DO I = 1, NLTEST
          READ (91, *) FDLGRD(I)
        END DO
      ENDIF

! *********************************************************************
! basin_rain.csv
! *********************************************************************
      IF (BASINRAINFLAG == 1) THEN
        DO I = 1, NLTEST
          READ (92, *) PREGRD(I)
        END DO
      ENDIF

! *********************************************************************
! basin_temperature.csv
! *********************************************************************
      IF (BASINTEMPERATUREFLAG == 1) THEN
        DO I = 1, NLTEST
          READ (93, *) TAGRD(I)
        END DO
      ENDIF

! *********************************************************************
! basin_wind.csv
! *********************************************************************
      IF (BASINWINDFLAG == 1) THEN
        DO I = 1, NLTEST
          READ (94, *) ULGRD(I)
        END DO
      ENDIF

! *********************************************************************
! basin_pres.csv
! *********************************************************************
      IF (BASINPRESFLAG == 1) THEN
        DO I = 1, NLTEST
          READ (95, *) PRESGRD(I)
        END DO
      ENDIF

! *********************************************************************
! basin_humidity.csv
! *********************************************************************
      IF (BASINHUMIDITYFLAG == 1) THEN
        DO I = 1, NLTEST
          READ (96, *) QAGRD(I)
        END DO
      ENDIF

C
C========================================================================
C
      CALL CLASSZ (0,      CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP,
     1             WTVSTP, WTSSTP, WTGSTP,
     2             FSGVGAT,FLGVGAT,HFSCGAT,HEVCGAT,HMFCGAT,HTCCGAT,
     3             FSGSGAT,FLGSGAT,HFSSGAT,HEVSGAT,HMFNGAT,HTCSGAT,
     4             FSGGGAT,FLGGGAT,HFSGGAT,HEVGGAT,HMFGGAT,HTCGAT,
     5             PCFCGAT,PCLCGAT,QFCFGAT,QFCLGAT,ROFCGAT,WTRCGAT,
     6             PCPNGAT,QFNGAT, ROFNGAT,WTRSGAT,PCPGGAT,QFGGAT,
     7             QFCGAT, ROFGAT, WTRGGAT,CMAIGAT,RCANGAT,SCANGAT,
     8             TCANGAT,SNOGAT, WSNOGAT,TSNOGAT,THLQGAT,THICGAT,
     9             HCPSGAT,THPGAT, DLZWGAT,TBARGAT,ZPNDGAT,TPNDGAT,
     A             DELZ,   FCS,    FGS,    FC,     FG,
     B             1,      NML,    NA*NTYPE,    IGND,   N    )
C
C========================================================================
C
C     * ALBEDO AND TRANSMISSIVITY CALCULATIONS; GENERAL VEGETATION
C     * CHARACTERISTICS.
C
      CALL CLASSA    (FC,     FG,     FCS,    FGS,    ALVSCN, ALIRCN,
     1                ALVSG,  ALIRG,  ALVSCS, ALIRCS, ALVSSN, ALIRSN,
     2                ALVSGC, ALIRGC, ALVSSC, ALIRSC,
     3                TRVSCN, TRIRCN, TRVSCS, TRIRCS, AILCAN, AILCNS,
     4                FSVF,   FSVFS,  RAICAN, RAICNS, SNOCAN, SNOCNS,
     5                FRAINC, FSNOWC, DISP,   DISPS,  ZOMLNC, ZOMLCS,
     6                ZOELNC, ZOELCS, ZOMLNG, ZOMLNS, ZOELNG, ZOELNS,
     7                CHCAP,  CHCAPS, CMASSC, CMASCS, CWLCAP, CWFCAP,
     8                CWLCPS, CWFCPS, RC,     RCS,    RBCOEF, FROOT,
     9                ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TRSNOW, ZSNOW,
     A                WSNOGAT,ALVSGAT,ALIRGAT,HTCCGAT,HTCSGAT,HTCGAT,
     B                WTRCGAT,WTRSGAT,WTRGGAT,CMAIGAT,FSNOGAT,
     C                FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,LAMXGAT,LAMNGAT,
     D                CMASGAT,ROOTGAT,RSMNGAT,QA50GAT,VPDAGAT,VPDBGAT,
     E                PSGAGAT,PSGBGAT,AILDGAT,HGTDGAT,ACVDGAT,ACIDGAT,
     F                ASVDGAT,ASIDGAT,AGVDGAT,AGIDGAT,ALGWGAT,ALGDGAT,
     G                THLQGAT,THICGAT,TBARGAT,RCANGAT,SCANGAT,TCANGAT,
     H                GROGAT, SNOGAT, TSNOGAT,RHOSGAT,ALBSGAT,ZBLDGAT,
     I                Z0ORGAT,ZSNLGAT,ZPLGGAT,ZPLSGAT,
     J                FCLOGAT,TAGAT,  VPDGAT, RHOAGAT,CSZGAT,
     K                FSVHGAT,RADJGAT,DLONGAT,RHSIGAT,DELZ,   DLZWGAT,
     L                ZBTWGAT,THPGAT, THMGAT, PSISGAT,BIGAT,  PSIWGAT,
     M                HCPSGAT,ISNDGAT,IDAY,   NA*NTYPE,    1,      NML,
     N                JLAT,   ICAN,   ICAN+1, IGND,   IDISP,  IZREF,
     O                IWF,    ILAI,   IHGT,   IALC,   IALS,   IALG  )
C
C-----------------------------------------------------------------------
C          * SURFACE TEMPERATURE AND FLUX CALCULATIONS.
C
      CALL  CLASST     (TBARC,  TBARG,  TBARCS, TBARGS, THLIQC, THLIQG,
     1  THICEC, THICEG, HCPC,   HCPG,   TCTOP,  TCBOT,  GZEROC, GZEROG,
     2  GZROCS, GZROGS, G12C,   G12G,   G12CS,  G12GS,  G23C,   G23G,
     3  G23CS,  G23GS,  QFREZC, QFREZG, QMELTC, QMELTG, EVAPC,  EVAPCG,
     4  EVAPG,  EVAPCS, EVPCSG, EVAPGS, TCANO,  TCANS,
     5  RAICAN, SNOCAN, RAICNS, SNOCNS, CHCAP,  CHCAPS, TPONDC, TPONDG,
     6  TPNDCS, TPNDGS, TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS,
     7  ZTHRC,  ZTHRG,  ZTHRCS, ZTHRGS,
     8  ITCTGAT,CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT,QFSGAT, QFXGAT,
     9  PETGAT, GAGAT,  EFGAT,  GTGAT,  QGGAT,  TSFGAT, SFCTGAT,SFCUGAT,
     A  SFCVGAT,SFCQGAT,FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT,FLGGGAT,
     B  HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT,HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,
     C  HTCCGAT,HTCSGAT,HTCGAT, DRGAT,  WTABGAT,ILMOGAT,UEGAT,  HBLGAT,
     D  TACGAT, QACGAT, ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, TBAR3,
     E  VPDGAT, TADPGAT,RHOAGAT,FSVHGAT,FSIHGAT,FDLGAT, ULGAT,  VLGAT,
     F  TAGAT,  QAGAT,  PADRGAT,FC,     FG,     FCS,    FGS,    RBCOEF,
     G  AILCAN, AILCNS, FSVF,   FSVFS,  ALVSCN, ALIRCN, ALVSG,  ALIRG,
     H  ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, ALIRSC,
     I  TRVSCN, TRIRCN, TRVSCS, TRIRCS,
     J  RC,     RCS,    FRAINC, FSNOWC, CMASSC, CMASCS, DISP,   DISPS,
     K  ZOMLNC, ZOELNC, ZOMLNG, ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS,
     L  TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT,TBASGAT,TCANGAT,TSNOGAT,
     M  ZSNOW,  TRSNOW, RHOSGAT,WSNOGAT,THPGAT, THRGAT, THMGAT, THFCGAT,
     N  RADJGAT,HCPSGAT,TCSGAT, TSFSGAT,DELZ,   DLZWGAT,ZBTWGAT,ISNDGAT,
     O  ILW,    ITC,    ITCG,   ITG,    NA*NTYPE,    1,NML,  JLAT, ICAN,
     P  IGND,   IZREF,  ISLFD,  NLANDCS,NLANDGS,NLANDC, NLANDG, NLANDI)
C
C-----------------------------------------------------------------------
C          * WATER BUDGET CALCULATIONS.
C
          CALL CLASSW  (THLQGAT,THICGAT,TBARGAT,TCANGAT,RCANGAT,SCANGAT,
     1                  ROFGAT, TROFGAT,SNOGAT, TSNOGAT,RHOSGAT,ALBSGAT,
     2                  WSNOGAT,ZPNDGAT,TPNDGAT,GROGAT, TBASGAT,GFLXGAT,
     3                  PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT,QFCFGAT,QFCLGAT,
     4                  QFNGAT, QFGGAT, QFCGAT, HMFCGAT,HMFGGAT,HMFNGAT,
     5                  HTCCGAT,HTCSGAT,HTCGAT, ROFCGAT,ROFNGAT,ROVGGAT,
     6                  WTRSGAT,WTRGGAT,ROFOGAT,ROFSGAT,ROFBGAT,
     7                  TROOGAT,TROSGAT,TROBGAT,QFSGAT,
     8                  TBARC,  TBARG,  TBARCS, TBARGS, THLIQC, THLIQG,
     9                  THICEC, THICEG, HCPC,   HCPG,   RPCPGAT,TRPCGAT,
     A                  SPCPGAT,TSPCGAT,PREGAT, TAGAT,  RHSIGAT,GGEOGAT,
     B                  FC,     FG,     FCS,    FGS,    TPONDC, TPONDG,
     C                  TPNDCS, TPNDGS, EVAPC,  EVAPCG, EVAPG,  EVAPCS,
     D                  EVPCSG, EVAPGS, QFREZC, QFREZG, QMELTC, QMELTG,
     E                  RAICAN, SNOCAN, RAICNS, SNOCNS, FROOT,  FSVF,
     F                  FSVFS,  CWLCAP, CWFCAP, CWLCPS, CWFCPS, TCANO,
     G                  TCANS,  CHCAP,  CHCAPS, CMASSC, CMASCS, ZSNOW,
     H                  GZEROC, GZEROG, GZROCS, GZROGS, G12C,   G12G,
     I                  G12CS,  G12GS,  G23C,   G23G,   G23CS,  G23GS,
     J                  TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS,
     K                  ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TSFSGAT,
     J                  TCTOP,  TCBOT,  ZTHRC,  ZTHRG,  ZTHRCS, ZTHRGS,
     M                  THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT,GRKSGAT,
     N                  THRAGAT,THFCGAT,DRNGAT, HCPSGAT,DELZ,
     O                  DLZWGAT,ZBTWGAT,XSLPGAT,GRKFGAT,WFSFGAT,WFCIGAT,
     P                  ISNDGAT,IWF,    NA*NTYPE,    1,      NML,
     Q                  JLAT,   ICAN,   IGND,   IGND+1, IGND+2,
     R                  NLANDCS,NLANDGS,NLANDC, NLANDG,NLANDI,MANNGAT,
     S                  DDGAT  )
C
C========================================================================
C
      CALL CLASSZ (1,      CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP,
     1             WTVSTP, WTSSTP, WTGSTP,
     2             FSGVGAT,FLGVGAT,HFSCGAT,HEVCGAT,HMFCGAT,HTCCGAT,
     3             FSGSGAT,FLGSGAT,HFSSGAT,HEVSGAT,HMFNGAT,HTCSGAT,
     4             FSGGGAT,FLGGGAT,HFSGGAT,HEVGGAT,HMFGGAT,HTCGAT,
     5             PCFCGAT,PCLCGAT,QFCFGAT,QFCLGAT,ROFCGAT,WTRCGAT,
     6             PCPNGAT,QFNGAT, ROFNGAT,WTRSGAT,PCPGGAT,QFGGAT,
     7             QFCGAT, ROFGAT, WTRGGAT,CMAIGAT,RCANGAT,SCANGAT,
     8             TCANGAT,SNOGAT, WSNOGAT,TSNOGAT,THLQGAT,THICGAT,
     9             HCPSGAT,THPGAT, DLZWGAT,TBARGAT,ZPNDGAT,TPNDGAT,
     A             DELZ,   FCS,    FGS,    FC,     FG,
     B             1,      NML,    NA*NTYPE,    IGND,   N    )
C
C=======================================================================

      CALL CLASSS (TBARROW,THLQROW,THICROW,TPNDROW,ZPNDROW,
     1             TBASROW,ALBSROW,TSNOROW,RHOSROW,SNOROW,
     2             TCANROW,RCANROW,SCANROW,GROROW,TSFSROW,
     3             CDHROW, CDMROW, HFSROW, TFXROW, QEVPROW,
     4             QFSROW, QFXROW, PETROW, GAROW,  EFROW,
     5             GTROW,  QGROW,  TSFROW, ALVSROW,ALIRROW,
     6             CMAIROW,SFCTROW,SFCUROW,SFCVROW,SFCQROW,
     7             FSGVROW,FSGSROW,FSGGROW,FLGVROW,FLGSROW,
     8             FLGGROW,HFSCROW,HFSSROW,HFSGROW,HEVCROW,
     9             HEVSROW,HEVGROW,HMFCROW,HMFNROW,HTCCROW,
     A             HTCSROW,PCFCROW,PCLCROW,PCPNROW,PCPGROW,
     B             QFGROW, QFNROW, QFCLROW,QFCFROW,ROFROW,
     C             ROFOROW,ROFSROW,ROFBROW,TROFROW,TROOROW,
     D             TROSROW,TROBROW,ROFCROW,ROFNROW,ROVGROW,
     E             WTRCROW,WTRSROW,WTRGROW,DRROW,  WTABROW,
     F             ILMOROW,UEROW,  HBLROW, TACROW, QACROW,
     G             HMFGROW,HTCROW, QFCROW, WSNOROW,FSNOROW,
     H             ITCTROW,ILMOS,JLMOS,IWMOS,JWMOS,
     I             NML,NA,NTYPE,NA*NTYPE,IGND,ICAN,ICAN+1,
     J             TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT,
     K             TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT,
     L             TCANGAT,RCANGAT,SCANGAT,GROGAT,TSFSGAT,
     M             CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT,
     N             QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT,
     O             GTGAT,  QGGAT,  TSFGAT, ALVSGAT,ALIRGAT,
     P             CMAIGAT,SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,
     Q             FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT,
     R             FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT,
     S             HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT,
     T             HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT,
     U             QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT,
     V             ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT,
     W             TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT,
     X             WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  WTABGAT,
     Y             ILMOGAT,UEGAT,  HBLGAT, TACGAT, QACGAT,
     Z             HMFGGAT,HTCGAT, QFCGAT, WSNOGAT,FSNOGAT,
     +             ITCTGAT,MANNROW,MANNGAT,DDROW,DDGAT)

c *********************************************************************
c Calculate values for output files and print them out
c *********************************************************************

C
C=======================================================================
C     * WRITE FIELDS FROM CURRENT TIME STEP TO OUTPUT FILES.
      DO I=1,NLTEST
        DO M=1,NMTEST
          IF(FSDOWN(I)>0.0) THEN
            ALTOT=(ALVSROW(I,M)+ALIRROW(I,M))/2.0
          ELSE
            ALTOT=0.0
          ENDIF

          FSSTAR=FSDOWN(I)*(1.0-ALTOT)
          FLSTAR=FDLGRD(I)-SBC*GTROW(I,M)**4
          QH=HFSROW(I,M)
          QE=QEVPROW(I,M)
          BEG=FSSTAR+FLSTAR-QH-QE
          SNOMLT=HMFNROW(I,M)

          IF(RHOSROW(I,M)>0.0) THEN
            ZSN=SNOROW(I,M)/RHOSROW(I,M)
          ELSE
            ZSN=0.0
          ENDIF

          IF(TCANROW(I,M)>0.01) THEN
            TCN=TCANROW(I,M)-TFREZ
          ELSE
            TCN=0.0
          ENDIF

          IF(TSNOROW(I,M)>0.01) THEN
            TSN=TSNOROW(I,M)-TFREZ
          ELSE
            TSN=0.0
          ENDIF

          IF(TPNDROW(I,M)>0.01) THEN
            TPN=TPNDROW(I,M)-TFREZ
          ELSE
            TPN=0.0
          ENDIF

          IF(ILW==1) THEN
            GTOUT=GTROW(I,M)-TFREZ
          ELSE
            GTOUT=0.0
          ENDIF

      I_OUT=0
      DO K=1, WF_NUM_POINTS
        IF(I==N_OUT(K).AND.M==II_OUT(k)) THEN
        ! figure out nlmos and mlmos of grid square I
          DO N=1, NML
            IF(ILMOS(N)==N_OUT(K).AND.JLMOS(N)==II_OUT(K)) THEN
              I_OUT=N
            ENDIF
	    ENDDO

          IF(I_OUT==0) THEN
            PRINT *,'In the input file there the following'
            PRINT *, 'grid square', i, ' has no area in land class', m
            PRINT *,'Please adjust the MESH_input_run_options file,
     *        as a guide here'
            PRINT *,'are the land class fractions for that square:'
            DO N=1, NMTEST
              PRINT *, 'land class ',n,' has an area of:',ACLASS(i,n)
            ENDDO
	      STOP
          ENDIF


          WRITE(150+k*10+4,'((I2,","),(I3,","),(I5,","),(I6,","),
     +                   9(F8.2,","),2(F7.3,","),(E11.3,","),(F8.2,","),
     +                   (F12.4,","))') 
     +                   IHOUR,IMIN,IDAY,IYEAR,FSSTAR,FLSTAR,QH,
     1                   QE,SNOMLT,BEG,GTOUT,SNOROW(I,M),RHOSROW(I,M),
     2                   WSNOROW(I,M),ALTOT,ROFROW(I,M),
     3                   TPN,ZPNDROW(I,M)
          WRITE(150+k*10+5,'((I2,","),(I3,","),(I5,","),(I6,","),
     +                   3(F7.2,",",2(F6.3,",")),(F8.2,","),2(F8.4,","),
     +                   (F8.2,","),(F8.3,","))')
     +                   IHOUR,IMIN,IDAY,IYEAR,
     1                   (TBARROW(I,M,J)-TFREZ,THLQROW(I,M,J),
     2                   THICROW(I,M,J),J=1,IGND),TCN,RCANROW(I,M),
     3                   SCANROW(I,M),TSN,ZSN
          WRITE(150+k*10+6,'((I2,",")(I3,",")(I5,",")2(F10.2,",")
     +                   (F12.6,",")(F10.2,",")(F8.2,",")(F10.2,",")
     +                   (F15.9,","))')
     +                   IHOUR,IMIN,IDAY,FSDOWN(I),FDLGRD(I),
     1                   PREGRD(I),TAGRD(I)-TFREZ,UVGRD(I),PRESGRD(I),
     2                   QAGRD(I)
          WRITE(150+k*10+7,'(12(E11.4,","))')
     +                   TROFROW(I,M),TROOROW(I,M),TROSROW(I,M),
     1                   TROBROW(I,M),ROFROW(I,M),ROFOROW(I,M),
     2                   ROFSROW(I,M),ROFBROW(I,M),
     3                   FCS(I),FGS(I),FC(I),FG(I)
          WRITE(150+k*10+8,'(22(F10.4,","))')
     +                   FSGVROW(I,M),FSGSROW(I,M),FSGGROW(I,M),
     1                   FLGVROW(I,M),FLGSROW(I,M),FLGGROW(I,M),
     2                   HFSCROW(I,M),HFSSROW(I,M),HFSGROW(I,M),
     3                   HEVCROW(I,M),HEVSROW(I,M),HEVGROW(I,M),
     4                   HMFCROW(I,M),HMFNROW(I,M),
     5                   (HMFGROW(I,M,J),J=1,IGND),
     6                   HTCCROW(I,M),HTCSROW(I,M),
     7                   (HTCROW(I,M,J),J=1,IGND)
          WRITE(150+k*10+9,'(21(E12.4,","))') 
     +                   PCFCROW(I,M),PCLCROW(I,M),PCPNROW(I,M),
     1                   PCPGROW(I,M),QFCFROW(I,M),QFCLROW(I,M),
     2                   QFNROW(I,M),QFGROW(I,M),(QFCROW(I,M,J),
     3                   J=1,IGND),ROFCROW(I,M),ROFNROW(I,M),
     4                   ROFOROW(I,M),ROFROW(I,M),WTRCROW(I,M),
     5                   WTRSROW(I,M),WTRGROW(I,M)

        ENDIF !IF(I==N_OUT(K).AND.M==II_OUT(k)) THEN
      ENDDO !DO K=1, WF_NUM_POINTS
      ENDDO !DO M=1,NMTEST
      ENDDO !DO I=1,NLTEST
C Write ENSIM output
c-----------------------------------------------------c
c
      !TODO: Add code to handle leap years
      IF(ensim_ios==0)THEN
        !calculate month/day
        if (iday < 32) then
          ensim_month = 1
          ensim_day = iday
        elseif (iday < 60) then
          ensim_month = 2
          ensim_day = iday - 31
        elseif (iday < 91) then
          ensim_month = 3
          ensim_day = iday - 59
        elseif (iday < 121) then
          ensim_month = 4
          ensim_day = iday - 90
        elseif (iday < 152) then
          ensim_month = 5
          ensim_day = iday - 120
        elseif (iday < 182) then
          ensim_month = 6
          ensim_day = iday - 151
        elseif (iday < 213) then
          ensim_month = 7
          ensim_day = iday - 181
        elseif (iday < 244) then
          ensim_month = 8
          ensim_day = iday - 212
        elseif (iday < 274) then
          ensim_month = 9
          ensim_day = iday - 243
        elseif (iday < 305) then
          ensim_month = 10
          ensim_day = iday - 273
        elseif (iday < 335) then
          ensim_month = 11
          ensim_day = iday - 304
        else
          ensim_month = 12
          ensim_day = iday - 334
        endif

        CALL ENSIM(NML, NLTEST, NMTEST, NCOUNT, IMIN, ireport,
     1    wfo_seq, IYEAR, ensim_MONTH, ensim_DAY, IHOUR, IMIN, 0,
     2    0, XXX, YYY, YCOUNT, XCOUNT, wfo_pick, M_Y, M_X,
     3    NLAT, NMOS, PREGRD, DELT, TAGRD, TFREZ, FSDOWN, FDLGRD, UVGRD,
     4    PRESGRD, QAGRD, ROFBROW, ROFSROW, ROFOROW, ROFROW, FAREROW,
     5    QFSROW, QEVPROW, HFSROW, SBC, GTROW, ALVSROW,
     6    ALIRROW, FC, FG, FCS, FGS, GZEROC, GZEROG,
      !TODO: check that fsnorow is correct (bjd - Jan 15/08)
     7    GZROCS, GZROGS, SNOROW, ZSNOW, FSNOROW, TSNOROW,
     8    TBARROW, THLQROW, THICROW, RHOW, DELZ,ILMOS,JLMOS, ILG,
     9    CURREC)

      ENDIF
C
C=======================================================================
C     * CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.
C
      DO I=1,NLTEST
          CDHGRD(I)=0.
          CDMGRD(I)=0.
          HFSGRD(I)=0.
          TFXGRD(I)=0.
          QEVPGRD(I)=0.
          QFSGRD(I)=0.
          QFXGRD(I)=0.
          PETGRD(I)=0.
          GAGRD(I)=0.
          EFGRD(I)=0.
          GTGRD(I)=0.
          QGGRD(I)=0.
          TSFGRD(I)=0.
          ALVSGRD(I)=0.
          ALIRGRD(I)=0.
          SFCTGRD(I)=0.
          SFCUGRD(I)=0.
          SFCVGRD(I)=0.
          SFCQGRD(I)=0.
          FSNOGRD(I)=0.
          FSGVGRD(I)=0.
          FSGSGRD(I)=0.
          FSGGGRD(I)=0.
          SNOGRD(I)=0.
          FLGVGRD(I)=0.
          FLGSGRD(I)=0.
          FLGGGRD(I)=0.
          HFSCGRD(I)=0.
          HFSSGRD(I)=0.
          HFSGGRD(I)=0.
          HEVCGRD(I)=0.
          HEVSGRD(I)=0.
          HEVGGRD(I)=0.
          HMFCGRD(I)=0.
          HMFNGRD(I)=0.
          HTCCGRD(I)=0.
          HTCSGRD(I)=0.
          PCFCGRD(I)=0.
          PCLCGRD(I)=0.
          PCPNGRD(I)=0.
          PCPGGRD(I)=0.
          QFGGRD(I)=0.
          QFNGRD(I)=0.
          QFCLGRD(I)=0.
          QFCFGRD(I)=0.
          ROFGRD(I)=0.
          ROFOGRD(I)=0.
          ROFSGRD(I)=0.
          ROFBGRD(I)=0.
          ROFCGRD(I)=0.
          ROFNGRD(I)=0.
          ROVGGRD(I)=0.
          WTRCGRD(I)=0.
          WTRSGRD(I)=0.
          WTRGGRD(I)=0.
          DRGRD(I)=0.
          WTABGRD(I)=0.
          ILMOGRD(I)=0.
          UEGRD(I)=0.
          HBLGRD(I)=0.
          DO J=1,IGND
            HMFGGRD(I,J)=0.
            HTCGRD(I,J)=0.
            QFCGRD(I,J)=0.
          ENDDO
      ENDDO !DO I=1,NLTEST
C
      DO I=1,NLTEST
        DO M=1,NMTEST
          CDHGRD(I)=CDHGRD(I)+CDHROW(I,M)*FAREROW(I,M)
          CDMGRD(I)=CDMGRD(I)+CDMROW(I,M)*FAREROW(I,M)
          HFSGRD(I)=HFSGRD(I)+HFSROW(I,M)*FAREROW(I,M)
          TFXGRD(I)=TFXGRD(I)+TFXROW(I,M)*FAREROW(I,M)
          QEVPGRD(I)=QEVPGRD(I)+QEVPROW(I,M)*FAREROW(I,M)
          QFSGRD(I)=QFSGRD(I)+QFSROW(I,M)*FAREROW(I,M)
          QFXGRD(I)=QFXGRD(I)+QFXROW(I,M)*FAREROW(I,M)
          PETGRD(I)=PETGRD(I)+PETROW(I,M)*FAREROW(I,M)
          GAGRD(I)=GAGRD(I)+GAROW(I,M)*FAREROW(I,M)
          EFGRD(I)=EFGRD(I)+EFROW(I,M)*FAREROW(I,M)
          GTGRD(I)=GTGRD(I)+GTROW(I,M)*FAREROW(I,M)
          QGGRD(I)=QGGRD(I)+QGROW(I,M)*FAREROW(I,M)
          TSFGRD(I)=TSFGRD(I)+TSFROW(I,M)*FAREROW(I,M)
          ALVSGRD(I)=ALVSGRD(I)+ALVSROW(I,M)*FAREROW(I,M)
          ALIRGRD(I)=ALIRGRD(I)+ALIRROW(I,M)*FAREROW(I,M)
          SFCTGRD(I)=SFCTGRD(I)+SFCTROW(I,M)*FAREROW(I,M)
          SFCUGRD(I)=SFCUGRD(I)+SFCUROW(I,M)*FAREROW(I,M)
          SFCVGRD(I)=SFCVGRD(I)+SFCVROW(I,M)*FAREROW(I,M)
          SFCQGRD(I)=SFCQGRD(I)+SFCQROW(I,M)*FAREROW(I,M)
          FSNOGRD(I)=FSNOGRD(I)+FSNOROW(I,M)*FAREROW(I,M)
          FSGVGRD(I)=FSGVGRD(I)+FSGVROW(I,M)*FAREROW(I,M)
          FSGSGRD(I)=FSGSGRD(I)+FSGSROW(I,M)*FAREROW(I,M)
          FSGGGRD(I)=FSGGGRD(I)+FSGGROW(I,M)*FAREROW(I,M)
          SNOGRD(I)=SNOGRD(I)+SNOROW(I,M)*FAREROW(I,M)
          FLGVGRD(I)=FLGVGRD(I)+FLGVROW(I,M)*FAREROW(I,M)
          FLGSGRD(I)=FLGSGRD(I)+FLGSROW(I,M)*FAREROW(I,M)
          FLGGGRD(I)=FLGGGRD(I)+FLGGROW(I,M)*FAREROW(I,M)
          HFSCGRD(I)=HFSCGRD(I)+HFSCROW(I,M)*FAREROW(I,M)
          HFSSGRD(I)=HFSSGRD(I)+HFSSROW(I,M)*FAREROW(I,M)
          HFSGGRD(I)=HFSGGRD(I)+HFSGROW(I,M)*FAREROW(I,M)
          HEVCGRD(I)=HEVCGRD(I)+HEVCROW(I,M)*FAREROW(I,M)
          HEVSGRD(I)=HEVSGRD(I)+HEVSROW(I,M)*FAREROW(I,M)
          HEVGGRD(I)=HEVGGRD(I)+HEVGROW(I,M)*FAREROW(I,M)
          HMFCGRD(I)=HMFCGRD(I)+HMFCROW(I,M)*FAREROW(I,M)
          HMFNGRD(I)=HMFNGRD(I)+HMFNROW(I,M)*FAREROW(I,M)
          HTCCGRD(I)=HTCCGRD(I)+HTCCROW(I,M)*FAREROW(I,M)
          HTCSGRD(I)=HTCSGRD(I)+HTCSROW(I,M)*FAREROW(I,M)
          PCFCGRD(I)=PCFCGRD(I)+PCFCROW(I,M)*FAREROW(I,M)
          PCLCGRD(I)=PCLCGRD(I)+PCLCROW(I,M)*FAREROW(I,M)
          PCPNGRD(I)=PCPNGRD(I)+PCPNROW(I,M)*FAREROW(I,M)
          PCPGGRD(I)=PCPGGRD(I)+PCPGROW(I,M)*FAREROW(I,M)
          QFGGRD(I)=QFGGRD(I)+QFGROW(I,M)*FAREROW(I,M)
          QFNGRD(I)=QFNGRD(I)+QFNROW(I,M)*FAREROW(I,M)
          QFCLGRD(I)=QFCLGRD(I)+QFCLROW(I,M)*FAREROW(I,M)
          QFCFGRD(I)=QFCFGRD(I)+QFCFROW(I,M)*FAREROW(I,M)
          ROFGRD(I)=ROFGRD(I)+ROFROW(I,M)*FAREROW(I,M)
          ROFOGRD(I)=ROFOGRD(I)+ROFOROW(I,M)*FAREROW(I,M)
          ROFSGRD(I)=ROFSGRD(I)+ROFSROW(I,M)*FAREROW(I,M)
          ROFBGRD(I)=ROFBGRD(I)+ROFBROW(I,M)*FAREROW(I,M)
          ROFCGRD(I)=ROFCGRD(I)+ROFCROW(I,M)*FAREROW(I,M)
          ROFNGRD(I)=ROFNGRD(I)+ROFNROW(I,M)*FAREROW(I,M)
          ROVGGRD(I)=ROVGGRD(I)+ROVGROW(I,M)*FAREROW(I,M)
          WTRCGRD(I)=WTRCGRD(I)+WTRCROW(I,M)*FAREROW(I,M)
          WTRSGRD(I)=WTRSGRD(I)+WTRSROW(I,M)*FAREROW(I,M)
          WTRGGRD(I)=WTRGGRD(I)+WTRGROW(I,M)*FAREROW(I,M)
          DRGRD(I)=DRGRD(I)+DRROW(I,M)*FAREROW(I,M)
          WTABGRD(I)=WTABGRD(I)+WTABROW(I,M)*FAREROW(I,M)
          ILMOGRD(I)=ILMOGRD(I)+ILMOROW(I,M)*FAREROW(I,M)
          UEGRD(I)=UEGRD(I)+UEROW(I,M)*FAREROW(I,M)
          HBLGRD(I)=HBLGRD(I)+HBLROW(I,M)*FAREROW(I,M)
          DO J=1,IGND
              HMFGGRD(I,J)=HMFGGRD(I,J)+HMFGROW(I,M,J)*FAREROW(I,M)
              HTCGRD(I,J)=HTCGRD(I,J)+HTCROW(I,M,J)*FAREROW(I,M)
              QFCGRD(I,J)=QFCGRD(I,J)+QFCROW(I,M,J)*FAREROW(I,M)
          ENDDO
        ENDDO !DO M=1,NMTEST
        
C     * CALCULATE AVERAGES FOR WATROUTE INTPUT FILES
CDAN  * VALUES ARE ONLY RESET ON THE HOUR AND ARE CUMULATIVE ON THE 
CDAN  * HALF-HOUR; STAND-ALONE RTE.EXE (WATROUTE) READS HOURLY DATA
CDAN  OUTPUT VALUES ARE MULTIPLIED BY DELT TO CONVERT THEM FROM 
CDAN  [kg m-2 s-1] TO [mm] (MAR 20/08)
        IF (MOD (REAL (NCOUNT), 2.0) .NE. 0.0) THEN !HOURLY TIME STEP
            RUNOFF(YYY(I), XXX(I)) = (ROFOGRD(I) + ROFSGRD(I))*DELT
            RECHARGE(YYY(I), XXX(I)) = ROFBGRD(I)*DELT
CDAN            LEAKAGE(YYY(I), XXX(I)) = 0.0*DELT
        ELSE !CUMULATIVE HALF-HOURLY TIME STEP
            RUNOFF(YYY(I), XXX(I)) = RUNOFF(YYY(I), XXX(I)) + 
     1          (ROFOGRD(I) + ROFSGRD(I))*DELT
            RECHARGE(YYY(I), XXX(I)) = RECHARGE(YYY(I), XXX(I)) + 
     1          ROFBGRD(I)*DELT
CDAN            LEAKAGE(YYY(I), XXX(I) = LEAKAGE(YYY(I), XXX(I)) + 0.0*DELT
        END IF
      ENDDO !DO I=1,NLTEST


C=======================================================================
C     * WRITE WATROUTE INPUT FILES
CDAN  * FILES ARE ONLY WRITTEN ON THE HOUR (WATROUTE READS HOURLY DATA).
CDAN  * HOURLY TIME STEPS ARE ODD-NUMBERED INTEGERS.

      IF (MOD (REAL (NCOUNT), 2.0) .EQ. 0.0) THEN !HOURLY TIME STEP
        YEAR1 = IYEAR
        CALL FIND_MONTH (IDAY, IYEAR, MONTH_NOW)
        CALL FIND_DAY (IDAY, IYEAR, DAY_NOW)
        HOUR_NOW = IHOUR + 1 !ROUTING USES 1-24 RANGE, MESH USES 0-23

        IF (MODELFLG.EQ."i" .OR. MODELFLG.EQ."r" .OR. MODELFLG.EQ."l") 
     1      THEN !WRITE RUNOFF DATA
            OUTARRAY = RUNOFF !PASS RUNOFF TO OUTARRAY IN WRITE_R2C
            CALL WRITE_R2C(261, 31, NO_FRAMES, 1, FRAME_NO, 1, 8)
        END IF

        IF (MODELFLG .EQ. "r") THEN !WRITE RECHARGE DATA
            OUTARRAY = RECHARGE !PASS RUNOFF TO OUTARRAY IN WRITE_R2C
            CALL WRITE_R2C(262, 32, NO_FRAMES, 1, FRAME_NO, 1, 8)
        END IF

        FRAME_NO = FRAME_NO + 1 !UPDATE COUNTERS
        NO_FRAMES = FRAME_NO + 1
      END IF !(MOD (REAL (NCOUNT), 2.0) .EQ. 0.0)        
        

C calculate and write the basin avg SCA similar to watclass3.0f5
C Same code than in wf_ensim.f subrutine of watclass3.0f8
C Especially for version MESH_Prototype 3.3.1.7b (not to be incorporated in future versions)
C calculate and write the basin avg SWE using the similar fudge factor!!!

      IF (BASIN_FRACTION(1) == -1) THEN
        DO I = 1, NLTEST ! nltest = number of grid squares
c         BASIN_FRACTION is the basin snow cover
c         (portions of the grids outside the basin are not included)
c         for a given day - IDAY in the if statement
          BASIN_FRACTION(I) = FRAC(I)
          !TODO: WF_FRAC is not actually the fraction of the grid square
          !within the basin, we should be using some other value, but I'm
          !not sure what.
        ENDDO
      ENDIF

      IF((IHOUR==12).AND.(IMIN==0))  THEN

          basin_SCA = 0.0
          basin_SWE = 0.0

          do I=1,NLTEST
             if(BASIN_FRACTION(I)/=0.0) then
                basin_SCA = basin_SCA + FSNOGRD(I)/BASIN_FRACTION(I)
                basin_SWE = basin_SWE + SNOGRD(I)/BASIN_FRACTION(I)
             endif
          enddo

         basin_SCA = basin_SCA/NLTEST
         basin_SWE = basin_SWE/NLTEST

      ENDIF


      IF ((IHOUR==12).AND.(IMIN==0))  THEN
        WRITE(85,'(I5, ",", F10.3)') IDAY, basin_SCA
        WRITE(86,'(I5, ",", F10.3)') IDAY, basin_SWE
      ENDIF

C
C=======================================================================
C     * ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.

      DO I=1,NLTEST
        DO M=1,NMTEST
          PREACC(I)=PREACC(I)+PREGRD(I)*FAREROW(I,M)*DELT
          GTACC(I)=GTACC(I)+GTROW(I,M)*FAREROW(I,M)
          QEVPACC(I)=QEVPACC(I)+QEVPROW(I,M)*FAREROW(I,M)
          EVAPACC(I)=EVAPACC(I)+QFSROW(I,M)*FAREROW(I,M)*DELT
          HFSACC(I)=HFSACC(I)+HFSROW(I,M)*FAREROW(I,M)
          HMFNACC(I)=HMFNACC(I)+HMFNROW(I,M)*FAREROW(I,M)
          ROFACC(I)=ROFACC(I)+ROFROW(I,M)*FAREROW(I,M)*DELT
          ROFOACC(I)=ROFOACC(I)+ROFOROW(I,M)*FAREROW(I,M)*DELT
          ROFSACC(I)=ROFSACC(I)+ROFSROW(I,M)*FAREROW(I,M)*DELT
          ROFBACC(I)=ROFBACC(I)+ROFBROW(I,M)*FAREROW(I,M)*DELT
          WTBLACC(I)=WTBLACC(I)+WTABROW(I,M)*FAREROW(I,M)
          DO J=1,IGND
            TBARACC(I,J)=TBARACC(I,J)+TBARROW(I,M,J)*FAREROW(I,M)
            THLQACC(I,J)=THLQACC(I,J)+THLQROW(I,M,J)*FAREROW(I,M)
            THICACC(I,J)=THICACC(I,J)+THICROW(I,M,J)*FAREROW(I,M)
            THALACC(I,J)=THALACC(I,J)+(THLQROW(I,M,J)+THICROW(I,M,J))
     1                  *FAREROW(I,M)
          ENDDO
          ALVSACC(I)=ALVSACC(I)+ALVSROW(I,M)*FAREROW(I,M)*FSVHGRD(I)
          ALIRACC(I)=ALIRACC(I)+ALIRROW(I,M)*FAREROW(I,M)*FSIHGRD(I)
          IF(SNOROW(I,M)>0.0) THEN
            RHOSACC(I)=RHOSACC(I)+RHOSROW(I,M)*FAREROW(I,M)
            TSNOACC(I)=TSNOACC(I)+TSNOROW(I,M)*FAREROW(I,M)
            WSNOACC(I)=WSNOACC(I)+WSNOROW(I,M)*FAREROW(I,M)
            SNOARE(I)=SNOARE(I)+FAREROW(I,M)
          ENDIF
          IF(TCANROW(I,M)>0.5) THEN
            TCANACC(I)=TCANACC(I)+TCANROW(I,M)*FAREROW(I,M)
            CANARE(I)=CANARE(I)+FAREROW(I,M)
          ENDIF
          SNOACC(I)=SNOACC(I)+SNOROW(I,M)*FAREROW(I,M)
          RCANACC(I)=RCANACC(I)+RCANROW(I,M)*FAREROW(I,M)
          SCANACC(I)=SCANACC(I)+SCANROW(I,M)*FAREROW(I,M)
          GROACC(I)=GROACC(I)+GROROW(I,M)*FAREROW(I,M)
          FSINACC(I)=FSINACC(I)+FSDOWN(I)*FAREROW(I,M)
          FLINACC(I)=FLINACC(I)+FDLGRD(I)*FAREROW(I,M)
          FLUTACC(I)=FLUTACC(I)+SBC*GTROW(I,M)**4*FAREROW(I,M)
          TAACC(I)=TAACC(I)+TAGRD(I)*FAREROW(I,M)
          UVACC(I)=UVACC(I)+UVGRD(I)*FAREROW(I,M)
          PRESACC(I)=PRESACC(I)+PRESGRD(I)*FAREROW(I,M)
          QAACC(I)=QAACC(I)+QAGRD(I)*FAREROW(I,M)
        ENDDO !DO M=1,NMTEST
      ENDDO !DO I=1,NLTEST
C
C     * CALCULATE AND PRINT DAILY AVERAGES.
C
      IF(NCOUNT==48) THEN !48 is the last half-hour period of the day
                            ! when they're numbered 1-48

      DO 800 I=1,NLTEST
          PREACC(I)=PREACC(I)
          GTACC(I)=GTACC(I)/REAL(NSUM)
          QEVPACC(I)=QEVPACC(I)/REAL(NSUM)
          EVAPACC(I)=EVAPACC(I)
          HFSACC(I)=HFSACC(I)/REAL(NSUM)
          HMFNACC(I)=HMFNACC(I)/REAL(NSUM)
          ROFACC(I)=ROFACC(I)
          ROFOACC(I)=ROFOACC(I)
          ROFSACC(I)=ROFSACC(I)
          ROFBACC(I)=ROFBACC(I)
          WTBLACC(I)=WTBLACC(I)/REAL(NSUM)

          DO J=1,IGND
            TBARACC(I,J)=TBARACC(I,J)/REAL(NSUM)
            THLQACC(I,J)=THLQACC(I,J)/REAL(NSUM)
            THICACC(I,J)=THICACC(I,J)/REAL(NSUM)
            THALACC(I,J)=THALACC(I,J)/REAL(NSUM)
          ENDDO

          IF(FSINACC(I)>0.0) THEN
            ALVSACC(I)=ALVSACC(I)/(FSINACC(I)*0.5)
            ALIRACC(I)=ALIRACC(I)/(FSINACC(I)*0.5)
          ELSE
            ALVSACC(I)=0.0
            ALIRACC(I)=0.0
          ENDIF

          IF(SNOARE(I)>0.0) THEN
            RHOSACC(I)=RHOSACC(I)/SNOARE(I)
            TSNOACC(I)=TSNOACC(I)/SNOARE(I)
            WSNOACC(I)=WSNOACC(I)/SNOARE(I)
          ENDIF

          IF(CANARE(I)>0.0) THEN
            TCANACC(I)=TCANACC(I)/CANARE(I)
          ENDIF

          SNOACC(I)=SNOACC(I)/REAL(NSUM)
          RCANACC(I)=RCANACC(I)/REAL(NSUM)
          SCANACC(I)=SCANACC(I)/REAL(NSUM)
          GROACC(I)=GROACC(I)/REAL(NSUM)
          FSINACC(I)=FSINACC(I)/REAL(NSUM)
          FLINACC(I)=FLINACC(I)/REAL(NSUM)
          FLUTACC(I)=FLUTACC(I)/REAL(NSUM)
          TAACC(I)=TAACC(I)/REAL(NSUM)
          UVACC(I)=UVACC(I)/REAL(NSUM)
          PRESACC(I)=PRESACC(I)/REAL(NSUM)
          QAACC(I)=QAACC(I)/REAL(NSUM)

          !ALTOT is the average of the
          ! visible spectrum and infrared spectrum
          ALTOT=(ALVSACC(I)+ALIRACC(I))/2.0
          FSSTAR=FSINACC(I)*(1.-ALTOT)
          FLSTAR=FLINACC(I)-FLUTACC(I)
          QH=HFSACC(I)
          QE=QEVPACC(I)
          BEG=FSSTAR+FLSTAR-QH-QE
          SNOMLT=HMFNACC(I)
          IF(RHOSACC(I)>0.0) THEN
            ZSN=SNOACC(I)/RHOSACC(I)
          ELSE
            ZSN=0.0
          ENDIF

          IF(TCANACC(I)>0.01) THEN !MAGIC NUMBER
            TCN=TCANACC(I)-TFREZ
          ELSE
            TCN=0.0
          ENDIF

          IF(TSNOACC(I)>0.01) THEN ! MAGIC NUMBER
            TSN=TSNOACC(I)-TFREZ
          ELSE
            TSN=0.0
          ENDIF

          IF(ILW==1) THEN
            GTOUT=GTACC(I)-TFREZ
          ELSE
            GTOUT=0.0
          ENDIF

c see if we are at one of the output points
      DO K=1, WF_NUM_POINTS
        IF(I==N_OUT(K)) THEN
c figure out nlmos and mlmos of grid square I
          DO N=1, NML
            IF(ILMOS(N)==N_OUT(K)) THEN
              I_OUT=N
            ENDIF
	    ENDDO

          WRITE(150+k*10+1,'((I4,","),(I5,","),9(F8.2,","),2(F8.3,","),
     +                       (F12.4,","),4(F12.4,","))') 
     +                       IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,SNOMLT,
     1                       BEG,GTOUT,SNOACC(I),RHOSACC(I),
     2                       WSNOACC(I),ALTOT,ROFACC(I),ROFOACC(I),
     3                       ROFSACC(I),ROFBACC(I)
          WRITE(150+k*10+2,'((I4,","),(I5,","),5((F8.2,","),
     +                       2(F6.3,",")),(F8.2,","),2(F7.4,","),
     +                       2(F8.2,","),(E12.5,","))') 
     +                       IDAY,IYEAR,(TBARACC(I,J)-TFREZ,
     1                       THLQACC(I,J),THICACC(I,J),J=1,IGND),
     2                       TCN,RCANACC(I),SCANACC(I),TSN,ZSN
          WRITE(150+k*10+3,'((I4,","),(I5,","),3(F9.2,","),(F8.2,","),
     +                       (F10.2,","),(E12.3,","),2(F12.3,","),
     +                       (F8.3,","))')
     +                       IDAY,IYEAR,FSINACC(I),FLINACC(I),
     1                       TAACC(I)-TFREZ,UVACC(I),PRESACC(I),
     2                       QAACC(I),PREACC(I),EVAPACC(I)

        ENDIF  !IF(I==N_OUT(K)) THEN
      ENDDO  !DO K=1, WF_NUM_POINTS

c update components for final tally
      TOTAL_ROFACC=TOTAL_ROFACC+ROFACC(I)
      TOTAL_ROFOACC=TOTAL_ROFOACC+ROFOACC(I)
      TOTAL_ROFSACC=TOTAL_ROFSACC+ROFSACC(I)
      TOTAL_ROFBACC=TOTAL_ROFBACC+ROFBACC(I)
      TOTAL_EVAPACC=TOTAL_EVAPACC+EVAPACC(I)
      TOTAL_PREACC=TOTAL_PREACC+PREACC(I)
      
      IF (WF_NUM_POINTS > 0) THEN !SUMMARY VALUES FOR SCREEN
        DO J = 1, WF_NUM_POINTS !FOR MORE THAN 1 OUTPUT
          IF (I == N_OUT(J)) THEN
            PRE_OUT(J) = PREACC(I)
            EVAP_OUT(J) = EVAPACC(I)
            ROF_OUT(J) = ROFACC(I)
          END IF
        END DO
      ELSEIF (I == CEILING(REAL(NA) / 2)) THEN !GENERAL CASE
        PRE_OUT(1) = PREACC(I)
        EVAP_OUT(1) = EVAPACC(I)
        ROF_OUT(1) = ROFACC(I)
      END IF

C
C     * RESET ACCUMULATOR ARRAYS.
C
          PREACC(I)=0.
          GTACC(I)=0.
          QEVPACC(I)=0.
          HFSACC(I)=0.
          HMFNACC(I)=0.
          ROFACC(I)=0.
          SNOACC(I)=0.
          CANARE(I)=0.
          SNOARE(I)=0.
          ROFOACC(I)=0.
          ROFSACC(I)=0.
          ROFBACC(I)=0.
          WTBLACC(I)=0.
          DO J=1,IGND
              TBARACC(I,J)=0.
              THLQACC(I,J)=0.
              THICACC(I,J)=0.
              THALACC(I,J)=0.
          ENDDO
          ALVSACC(I)=0.
          ALIRACC(I)=0.
          RHOSACC(I)=0.
          TSNOACC(I)=0.
          WSNOACC(I)=0.
          TCANACC(I)=0.
          RCANACC(I)=0.
          SCANACC(I)=0.
          GROACC(I)=0.
          FSINACC(I)=0.
          FLINACC(I)=0.
          TAACC(I)=0.
          UVACC(I)=0.
          PRESACC(I)=0.
          QAACC(I)=0.
          EVAPACC(I)=0.
          FLUTACC(I)=0.
800   CONTINUE

      ENDIF  ! IF(NCOUNT==48) THEN

      NCOUNT=NCOUNT+1
      NSUM=NSUM+1
      IF(NCOUNT>48) THEN !48 is the last half-hour period of the day
                            ! when they're numbered 1-48
        NCOUNT=1
        NSUM=1
      ENDIF

!c *********************************************************************
!c Call routing routine
!c *********************************************************************


!      CALL WF_ROUTE(WF_ROUTETIMESTEP,WF_R1,WF_R2,
!     A     NA,NAA,NTYPE,YCOUNT,XCOUNT,IYMIN,
!     B     WF_IYMAX,JXMIN,WF_JXMAX,YYY,XXX,WF_IBN,WF_IROUGH,
!     C     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE,
!     D     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE,WF_ELEV,WF_FRAC,
!     E     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX,
!     F     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R,
!     G     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME,
!     H     WF_B1,WF_B2,WF_QREL, WF_QR,
!     I     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2,
!     J     WF_STORE1,WF_STORE2,
!     K     DRIVERTIMESTEP,ROFGRD, NLAT, M_C,M_R,M_S, NLTEST,
!     L     WF_S, JAN,IDAY,IHOUR,IMIN)

!      DO I=1,WF_NO
!        WF_QSYN(I)=WF_QO2(WF_S(I))
!        WF_QHYD_AVG(I)=WF_QHYD(I)
!      ENDDO

c *********************************************************************
c Write measured and simulated streamflow to file and screen
c Also write daily summary (pre, evap, rof)
c *********************************************************************


      IF(NCOUNT==48) THEN !48 is the last half-hour period of the day
                            ! when they're numbered 1-48
c write out the spl.csv file
!        WRITE(70,'(I5,",",F10.3,100(",",F10.3))') IDAY,(WF_QHYD_AVG(I),
!     +    WF_QSYN(I),I=1,WF_NO)
     
        IF (WF_NUM_POINTS .GT. 1) THEN !FOR MORE THAN ONE OUTPUT
          WRITE (6, "(2I5)", ADVANCE="no") IYEAR, IDAY
          DO I = 1, WF_NUM_POINTS
            WRITE(6, "('  'A, T18, 3F10.3)") DIR_OUT(I),
     +        PRE_OUT(I), EVAP_OUT(I), ROF_OUT(I)
            PRE_OUT(I) = 0.0 !RESET ACCUMULATORS
            EVAP_OUT(I) = 0.0
            ROF_OUT = 0.0
          END DO
        ELSE !FOR GENERAL CASE OR SINGLE GRID OUTPUT POINT
          WRITE(6, "(2I5, 3F10.3)") IYEAR, IDAY,
     1      PRE_OUT(1), EVAP_OUT(1), ROF_OUT(1)
          PRE_OUT(1) = 0.0
          EVAP_OUT = 0.0
          ROF_OUT = 0.0
        END IF

c print out spl.csv file to screen
!        WRITE(6,'(F10.3,100(F10.3))') (WF_QHYD_AVG(I), WF_QSYN(I),
!     +    I=1,WF_NO)
      ENDIF

c *********************************************************************
c Update time counters and return to beginning of main loop
c *********************************************************************

      IMIN = IMIN + 30 ! increment the current time by 30 minutes
      IF (IMIN==60) THEN
        IMIN = 0
        IHOUR = IHOUR + 1
        IF (IHOUR==24) THEN
          IHOUR = 0
          IDAY = IDAY + 1
          IF (IDAY >= 366) THEN
            IF (MOD(IYEAR,400) == 0) THEN !LEAP YEAR
              IF (IDAY == 367) THEN
                IDAY = 1
                IYEAR = IYEAR + 1
              ENDIF
            ELSE IF (MOD(IYEAR,100) == 0) THEN !NOT A LEAP YEAR
              IDAY = 1
              IYEAR = IYEAR + 1
            ELSE IF (MOD(IYEAR,4) == 0) THEN !LEAP YEAR
              IF (IDAY == 367) THEN
                IDAY = 1
                IYEAR = IYEAR + 1
              ENDIF
            ELSE !NOT A LEAP YEAR
              IDAY = 1
              IYEAR = IYEAR + 1
            ENDIF
          ENDIF
        ENDIF
      ENDIF

      !check if we should terminate the run yet
      IF (IYEAR >= IYEAR_END .AND. IYEAR_END > 0) THEN
        IF(IYEAR > IYEAR_END) THEN
          GOTO 999
        ELSEIF (IYEAR == IYEAR_END .AND. IDAY >= IDAY_END) THEN
          IF (IDAY > IDAY_END) THEN
            GOTO 999
          ELSEIF (IDAY == IDAY_END .AND. IHOUR >= IHOUR_END) THEN
            IF (IHOUR > IHOUR_END) THEN
              GOTO 999
            ELSEIF (IHOUR == IHOUR_END .AND. IMIN >= IMIN_END) THEN
              GOTO 999
            ENDIF
          ENDIF
        ENDIF
      ENDIF

C=======================================================================
C
      GO TO 200

c *********************************************************************
c Run is now over, print final results to the screen and close files
c *********************************************************************

999   CONTINUE
      PRINT *, 'Reached the end of the forcing data, ',
     +  'MESH_input_forcing.bin'
C Calculate final storage
      FINAL_STORE=0.0
      DO I=1,NLTEST
      DO M=1,NMTEST
		IF(FRAC(I)/=0.0)THEN
          FINAL_STORE=FINAL_STORE+(RCANROW(I,M)+SCANROW(I,M)+SNOROW(I,M)
     1    +(THLQROW(I,M,1)*RHOW+THICROW(I,M,1)*RHOICE)*
     2          DLZWROW(I,M,1)+ZPNDROW(I,M)*RHOW
     3    +(THLQROW(I,M,2)*RHOW+THICROW(I,M,2)*RHOICE)*DLZWROW(I,M,2)
     4    +(THLQROW(I,M,3)*RHOW+THICROW(I,M,3)*RHOICE)*DLZWROW(I,M,3))
     5    *FAREROW(I,M)
		ENDIF
      ENDDO
      ENDDO

c write out final totals to screen
         WRITE(6,*)
         WRITE(6,'(A,F11.3)') '  Total Precipitation         (mm) = ',
     +        TOTAL_PREACC/TOTAL_AREA
         WRITE(6,'(A,F11.3)') '  Total Evaporation           (mm) = ',
     +        TOTAL_EVAPACC/TOTAL_AREA
         WRITE(6,'(A,F11.3)') '  Total Runoff                (mm) = ',
     +        TOTAL_ROFACC/TOTAL_AREA
         WRITE(6,'(A,3F11.3)') '  Storage(Change/Init/Final)  (mm) = ',
     +        (FINAL_STORE-INIT_STORE)/TOTAL_AREA,
     +        INIT_STORE/TOTAL_AREA,
     +        FINAL_STORE/TOTAL_AREA
         WRITE(6,*)
         WRITE(6,'(A,F11.3)') '  Total Overland flow         (mm) = ',
     +        TOTAL_ROFOACC/TOTAL_AREA
         WRITE(6,'(A,F11.3)') '  Total Interflow             (mm) = ',
     +        TOTAL_ROFSACC/TOTAL_AREA
         WRITE(6,'(A,F11.3)') '  Total Baseflow              (mm) = ',
     +        TOTAL_ROFBACC/TOTAL_AREA
         WRITE(6,*)
         WRITE(6,'(A32)') 'Program has terminated normally.'
         WRITE(6,*)
c write out final totals to file
         WRITE(58,*)
         WRITE(58,'(A,F11.3)') '  Total Precipitation         (mm) = ',
     +        TOTAL_PREACC/TOTAL_AREA
         WRITE(58,'(A,F11.3)') '  Total Evaporation           (mm) = ',
     +        TOTAL_EVAPACC/TOTAL_AREA
         WRITE(58,'(A,F11.3)') '  Total Runoff                (mm) = ',
     +        TOTAL_ROFACC/TOTAL_AREA
         WRITE(58,'(A,3F11.3)')'  Storage(Change/Init/Final)  (mm) = ',
     +        (FINAL_STORE-INIT_STORE)/TOTAL_AREA,
     +        INIT_STORE/TOTAL_AREA,
     +        FINAL_STORE/TOTAL_AREA
         WRITE(58,'(A,F11.3)') '  Total Overland flow         (mm) = ',
     +        TOTAL_ROFOACC/TOTAL_AREA
         WRITE(58,'(A,F11.3)') '  Total Interflow             (mm) = ',
     +        TOTAL_ROFSACC/TOTAL_AREA
         WRITE(58,'(A,F11.3)') '  Total Baseflow              (mm) = ',
     +        TOTAL_ROFBACC/TOTAL_AREA
         WRITE(58,*)
         WRITE(58,*)
         WRITE(58,'(A32)') 'Program has terminated normally.'
         WRITE(58,*)

!Diane      CLOSE(UNIT=21)
!      CLOSE(UNIT=22)
      CLOSE(UNIT=51)
      CLOSE(UNIT=58)
      CLOSE(UNIT=70)
      close(unit=85)
      close(unit=86)
      close(unit=90)

      DO I=1, wf_num_points
        CLOSE(UNIT=150+i*10+1)
        CLOSE(UNIT=150+i*10+2)
        CLOSE(UNIT=150+i*10+3)
        CLOSE(UNIT=150+i*10+4)
        CLOSE(UNIT=150+i*10+5)
        CLOSE(UNIT=150+i*10+6)
        CLOSE(UNIT=150+i*10+7)
        CLOSE(UNIT=150+i*10+8)
        CLOSE(UNIT=150+i*10+9)
      ENDDO

      STOP
      END
