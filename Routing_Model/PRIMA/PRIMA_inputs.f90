module PRIMA_inputs

    use main_PRIMA

    contains
    subroutine read_PRIMA_inputs(ascii_data,rain_flag,ncol,nrow,ntot,inactive_cells,&
                              & active_cells,n_rvr_cell,xllcorner,yllcorner,ind_node,&
                              & rvr_cell_ind,mann1,rnk_ind,ind_sur,ind_no_data,dem_lin,wl_lin,time_step,no_data&
                              & ,cell_size,rep_fnam,dir,ini_dep_flag,ras_out,nmesh_grid,ZPNDCLSPRE)
        implicit none
        !integer::ncol,nrow,ntot
        character(len=100):: fnam, dem_file,dir,makedirectory,rep_fnam,trash,ini_water_file
        character(len=200)::ascii_data(6)
        integer::rain_flag,ncol,nrow,ntot,inactive_cells,active_cells,n_rvr_cell,method,ras_out,outflow_cell,outlet_flag
        integer:: isum,j,inode,niter,i,ini_dep_flag,freq_err
        real*8:: xllcorner,yllcorner
        real :: CA_outflow
        integer,allocatable::ind_node(:,:),rvr_cell_ind(:)
        real,allocatable::mann(:)
        integer, allocatable::rnk_ind(:),ind_sur(:,:),ind_no_data(:)
        real*8, allocatable:: dem(:,:),dem_lin(:),wl_lin(:),wdepth(:),wdepth_2d(:,:)
        real:: time_step,no_data,cell_size,error_thr,vol_thr,mann1,errord_thr
        integer nmesh_grid
        real ZPNDCLSPRE(nmesh_grid)

!        common /dims/ncol,nrow,ntot

        fnam='PRIMA_Setup_file.inp'

        open(1, file=fnam,status='old')
        read(1,*) trash
        read(1,*) dem_file
        read(1,*) ini_water_file
        read(1,*) mann1
        !######################### Add Module parameters #########################
        !read(1,*) trash
        !read(1,*) error_thr; error_thr=error_thr/1000.0
        !######################### Drain Module parameters #########################
        !read(1,*) trash
        !read(1,*) errord_thr; errord_thr=errord_thr/1000.0
        !read(1,*) vol_thr;
        !######################### General Configuration Parameters #########################
        !read(1,*) trash
        read(1,*) rain_flag
        !read(1,*) method
        !read(1,*) niter
        !read(1,*) freq_err
        read(1,*) ras_out
        read(1,*) outlet_flag
        close(1)
        !freq_err=minval([freq_err,niter])

        if(len_trim(ini_water_file) >= 4) then
            ini_dep_flag=1
        else
            ini_dep_flag=0
        end if
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !!read dem file
        open(1, file=dem_file,status='old')
        read(1,*)ascii_data(1),ncol
        read(1,*)ascii_data(2),nrow
        read(1,*)ascii_data(3),xllcorner
        read(1,*)ascii_data(4),yllcorner
        read(1,*)ascii_data(5),cell_size
        read(1,*)ascii_data(6),no_data
        allocate(dem(nrow,ncol))
        do i=1,nrow
            read(1,*)dem(i,:)
        end do
        close(1)
        ntot=nrow*ncol; !total number of cells

        if (rain_flag .eq. 0) then  !the time step wont be used to stop running
            time_step=1e30
        else if (rain_flag .eq. 1) then
            time_step=24*60*60
        else if (rain_flag .eq. 2)then
            time_step=60*60
        else if (rain_flag .eq. 3)then
            time_step=30*60
        end if
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !!linear indexing of arrays
        allocate(ind_node(nrow,ncol))
        isum=0
        do j=1,ncol
            do i=1,nrow
                isum=isum+1
                ind_node(i,j)=isum !linear index of the 2d cells
            enddo
        enddo
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !reshape dem to linearized form
        allocate(dem_lin(ntot))

        do j=1,ncol
            do i=1,nrow
                inode=ind_node(i,j)
                dem_lin(inode)=dem(i,j)
            end do
        end do

       !!!!start ranking
        allocate(rnk_ind(ntot)) ! linear_index ranked from higher elevation to lower elevation same loop starts from the first element and ends at the last element

        !read the ranked cells from text file generated by matlab
        write(*,*)'reading rank_ind.txt file'
        open(2,file='CA_rank_ind.txt',status='old')
        do i=1,ntot
            read(2,*)rnk_ind(i)
        end do
        close(2)

        !read inactive (NO_DATA) cells from text file generated by matlab
        write(*,*)'reading no_data_ind.txt file'
        open(2,file='CA_no_data_ind.txt',status='old')
        read(2,*)inactive_cells
        active_cells=ntot-inactive_cells
        allocate(ind_no_data(inactive_cells))
        do i=1,inactive_cells
            read(2,*)ind_no_data(i)
        end do
        close(2)
        !active_cells=ntot-inactive_cells
        write(*,*) 'no of active cells=',active_cells
        write(*,*) 'no of No_DATA cells=',inactive_cells

        if (outlet_flag .eq. 1) then
        !read river cells index from text file generated by matlab
            write(*,*)'reading river_ind.txt file'
            open(2,file='CA_river_ind.txt',status='old')
            read(2,*)n_rvr_cell
            allocate(rvr_cell_ind(n_rvr_cell))
            do i=1,n_rvr_cell
                read(2,*)rvr_cell_ind(i)
            end do
            close(2)
        else
            allocate(rvr_cell_ind(1))
            !get the lowest cell within the DEM
            rvr_cell_ind=minloc(abs(dem_lin))
        end if
        !!!!!initialize variables
        allocate(mann(ntot),wl_lin(ntot)) !vel(ntot),dt(ntot),wdepth(ntot)

        mann=mann1; !manning's coefficient is assumed to be uniform over the DEM. It is possible to make it variable as this value is assigned to an array
        !that has the same dimensions as the DEM, but this will be investigated  later

        if(ini_dep_flag .eq. 0)then !if there a raster depth file that has the initial depth over each grid cell
            !if there is no water depth available, add the ponded depth from the CLASS.ini file
            wl_lin=dem_lin+(ZPNDCLSPRE(1)/1000.0) !water level in each grid cell, ZPNDCLSPRE(1) based on one grid cell in MESH, will be changed later
        else
            allocate(wdepth(ntot),wdepth_2d(nrow,ncol))
            !read initial water depth
            open(1,file=ini_water_file,status='old')
            do i=1,6
                read(1,*)trash
            end do

            do i=1,nrow
                read(1,*)wdepth_2d(i,:)
            end do
            close(1)

            do j=1,ncol
                do i=1,nrow
                    inode=ind_node(i,j)
                    wdepth(inode)=wdepth_2d(i,j)
                end do
            end do


            !if the initial water depth is available
            wl_lin=dem_lin+wdepth !water level in each grid cell
            wl_lin(ind_no_data)=no_data
        end if

        !get index surrounding 8 (index of the 8 surrounding cells)
        allocate(ind_sur(ntot,10))
        !array ind_sur columns: cell_linear id of current cell, no_of surrounding cells, surrounding cells linear_id as (1S,2SE,3E,4NE,5N,6NW,7W,8SW) S: south, N: north, etc.
        call neighbor_cells8(ind_node,dem_lin,ind_sur,no_data)

        CA_outflow=0 !initial outflow volume



        !write the CA output file
        dir='PRIMA_output'
        !makedirectory = 'mkdir ' // trim(dir)
        !call system(makedirectory) ! the PRIMA_balance.csv will be written in the results of the MESH model
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !write(*,*)'Running PRIMA algorithm'
        !!write detailed output
        rep_fnam=trim(dir)// '/' // 'PRIMA_report.txt'
        ! open(2,file=TRIM(ADJUSTL(rep_fnam)),status='unknown') !create report empty file
        ! write(2,*)'PRIMA report © Mohamed I. Ahmed 2019'
        ! if (method .eq. 1)then
            ! write(2,*)'Method: Add/subtract water'
        ! elseif (method .eq. 2)then
            ! write(2,*)'Method: Drain water'
        ! elseif (method .eq. 3)then
            ! write(2,*)'Method: Add then Drain water'
        ! elseif (method .eq. 4)then
            ! write(2,*)'Method: Add and Drain water at the same time'
        ! end if

        ! if (method .ne. 2) write(2,*)'Add Elevation tolerance ', error_thr*1000,' mm'

        ! if(method .ne. 1) then
            ! write(2,*)'Drain Elevation tolerance ', errord_thr*1000,' mm'
            ! write(2,*)'Volume tolerance ', vol_thr, ' m3'
        ! end if
        ! if (rain_flag .eq. 0) then
            ! write(2,*)'Time step (not specified)'
        ! elseif (rain_flag .eq. 1) then
            ! write(2,*)'Time step (day)'
        ! else
            ! write(2,*)'Time step (hr)'
        ! end if

        ! write(2,*)'Max # iterations ',niter,' and error is calculated every ',freq_err

        ! if(ini_dep_flag .eq. 1) write(2,*) 'Initial water depth (asc) file is used: ',ini_water_file

        ! write(2,*) "Running the PRIMA algorithm"

        ! if(method .eq. 1)then
            ! write(2,*) 'event/day   # Iteration     max dep diff        travel time'
            ! write(2,*) '                                (m)                  (s)   '

            ! write(*,*) 'event/day   # Iteration     max dep diff        travel time'
            ! write(*,*) '                                (m)                  (s)   '
        ! else
            ! write(2,*) 'event/day   # Iteration     max dep diff       volume diff   travel time'
            ! write(2,*) '                                 (m)                (m3)          (s)  '

            write(*,*) 'year    day   # Iteration     max dep change       volume change   travel time'
            write(*,*) '                                    (m)                (m3)           (s)  '
        ! end if


        ! close(2)


    return
    end subroutine read_PRIMA_inputs



end module PRIMA_inputs
