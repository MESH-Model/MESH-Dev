General programming rules 1-3  GENERAL PROGRAMMING RULES 
 ******************************
 (Thanks to Craig Burley for the excellent comments)


 Programming rules are an attempt summarize the programming experience 
 of programmers, and the theoretical considerations raised by computer
 scientists. Some programming rules apply to all programming language, 
 they stem from general principles like:

 A) Modern computers are very powerful, memory became relatively
    cheap, and modern compilers automatically optimize code better
    than the average programmer.

    So, saving memory or CPU time is no longer of prime importance:
    what is important is creating programs that are easy to VALIDATE 
    (check that the results are correct) and MAINTAIN (change to suit 
    different future needs).

 B) The building units of program code, procedures and functions, 
    should be made as GENERAL (suitable for many similar applications) 
    and FLEXIBLE (able to handle different types of input and computing 
    requirements) as possible. 

    This principle promotes CODE REUSABILITY (using parts of old programs 
    in new ones), and also helps improve coding since programs that don't 
    rely on special assumptions tend to be more reliable.

 C) Programs should have a well organized internal structure.
    The MODULARITY PROGRAMMING PARADIGM requires partitioning every program 
    into relatively small units, each performing a well defined task. 

    The interaction between code units can be described by a PROCEDURE 
    CALLING TREE, the calling tree makes clear also the internal structure 
    of the program.
    
    A subprogram call has a performance cost, so sometimes you don't 
    partition the program to many subprograms but just arrange it in 
    well defined blocks, optimizing compilers does such things 
    automatically (procedure inlining).

    (Some new programming paradigms like OBJECT ORIENTED PROGRAMMING 
    and VISUAL PROGRAMMING are not yet supported directly by the current 
    Fortran languages and dialects. It seems that implementing these 
    paradigms degrade performance.)

 D) Programs should be fully documented. Documentation
    consists of:

       1) Self-explaining names for variables, procedures etc.

       2) Short comments explaining the algorithms used,
          variables' roles and computation steps 

       3) Program header containing: A general description,
          bugs and problems, planned improvements, copyright 
          and redistribution information

       4) Procedure headers similar to the program header

       5) A text file explaining how to compile, link, install 
          and use the program (and/or a Makefile).

 E) Programs should be portable. To achieve this goal you 
    should:

       1) Strictly adhere to the FORTRAN STANDARD
       2) Avoid using operating system routines
       3) Avoid using any processor dependent features

    Languages standards are technical specifications describing a 
    programming language in detail. Compiler writers check their 
    compilers against the standard, and so ensure that a program that 
    compiled correctly on one standard conforming compiler will compile 
    correctly on another such compiler.

    The problem is that most compilers offer nice LANGUAGE EXTENSIONS, 
    that sometimes are quite tempting to use, and may even be included 
    in future revisions of the standard. However, if you use language 
    extensions, your program might not compile on other machines without 
    some rewriting, and so might be less useful.

 F) A program source is really just a text file; as such it can 
    and should be as READABLE and EASY TO EDIT as possible. 

    Readable programs are easier to maintain and validate.

    In the chapter on program layout we will try to set some 
    FORTRAN guidelines and give some useful references.

 G) A program should not depend on assumptions about the correctness 
    of user's input, guesses about expected data etc, this is called 
    DEFENSIVE PROGRAMMING. 

    Make your program check user's input and key computation results, 
    if wrong, try to recover - go back to the last trusted point, or 
    just give a detailed message and abort the program.

 H) It is very important to carefully select appropriate algorithms.

  +------------------------------------------------------+
  |                                                      |
  |     SUMMARY OF PROGRAMMING RULES                     |
  |     ----------------------------                     |
  |     a) Clarity is more important than efficiency     |
  |     b) Generalize your code                          |
  |     c) Write modular programs                        |
  |     d) Document your program                         |
  |     e) Write standard FORTRAN                        |
  |     f) Improve your layout                           |
  |     g) Program defensively                           |
  |     h) Use appropriate algorithms                    |
  |                                                      |
  +------------------------------------------------------+

Return to contents page 




