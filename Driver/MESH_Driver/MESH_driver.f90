PROGRAM RUNMESH

!>       MESH DRIVER
!>
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.

USE AREA_WATFLOOD
USE EF_MODULE
USE MESH_INPUT_MODULE
USE FLAGS
IMPLICIT NONE

!> DAN  USE RTE SUBROUTINES FOR READING EVENT FILE AND SHD FILE, AND
!> DAN  WRITING R2C-FORMAT OUTPUT FILES      

!>  INTEGER CONSTANTS.
INTEGER ILG
INTEGER,PARAMETER :: ICAN=4, IGND=6, ICP1=ICAN+1
INTEGER,PARAMETER :: M_S=140, M_R=7, M_C=5
!todo M_s should be allocatable. it should not be constant
!todo it should be read in from the shd file

!> WATERSHED RELATED VARIABLES
INTEGER LATDEGMIN,LATMINMIN,LATDEGMAX,LATMINMAX,LONDEGMIN, &
     LONMINMIN,LONDEGMAX,LONMINMAX
INTEGER WF_IYMAX,WF_JXMAX
!> note, there are more watershed related variables declared in mesh_input_module.f

REAL*8 :: LATLENGTH, LONGLENGTH
REAL*8 WF_AL
REAL WF_LAND_MAX, WF_LAND_SUM
INTEGER WF_LAND_COUNT

!> IOSTAT VARIABLE
INTEGER IOS, IOS_EVT

!> FOR OUTPUT
CHARACTER*10 GENDIR_OUT

!todo clean up commets and arrange variables a bit better

!> These variables are used to keep track of the number of forcing files
!> that are in different formats
INTEGER NUM_CSV, NUM_R2C, CURGRU

!> SCA variables

!todo clean up comments and make sure the variables
!todo are in groups that make sense
REAL basin_SCA
REAL basin_SWE
!> STREAMFLOW VARIABLES
!* WF_GAGE: GAUGE IDENTIFIER (8 CHARACTER STRING)
!* WF_NO: NUMBER OF STREAMFLOW GAUGES
!* WF_NL: NUMBER OF DATA POINTS
!* WF_MHRD: NUMBER OF HOURS OF DATA PER MONTH
!* WF_KT: HOURLY INCREMENT FOR STREAMFLOW INPUT (24 = DAILY)
!* WF_IY: Y-DIRECTION GAUGE CO-ORDINATE (UTM OR LATLONG)
!* WF_JX: X-DIRECTION GAUGE CO-ORDINATE (UTM OR LATLONG)
!* WF_S: GAUGE'S PARENT GRID SQUARE
!* WF_QHYD: STREAMFLOW VALUE (_AVG = DAILY AVERAGE)
!* WF_QSYN: SIMULATED STREAFLOW VALUE (_AVG = DAILY AVERAGE)
!* WF_START_YEAR OBSERVED STREAMFLOW START YEAR
!* WF_START_DAY OBSERVED STREAMFLOW START DAY
!* WF_START_HOUR OBSERVED STREAMFLOW START HOUR
INTEGER WF_NO, WF_NL, WF_MHRD, WF_KT, WF_START_YEAR, &
        WF_START_DAY,WF_START_HOUR
INTEGER WF_IY(M_S),WF_JX(M_S), WF_S(M_S)
REAL WF_QHYD(M_S),WF_QHYD_AVG(M_S),WF_QSYN(M_S),WF_QSYN_AVG(M_S)
CHARACTER WF_GAGE(M_S)*8

!> RESERVOIR VARIABLES
	INTEGER WF_IRES(M_R), WF_JRES(M_R), WF_RES(M_R), WF_R(M_R)
	REAL WF_B1(M_R),WF_B2(M_R),WF_QREL(M_R), WF_RESSTORE(M_R)
	CHARACTER WF_RESNAME(M_R)*8

!> FOR BASEFLOW INITIALIZATION
INTEGER JAN

!>     FOR ROUTING
!* WF_R1: MANNING'S N FOR RIVER CHANNEL
!* WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
!* WF_QO2: SIMULATED STREAMFLOW VALUE
REAL WF_R1(M_C), WF_R2(M_C)
REAL, DIMENSION(:), ALLOCATABLE :: WF_NHYD, WF_QBASE, WF_QI2, &
  WF_QO1, WF_QO2, WF_QR, WF_STORE1, WF_STORE2, WF_QI1

! Saul=======
!* IYEAR_START: Initial year for data at the bin file
!* IDAY_START : Initial day for data at the bin file
!* IHOUR_START: Initial hour for data at the bin file
!* IMIN_START : Initial minute for data at the bin file
!* ISTEP_START: Time step; 1:hour, 2:half of hour
!* toskip   : The number of variables in the file per timestep
!* HOURLY_START_*: Start day/year for recording hourly averaged data
!* HOURLY_STOP_*: Stop day/year for recording hourly averaged data
!* DAILY_START_*: Start day/year for recording daily averaged data
!* DAILY_STOP_*: Stop day/year for recording daily averaged data
INTEGER IHOUR_START,IMIN_START,IDAY_START,IMON_START,IYEAR_START,&
               ISTEP_START
INTEGER IHOUR_END,IMIN_END,IDAY_END,IYEAR_END
INTEGER nyy,ndy,nmy,nhy,nrs,toskip
INTEGER HOURLY_START_DAY, HOURLY_STOP_DAY, DAILY_START_DAY, &
           DAILY_STOP_DAY
INTEGER HOURLY_START_YEAR, HOURLY_STOP_YEAR, DAILY_START_YEAR, &
           DAILY_STOP_YEAR
INTEGER JDAY_IND_STRM,JDAY_IND1,JDAY_IND2,JDAY_IND3,JDAY_IND_MET		   
!*******************************************************************************


!> LAND SURFACE DIAGNOSTIC VARIABLES.

REAL, DIMENSION(:), ALLOCATABLE :: SNOGRD

!>==========
!>
!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
CHARACTER*10 wf_landclassname(10)
INTEGER*4 wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss, &
                   wfo_ms,nj, ensim_month, ensim_day
INTEGER*4 WFO_SEQ, ENSIM_IOS
INTEGER*4 CURREC
!> End of ENSIM Changes 
!>== ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

!>  CONSTANTS AND TEMPORARY VARIABLES.
REAL DEGLAT,DEGLON,FSDOWN1,FSDOWN2,FSDOWN3,RDAY, &
     DECL,HOUR,COSZ, &
     ALTOT,FSSTAR,FLSTAR,QH,QE,BEG,SNOMLT,ZSN,TCN,TSN,TPN,GTOUT
INTEGER JLAT

REAL, DIMENSION(:), ALLOCATABLE :: FSDOWN,FSDOWNPRE,FSDOWNPST


!> *************************************************************
!> For reading in options information from MESH_run_options.ini
!> *************************************************************
CHARACTER(20) :: IRONAME
INTEGER       :: IROVAL

!> *******************************************************************
!> For reading in the last information in mesh_paramters_hydrology.ini
!> *******************************************************************
CHARACTER(30) :: NMTESTFORMAT

!>=======================================================================
!>     * DIMENSION STATEMENTS

!> FIRST SET OF DEFINITIONS:

!> BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!> VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!> THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!> MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!> "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!> A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!> ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!> GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!> DIAGNOSTIC VARIABLES.

!> THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!> REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!> LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!> NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!> SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!> ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!> NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!> VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!> DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!> THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!> "ROW" VARIABLES.

!>     * CONSTANTS (PARAMETER DEFINITIONS):

!* NA: MAXIMUM ALLOWABLE NUMBER OF GRID SQUARES
!* NTYPE: MAXIMUM ALLOWABLE NUMBER OF GRUS
!* ILG: MAXIMUM ALLOWABLE SINGLE-DIMENSION ARRAY LENGTH
!* ICAN: MAXIMUM ALLOWABLE NUMBER OF LAND COVER TYPES
!* ICP1: MAXIMUM ALLOWABLE NUMBER OF LAND COVER TYPES INCLUDING
!*       URBAN AREAS
!* IGND: MAXIMUM ALLOWABLE NUMBER OF SOIL LAYERS
!* M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
!* M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
!* M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
!* M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
!* M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
!* M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS

!> DAN  * VERSION: MESH_DRIVER VERSION
!> DAN  * RELEASE: PROGRAM RELEASE VERSIONS
!> ANDY * VER_OK: IF INPUT FILES ARE CORRECT VERSION FOR PROGRAM
!> ANDY *    INTEGER, PARAMETER :: M_G = 5
CHARACTER :: VERSION*24 = "driver_04-20-2009"
CHARACTER*8 :: RELEASE(10)
LOGICAL :: VER_OK
!>
!>*******************************************************************
!>
!> OPERATIONAL VARIABLES:

!* IOS: IOSTAT (ERROR) RETURN ON READ EXTERNAL FILE
!* IY: Y-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* JX: X-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* NN: GRID SQUARE, USED TO READ DRAINAGE DATABASE
!* II: GRU, USED TO READ DRAINAGE DATABASE
!* JAN: IS USED TO INITIALISE BASEFLOW (WHEN JAN = 1)
!* N: COUNTER USED BY CLASS
!* NCOUNT: HALF-HOURLY BASED TIME STEP (200 LOOP)
!* NSUM: NUMBER OF ITERATIONS, TIME STEPS PASSED (200 LOOP)
!* I: COUNTER
!* J: COUNTER
!* K: COUNTER
!* L: COUNTER
!* M: COUNTER
!* CONFLAGS: NUMBER OF CONTROL FLAGS
!* OPTFLAGS: NUMBER OF OPTFLAGS
!* INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
!* DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
!* PAS: STAT (ERROR) RETURN ON ALLOCATE VARIABLE
!* OPN: OPENED RETURN ON INQUIRE STATEMENT (USED TO CHECK IF AN
!*      EXTERNAL FILE HAS BEEN OPENED BY THE PROGRAM)
!* FILE_VER: FILE VERSION USED TO SEEK INPUT FILE COMPATIBILITY
!*           (COMPARED TO "RELEASE")
CHARACTER :: FILE_VER*8
INTEGER ::  N, NCOUNT, NSUM, I, J, K, L, M, &
            INDEPPAR, DEPPAR, PAS
!  CONFLAGS, OPTFLAGS, INDEPPAR, DEPPAR, PAS
LOGICAL :: OPN
!>
!>*******************************************************************
!>
!>  BASIN INFORMATION AND COUNTS:
!* WF_NA: NUMBER OF GRID SQUARES
!* NAA: NUMBER OF GRID OUTLETS
!* WF_NTYPE: NUMBER OF GRUS
!* NRVR: NUMBER OF RIVER CLASSES
!* WF_IMAX: NUMBER OF GRID COLUMNS IN BASIN
!* WF_JMAX: NUMBER OF GRID ROWNS IN BASIN
!* AL: SINGLE-DIMENSION GRID SQUARE LENGTH
!* LAT/LONG, SITE LOCATION INFORMATION:
!* IYMIN: MINIMUM Y-DIRECTION GRID CO-ORDINATE (UTM)
!* WF_IYMAX: MAXIMUM Y-DIRECTION GRID CO-ORDINATE (UTM)
!* JXMIN: MINIMUM X-DIRECTION GRID CO-ORDINATE (UTM)
!* WF_JXMAX: MAXIMUM X-DIRECTION GRID CO-ORDINATE (UTM)
!* GRDN: GRID NORTHING
!* GRDE: GRID EASTING
!* LATLENGTH: SINGLE SIDE LENGTH OF GRID SQUARE IN DEGREES
!*            LATITUDE
!* LONGLENGTH: SINGLE SIDE LENGTH OF GRID SQUARE IN DEGREES
!*             LONGITUDE
!>************************************************************
!>
!> RESERVOIR MEASUREMENTS:
!* WF_RESNAME: RESERVOIR IDENTIFIER (8 CHARACTER STRING)
!* WF_NORESV: NUMBER OF RESERVOIRS
!* WR_NREL: NUMBER OF DATA POINTS
!* WF_KTR: HOURLY INCREMENT FOR RESERVOIR INPUR (24 = DAILY)
!* WF_IRES: Y-DIRECTION GAUGE CO-ORDINATE
!* WF_JRES: X-DIRECTION GAUGE CO-ORDINATE
!* WF_R: RESERVOIR'S PARENT GRID SQUARE
!* WF_QREL: RESERVOIR VALUE

INTEGER :: WF_NORESV, WF_NREL, WF_KTR, WF_NORESV_CTRL
INTEGER :: WF_ROUTETIMESTEP, WF_TIMECOUNT, DRIVERTIMESTEP
!>
!>*******************************************************************
!>
!* FRAME_NO: FRAME NUMBER BEING WRITTEN TO R2C-FORMAT FILE
!* NO_FRAMES: TOTAL NUMBER OF FRAMES IN R2C-FORMAT FILE (TOTAL
!*            NUMBER OF FRAMES IS NEVER KNOWN, IS ALWAYS SET TO
!*            FRAME_NO + 1)
INTEGER :: FRAME_NO, NO_FRAMES
!* RUNOFF: HOURLY SIMULATED RUNOFF
!* RECHARGE: HOURLY SIMULATED RECHARGE
REAL*4, DIMENSION(:, :), ALLOCATABLE :: RUNOFF, RECHARGE
!* LEAKAGE: UNKNOWN, BUT MAY BE USED IN THE FUTURE

!> GRID OUTPUT POINTS
!* BNAM: TEMPORARY HOLD FOR OUTPUT DIRECTORY (12 CHARACTER STRING)
CHARACTER :: BNAM*12
!* WF_NUM_POINTS: NUMBER OF GRID OUTPUTS
!* I_OUT: OUTPUT GRID SQUARE TEMPORARY STORE
INTEGER :: WF_NUM_POINTS, I_OUT
!* PRE_OUT: DAILY ACCUMULATIVE PRECIPITATION FOR OUTPUT
!* EVAP_OUT: DAILY ACCUMULATIVE EVAPORATION FOR OUTPUT
!* ROF_OUT: DAILY ACCUMULATIVE RUNOFF FOR OUTPUT
REAL*4, DIMENSION(:), ALLOCATABLE :: PRE_OUT, EVAP_OUT, ROF_OUT
!>
!>*******************************************************************
!>
!>*******************************************************************
!>
!> LIMITING TIME STEPS (CLASS.INI):
!> DAN  NOT USED RIGHT NOW.  CONSIDER USING THEM TO LIMIT RUN INSTEAD
!> DAN  OF END OF FORCING.BIN FILE (IS ESPECIALLY USEFUL WHEN DEBUGGING).
!* JOUT1: DAILY-AVERAGED OUTPUT START DAY (JULIAN FROM YEAR START)
!* JOUT2: DAILY-AVERAGED OUTPUT STOP DAY (JULIAN FROM YEAR START)
!* JAV1: DAILY-AVERAGED OUTPUT START YEAR
!* JAV2: DAILY-AVERAGED OUTPUT STOP YEAR
!* KOUT1: YEARLY-AVERAGED OUTPUT START DAY (JULIAN FROM YEAR START)
!* KOUT2: YEARLY-AVERAGED OUTPUT STOP DAY (JULIAN FROM YEAR START)
!* KAV1: YEARLY-AVERAGED OUTPUT START YEAR
!* KAV2: YEARLY-AVERAGED OUTPUT STOP YEAR
INTEGER :: JOUT1, JOUT2, JAV1, JAV2, KOUT1, KOUT2, KAV1, KAV2
!>
!>*******************************************************************
!>
!> CLASS CONTROL FLAGS:
!> DAN  CONSIDER INCLUDING AS CONTROL FLAGS IN RUN_OPTIONS.INI FILE SO
!> DAN  THAT THEY ARE NO LONGER HARD-CODED.
!* ALL: DESCRIPTIONS ARE WRITTEN WHERE RUN_OPTIONS.INI IS READ
INTEGER :: IDISP, IZREF, ISLFD, IPCP, IWF, IPAI, IHGT, IALC, &
  IALS, IALG, ITG, ITC, ITCG


!> GRID SQUARE COUNTS:
!* NLTEST: NUMBER OF GRID SQUARES (CLASS.INI)
!* NMTEST: NUMBER OF GRUS (CLASS.INI)
!* IHOUR: CURRENT HOUR OF MET. FORCING DATA (0 TO 23) (CLASS.INI)
!* IMIN: CURRENT MINUTE OF MET. FORCING DATA (0 OR 30) (CLASS.INI)
!* IMIN2: CURRENT MINUTE OF MET. FORCING DATA (RANGES FROM 0  TO HOURLYFLAG)
!* IDAY: CURRENT DAY OF MET. FORCING DATA (JULIAN FROM YEAR START)
!*       (CLASS.INI)
!* IYEAR: CURRENT YEAR OF MET. FORCING DATA (CLASS.INI)
!* NML: NUMBER OF LAND-ORIENTED GRID SQUARES
!* NMW: NUMBER OF WATER-ORIENTED GRID SQUARES
!* NICE: NUMBER OF LARGE ICE-BODIED GRID SQUARES (GLACIERS)
!* NWAT: NUMBER OF LARGE WATER-BODIED GRID SQUARES
INTEGER :: ILW, NLTEST, NMTEST, IHOUR, IMIN, IMIN2, IDAY, IYEAR, NML, &
  NMW, NWAT, NICE, NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI

!> LAND SURFACE PROGNOSTIC VARIABLES (CLASS.INI):
!* TBAR: INITIAL SOIL LAYER TEMPERATURE
!* THLQ: INITIAL SOIL LAYER LIQUID WATER CONTENT
!* THIC: INITIAL SOIL LAYER ICE WATER CONTENT
REAL, DIMENSION(:, :), ALLOCATABLE :: TBARGAT, THLQGAT, THICGAT
REAL, DIMENSION(:, :), ALLOCATABLE ::  TBASROW, &
  CMAIROW, TACROW, QACROW, WSNOROW
     
!* TPND: INITIAL PONDING TEMPERATURE (CLASS.INI)
!* ZPND: INITIAL PONDING DEPTH (CLASS.INI)
!* ALBS: ALBEDO OF SNOWPACK (CLASS.INI)
!* TSNO: INITIAL SNOWPACK TEMPERATURE (CLASS.INI)
!* RHOS: DENSITY OF SNOWPACK (CLASS.INI)
!* SNO: SNOWPACK ON CANOPY LAYER (CLASS.INI)
!* TCAN: INITIAL CANOPY TEMPERATURE (CLASS.INI)
!* GRO: VEGETATION GROWTH INDEX (CLASS.INI)
REAL, DIMENSION(:), ALLOCATABLE :: TPNDGAT, ZPNDGAT, TBASGAT, &
  ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, TCANGAT, RCANGAT, SCANGAT, &
  GROGAT, CMAIGAT, TACGAT, QACGAT, WSNOGAT
     
REAL, DIMENSION(:, :, :), ALLOCATABLE :: TSFSROW
REAL, DIMENSION(:, :), ALLOCATABLE :: TSFSGAT

!> GATHER-SCATTER COUNTS:
INTEGER, DIMENSION(:), ALLOCATABLE :: ILMOS, JLMOS, IWMOS, JWMOS
INTEGER, DIMENSION(:), ALLOCATABLE :: IWAT, IICE
!>
!>*******************************************************************
!>
!> CANOPY AND SOIL INFORMATION (CLASS):
!> THE LENGTH OF THESE ARRAYS IS DETERMINED BY THE NUMBER
!> OF SOIL LAYERS (3) AND THE NUMBER OF BROAD VEGETATION
!> CATEGORIES (4, OR 5 INCLUDING URBAN AREAS).
!* ALL: DEFINITIONS IN CLASS DOCUMENTATION (CLASS.INI)
REAL, DIMENSION(:, :), ALLOCATABLE :: FCANGAT, LNZ0GAT, &
  ALVCGAT, ALICGAT
 REAL, DIMENSION(:, :, :), ALLOCATABLE :: &
 PAIDROW, HGTDROW, ACVDROW, ACIDROW
REAL, DIMENSION(:, :), ALLOCATABLE :: PAMXGAT, PAMNGAT, &
  CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, VPDAGAT, VPDBGAT, PSGAGAT, &
  PSGBGAT, PAIDGAT, HGTDGAT, ACVDGAT, ACIDGAT
REAL, DIMENSION(:, :, :), ALLOCATABLE :: THPROW, THRROW, THMROW, &
  BIROW, PSISROW, GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
  PSIWROW, DLZWROW, ZBTWROW
REAL, DIMENSION(:, :), ALLOCATABLE :: THPGAT, THRGAT, THMGAT, &
  BIGAT, PSISGAT, GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
  PSIWGAT, DLZWGAT, ZBTWGAT, GFLXGAT
REAL, DIMENSION(:, :), ALLOCATABLE :: &
  WFSFROW, ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
  AGIDROW
REAL, DIMENSION(:), ALLOCATABLE :: DRNGAT, XSLPGAT, XDGAT, &
  WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
  AGIDGAT, ZSNLGAT, ZPLGGAT, ZPLSGAT, SDEPGAT, FAREGAT

!* SAND: PERCENT-CONTENT OF SAND IN SOIL LAYER (CLASS.INI)
!* CLAY: PERCENT-CONTENT OF CLAY IN SOIL LAYER (CLASS.INI)
!* ORGM: PERCENT-CONTENT OF ORGANIC MATTER IN SOIL LAYER (CLASS.INI)

!* MIDROW: DEFINITION IN CLASS DOCUMENTATION (CLASS.INI)

INTEGER, DIMENSION(:, :, :), ALLOCATABLE :: ISNDROW, IORG
INTEGER, DIMENSION(:, :), ALLOCATABLE :: ISNDGAT
!>
!>*******************************************************************
!>
!> WATROF FLAGS AND VARIABLES:
!* VICEFLG: VERTICAL ICE FLAG OR LIMIT
!* HICEFLG: HORIZONTAL ICE FLAG OR LIMIT
INTEGER :: LZFFLG, EXTFLG, IWFICE, ERRFLG, IWFOFLW
REAL :: VICEFLG, PSI_LIMIT, HICEFLG
!* DD (DDEN): DRAINAGE DENSITY (CLASS.INI)
!* MANN (WFSF): MANNING'S n (CLASS.INI)
REAL, DIMENSION(:), ALLOCATABLE :: DDGAT, MANNGAT


!> CONTROL FLAGS
!* ALL: DEFINITIONS ARE WRITTEN JUST BEFORE RUN_OPTIONS.INI IS
!*      OPENED
!* RELFLG: RELEASE-MATCH STRICTNESS
!INTEGER :: RELFLG
!>
!>*******************************************************************
!>
!> ATMOSPHERIC AND GRID-CONSTANT INPUT VARIABLES:
REAL, DIMENSION(:), ALLOCATABLE :: ZDMGRD, &
  ZDHGRD, FSVHGRD, FSIHGRD, RADJGRD, CSZGRD, FDLGRD, &
  ULGRD, VLGRD, TAGRD, QAGRD, PRESGRD, PREGRD, PADRGRD, VPDGRD, &
  TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, RHSIGRD, &
  FCLOGRD, DLONGRD, Z0ORGRD, GGEOGRD, UVGRD, XDIFFUS, &
  RPREGRD, SPREGRD, &

!> MAM - variables for forcing data interpolation:
   FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
   TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &
   FSVHGATPST, FSIHGATPST, FDLGATPST, PREGATPST, &
   TAGATPST, ULGATPST, PRESGATPST, QAGATPST

REAL    TRATIO

!> MAM - logical variables to control simulation runs:
LOGICAL ENDDATE, ENDDATA

REAL, DIMENSION(:), ALLOCATABLE :: ZRFMGAT, ZRFHGAT, ZDMGAT, &
  ZDHGAT, ZBLDGAT, FSVHGAT, FSIHGAT, RADJGAT, CSZGAT, FDLGAT, &
  ULGAT, VLGAT, TAGAT, QAGAT, PRESGAT, PREGAT, PADRGAT, VPDGAT, &
  TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
  FCLOGAT, DLONGAT, Z0ORGAT, GGEOGAT
!>
!>*******************************************************************
!>
!> LAND SURFACE DIAGNOSTIC VARIABLES:
REAL, DIMENSION(:, :), ALLOCATABLE :: CDHROW, CDMROW, HFSROW, &
  TFXROW, QEVPROW, QFSROW, QFXROW, PETROW, GAROW, EFROW, GTROW, &
  QGROW, TSFROW, ALVSROW, ALIRROW, FSNOROW, SFCTROW, SFCUROW, &
  SFCVROW, SFCQROW, FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
  FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, HEVSROW, HEVGROW, &
  HMFCROW, HMFNROW, HTCCROW, HTCSROW, PCFCROW, PCLCROW, PCPNROW, &
  PCPGROW, QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, ROFOROW, &
  ROFSROW, ROFBROW, ROFCROW, ROFNROW, ROVGROW, WTRCROW, WTRSROW, &
  WTRGROW, DRROW, WTABROW, ILMOROW, UEROW, HBLROW, TROFROW, &
  TROOROW, TROSROW, TROBROW
REAL, DIMENSION(:), ALLOCATABLE :: CDHGAT, CDMGAT, HFSGAT, &
  TFXGAT, QEVPGAT, QFSGAT, QFXGAT, PETGAT, GAGAT, EFGAT, GTGAT, &
  QGGAT, TSFGAT, ALVSGAT, ALIRGAT, FSNOGAT, SFCTGAT, SFCUGAT, &
  SFCVGAT, SFCQGAT, FSGVGAT, FSGSGAT, FSGGGAT, FLGVGAT, FLGSGAT, &
  FLGGGAT, HFSCGAT, HFSSGAT, HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, &
  HMFCGAT, HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, PCPNGAT, &
  PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, QFCFGAT, ROFGAT, ROFOGAT, &
  ROFSGAT, ROFBGAT, ROFCGAT, ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, &
  WTRGGAT, DRGAT, WTABGAT, ILMOGAT, UEGAT, HBLGAT,FTEMP,FVAP,RIB, &
  TROFGAT,TROOGAT, TROSGAT, TROBGAT
REAL, DIMENSION(:), ALLOCATABLE :: CDHGRD, CDMGRD, HFSGRD, &
  TFXGRD, QEVPGRD, QFSGRD, QFXGRD, PETGRD, GAGRD, EFGRD, GTGRD, &
  QGGRD, TSFGRD, ALVSGRD, ALIRGRD, FSNOGRD, SFCTGRD, SFCUGRD, &
  SFCVGRD, SFCQGRD, FSGVGRD, FSGSGRD, FSGGGRD, FLGVGRD, FLGSGRD, &
  FLGGGRD, HFSCGRD, HFSSGRD, HFSGGRD, HEVCGRD, HEVSGRD, HEVGGRD, &
  HMFCGRD, HMFNGRD, HTCCGRD, HTCSGRD, PCFCGRD, PCLCGRD, PCPNGRD, &
  PCPGGRD, QFGGRD, QFNGRD, QFCLGRD, QFCFGRD, ROFGRD, ROFOGRD, &
  ROFSGRD, ROFBGRD, ROFCGRD, ROFNGRD, ROVGGRD, WTRCGRD, WTRSGRD, &
  WTRGGRD, DRGRD, WTABGRD, ILMOGRD, UEGRD, HBLGRD

REAL, DIMENSION(:, :, :), ALLOCATABLE :: HMFGROW, HTCROW, QFCROW, &
  GFLXROW 
REAL, DIMENSION(:, :), ALLOCATABLE :: HMFGGAT, HTCGAT, QFCGAT
REAL, DIMENSION(:, :), ALLOCATABLE :: HMFGGRD, HTCGRD, QFCGRD
INTEGER, DIMENSION(:, :, :, :), ALLOCATABLE :: ITCTROW
INTEGER, DIMENSION(:, :, :), ALLOCATABLE :: ITCTGAT

!* TITLE: PROJECT DESCRIPTOR (6 COLUMNS: 4 CHARACTER STRINGS)
!* NAME: AUTHOR, RESEARCHER (6 COLUMNS: 4 CHARACTER STRINGS)
!* PLACE: SITE LOCATION, BASIN (6 COLUMNS: 4 CHARACTER STRINGS)
CHARACTER :: TITLE1*4, TITLE2*4, TITLE3*4, TITLE4*4, TITLE5*4, &
  TITLE6*4, NAME1*4, NAME2*4, NAME3*4, NAME4*4, NAME5*4, NAME6*4, &
  PLACE1*4, PLACE2*4, PLACE3*4, PLACE4*4, PLACE5*4, PLACE6*4
!>
!>*******************************************************************
!>*******************************************************************
!>
!> OUTPUT VARIABLES:
!> THE SUFFIX "ACC" REFERS TO THE ACCUMULATOR ARRAYS USED IN
!> CALCULATING TIME AVERAGES.
!* ALL: DEFINITIONS IN CLASS DOCUMENTATION
REAL, DIMENSION(:), ALLOCATABLE :: PREACC, GTACC, QEVPACC, &
  HFSACC, ROFACC, SNOACC, ALVSACC, ALIRACC, FSINACC, FLINACC, &
  TAACC, UVACC, PRESACC, QAACC, EVAPACC, FLUTACC, ROFOACC, &
  ROFSACC, ROFBACC, HMFNACC, WTBLACC, WSNOACC, RHOSACC, TSNOACC, &
  TCANACC, RCANACC, SCANACC, GROACC, CANARE, SNOARE

REAL, DIMENSION(:, :), ALLOCATABLE :: TBARACC, THLQACC, THICACC, &
  THALACC

!* TOTAL_ROFACC: TOTAL RUNOFF
!* TOTAL_EVAPACC: TOTAL EVAPORATION
!* TOTAL_PREACC: TOTAL PRECIPITATION
!* INIT_STORE: INITIAL STORAGE
!* FINAL_STORE: FINAL STORAGE
!* TOTAL_AREA: TOTAL FRACTIONED DRAINAGE AREA
REAL :: TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
  FINAL_STORE, TOTAL_AREA


!> CROSS-CLASS VARIABLES (CLASS):
!> ARRAYS DEFINED TO PASS INFORMATION BETWEEN THE THREE MAJOR
!> SUBSECTIONS OF CLASS ("CLASSA", "CLASST" AND "CLASSW").
REAL, DIMENSION(:, :), ALLOCATABLE :: TBARC, TBARG, TBARCS, &
  TBARGS, THLIQC, THLIQG, THICEC, THICEG, FROOT, HCPC, HCPG, &
  TCTOPC, TCBOTC, TCTOPG, TCBOTG

REAL, DIMENSION(:), ALLOCATABLE :: FC, FG, FCS, FGS, RBCOEF, &
  ZSNOW, FSVF, FSVFS, ALVSCN, ALIRCN, ALVSG, &
  ALIRG, ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, &
  ALIRSC, TRVSCN, TRIRCN, TRVSCS, TRIRCS, RC, RCS, FRAINC, &
  FSNOWC, FRAICS, FSNOCS,CMASSC, CMASCS, DISP, DISPS, ZOMLNC, &
  ZOELNC, ZOMLNG, &
  ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS, TRSNOW, CHCAP, CHCAPS, &
  GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, G12CS, G12GS, G23C, &
  G23G, G23CS, G23GS, QFREZC, QFREZG, QMELTC, QMELTG, EVAPC, &
  EVAPCG, EVAPG, EVAPCS, EVPCSG, EVAPGS, TCANO, TCANS, RAICAN, &
  SNOCAN, RAICNS, SNOCNS, CWLCAP, CWFCAP, CWLCPS, CWFCPS, TSNOCS, &
  TSNOGS, RHOSCS, RHOSGS, WSNOCS, WSNOGS, TPONDC, TPONDG, TPNDCS, &
  TPNDGS, ZPLMCS, ZPLMGS, ZPLIMC, ZPLIMG

!> BALANCE ERRORS (CLASS):
!> DIAGNOSTIC ARRAYS USED FOR CHECKING ENERGY AND WATER
!> BALANCES.
REAL, DIMENSION(:), ALLOCATABLE :: CTVSTP, CTSSTP, CT1STP, &
  CT2STP, CT3STP, WTVSTP, WTSSTP, WTGSTP

!> COMMON BLOCK PARAMETERS (CLASS):
INTEGER :: K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11
REAL :: X1, X2, X3, X4, G, GAS, X5, X6, CPRES, GASV, X7, CPI, X8, &
  CELZRO, X9, X10, X11, X12, X13, X14, X15, SIGMA, X16, DELTIM, &
  DELT, TFREZ, RGAS, RGASV, GRAV, SBC, VKC, CT, VMIN, TCW, TCICE, &
  TCSAND, TCCLAY, TCOM, TCDRYS, RHOSOL, RHOOM, HCPW, HCPICE, &
  HCPSOL, HCPOM, HCPSND, HCPCLY, SPHW, SPHICE, SPHVEG, SPHAIR, &
  RHOW, RHOICE, TCGLAC, CLHMLT, CLHVAP, PI, ZOLNG, ZOLNS, ZOLNI, &
  ZORATG, ALVSI, ALIRI, ALVSO, ALIRO, ALBRCK, DELTA, CGRAV, &
  CKARM, CPD, AS, ASX, CI, BS, BETA, FACTN, HMIN, ANGMAX


!> DAN * CONFLICTS WITH COMMON BLOCK DEFINITIONS (APR 20/08)
REAL, DIMENSION(ICAN) :: CANEXT, XLEAF, ZORAT

REAL, DIMENSION(3) :: THPORG, THRORG, THMORG, BORG, PSISORG, &
  GRKSORG
REAL, DIMENSION(18, 4, 2) :: GROWYR

INTEGER found

CHARACTER(10) :: time
CHARACTER(8)  :: cday

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

INTEGER SUBBASINCOUNT
INTEGER, DIMENSION(:), ALLOCATABLE :: SUBBASIN

!>=======================================================================
!> DAN * GLOBAL SUBROUTINES AND VARIABLES

!> SOME SUBROUTINES AND VARIABLES HAVE BEEN TAKEN FROM RTE.EXE TO
!> READ THE BASIN SHD FILE AND WRITE THE RTE.EXE INPUT FILES
!> (RUNOFF, RECHARGE, AND LEAKAGE VALUES).  TO FOLLOW THE
!> PROGRAMMING METHODS USED BY RTE.EXE, THESE SUBROUTINES AND
!> VARIABLES HAVE REMAINED GLOBAL AND ARE ACCESSIBLE BY CALLING
!> AREA_WATFLOOD AND EF_MODULE USING THE "USE" COMMAND.  THE
!> GLOBAL SUBROUTINES AND VARIABLES THAT ARE USED BY MESH_DRIVER
!> ARE LISTED BELOW.
!
!> DAN * SUBROUTINES AND MODULES:
!
!> RDEVT: SUBROUTINE USED TO READ THE EVENT FILE (EVENT/EVENT.EVT)
!> READ_SHED_EF: SUBROUTINE USED TO READ THE BASIN SHD FILE
!> WRITE_R2C: SUBROUTINE USED TO WRITE R2C-FORMAT RTE.EXE INPUT
!>            FILES (RUNOFF, RECHARGE, AND LEAKAGE VALUES)
!> AREA_WATFLOOD: MODULE CONTAINING VARIABLE DEFINITIONS
!> EF_MODULE: MODULE CONTAINING FORMATTING FUNCTIONS AND
!>            SUBROUTINES
!> EF_PARSEUTILITIES: MODULE CONTAINING FORMATTING FUNCTIONS AND
!>                    SUBROUTINES CALLED BY EF_MODULE
!> FIND_MONTH: SUBROUTINE USED TO CONVERT JULIAN DAY FROM YEAR
!>             START INTO MONTH FROM YEAR START (1 TO 12)
!> FIND_DAY: SUBROUTINE USED TO CONVERT JULIAN DAY FROM YEAR START
!>           INTO DAY FROM MONTH START (1 TO 31)

!> DAN * VARIABLES:

!* FLN: CONTAINS BASIN SHD AND RTE.EXE INPUT FILES' FILE NAMES
!* XCOUNT_TEMP, XCOUNT: NUMBER OF GRID SQUARES IN X-DIRECTION OF
!*                      BASIN (COLUMNS) (JMAX)
!* YCOUNT_TEMP, YCOUNT: NUMBER OF GRID SQUARES IN Y-DIRECTION OF
!*                      BASIN (ROWS) (IMAX)
!* AL: SINGLE GRID SIDE LENGTH IN METRES (AL)
!* NA: NUMBER OF GRID SQUARES IN BASIN (WF_NA)
!* NAA: NUMBER OF GRID SQUARE OUTLETS IN BASIN (NAA)
!* NTYPE: NUMBER OF GRUS (WF_NTYPE)
!* FRAC: GRID FRACTION (previously WF_FRAC)
!* ACLASS: PERCENT-GRU FRACTION FOR EACH GRID SQUARE
!* OUTARRAY: USED TO PASS DATA TO WRITE_R2C
!* AUTHOR: PROGRAM NAME = 'MESH_DRIVER' (PASSED TO WRITE_R2C)
!* MODELFLG: WATROUTE CONFIGURATION (FROM EVENT FILE)
!* COORDSYS_TEMP, COORDSYS1: CO-ORDINATE SYSTEM (FROM BASIN SHD
!*                           FILE) (PASSED TO WRITE_R2C)
!* ZONE_TEMP, ZONE1: CO-ORDINATE SYSTEM (FROM BASIN SHD FILE)
!*                   (PASSED TO WRITE_R2C)
!* DATUM_TEMP, DATUM1: CO-ORDINATE SYSTEM (FROM BASIN SHD FILE)
!*                     (PASSED TO WRITE_R2C)
!* XORIGIN_TEMP, XORIGIN: X-DIRECTION CO-ORDINATE OF BASIN GRID
!*                        (FROM BASIN SHD FILE) (PASSED TO
!*                        WRITE_R2C)
!* YORIGIN_TEMP, YORIGIN: Y-DIRECTION CO-ORDINATE OF BASIN GRID
!*                        (FROM BASIN SHD FILE) (PASSED TO
!*                        WRITE_R2C)
!* XDELTA_TEMP, XDELTA: AVERAGE DIFFERENCE BETWEEN TWO X-DIRECTION
!*                      SIDES OF GRID SQUARE (FROM BASIN SHD FILE)
!*                      (PASSED TO WRITE_R2C)
!* YDELTA_TEMP, YDELTA: AVERAGE DIFFERENCE BETWEEN TWO Y-DIRECTION
!*                      SIDES OF GRID SQUARE (FROM BASIN SHD FILE)
!*                      (PASSED TO WRITE_R2C)
!* SOURCE_FILE_NAME: DATA SOURCE = 'CLASS' (PASSED TO WRITE_R2C)
!* NAME: R2C-FORMAT DATA FILE NAME (PASSED TO WRITE_R2C)
!* ATTRIBUTE_NAME: R2C-FORMAT DATA IDENTIFER (PASSED TO WRITE_R2C)
!* ATTRIBUTE_UNITS: R2C-FORMAT DATA UNITS (PASSED TO WRITE_R2C)
!* ATTRIBUTE_TYPE: R2C-FORMAT DATA TYPE (PASSED TO WRITE_R2C)
!* YEAR1: YEAR OF CURRENT TIME STEP (IYEAR) (PASSED TO WRITE_R2C)
!* MONTH_NOW: MONTH OF CURRENT TIME STEP (1 TO 12) (PASSED TO
!*            WRITE_R2C)
!* DAY_NOW: DAY OF CURRENT TIME STEP (1 TO 31) (PASSED TO
!*          WRITE_R2C)
!* HOUR_NOW: HOUR OF CURRENT TIME STEP (IHOUR + 1) (1 TO 24)
!*           (PASSED TO WRITE_R2C)
!* YYY: Y-DIRECTION GRID SQUARE CO-ORDINATE (YYY), aka column coordinate
!* XXX: X-DIRECTION GRID SQUARE CO-ORDIANTE (XXX), aka row coordinate


!> These are the types defined in mesh_input_module.f that contain arrays
!> that need to be allocated in read_initial_inputs.f.
TYPE(OutputPoints) :: op
!TYPE(ShedInformation) :: si
TYPE(SoilLevels) :: sl
TYPE(ClassParameters) :: cp
TYPE(SoilValues) :: sv
TYPE(HydrologyParameters) :: hp

!> MAM - FOR AUTOCALIBRATION USING PRE-EMPTION - A MAXIMUM OF 1 YEAR (365 DAYS) 
!> DAILY STREAM FLOW IS SUPPOSED TO BE USED FOR AUTOCALIBRATION PURPOSE.
!* NCALMAX: MAXIMUM NUMBER OF CALIBRATION DATA
!* NCAL:    ACTUAL NUMBER OF CALIBRATION DATA
!* COUNTER: COUNTER FOR THE NUMBER OF PRE-EMPTION STARTS
!* EXISTS:  LOGICAL TO CHECK IF "pre_emption_value.txt" FILE EXISTS
!* SAE   :  SUM OF ABSOLUTE VALUE OF ERRORS (DEVIATIONS BETWEEN OBSERVED 
!*          AND SIMULATED STREAM FLOWS)
!* SAEPRE:  SAE AT PREVIOUS TIME STEP TRIAL
!* SAENEW:  SAE AT CURRENT TIME STEP TRIAL
!* QOBS  :  OBSERVED DAILY STREAM FLOW
!* QSIM  :  SIMULATED DAILY STREAM FLOW
INTEGER, PARAMETER :: NCALMAX = 730
INTEGER NCAL
LOGICAL EXISTS
REAL    SAE,SAEPRE,SAENEW,QOBS(NCALMAX),QSIM(NCALMAX)

!=======================================================================
!     * SET PHYSICAL CONSTANTS AND COMMON BLOCKS

COMMON    /PARAMS/    X1, X2, X3, X4, G, GAS, X5, X6, CPRES, &
                      GASV, X7
COMMON    /PARAM1/    CPI, X8, CELZRO, X9, X10, X11
COMMON    /PARAM3/    X12, X13, X14, X15, SIGMA, X16
COMMON    /TIMES/     DELTIM, K1, K2, K3, K4, K5, K6, K7, K8, K9, &
                      K10, K11

!> THE FOLLOWING COMMON BLOCKS ARE DEFINED SPECIFICALLY FOR USE
!> IN CLASS, VIA BLOCK DATA AND THE SUBROUTINE "CLASSD".
COMMON    /CLASS1/    DELT, TFREZ
COMMON    /CLASS2/    RGAS, RGASV, GRAV, SBC, VKC, CT, VMIN
COMMON    /CLASS3/    TCW, TCICE, TCSAND, TCCLAY, TCOM, TCDRYS, &
                      RHOSOL, RHOOM
COMMON    /CLASS4/    HCPW, HCPICE, HCPSOL, HCPOM, HCPSND, &
                      HCPCLY, SPHW, SPHICE, SPHVEG, SPHAIR, RHOW, &
                      RHOICE, TCGLAC, CLHMLT, CLHVAP
COMMON    /CLASS5/    THPORG, THRORG, THMORG, BORG, PSISORG, &
                      GRKSORG
COMMON    /CLASS6/    PI, GROWYR, ZOLNG, ZOLNS, ZOLNI, ZORAT, &
                      ZORATG
COMMON    /CLASS7/    CANEXT, XLEAF
COMMON    /CLASS8/    ALVSI, ALIRI, ALVSO, ALIRO, ALBRCK
COMMON    /PHYCON/    DELTA, CGRAV, CKARM, CPD
COMMON /CLASSD2/ AS,ASX,CI,BS,BETA,FACTN,HMIN,ANGMAX

!> THE FOLLOWING COMMON BLOCKS ARE DEFINED FOR WATROF
COMMON    /WATFLGS/   VICEFLG, PSI_LIMIT, HICEFLG, LZFFLG, &
                      EXTFLG, IWFICE, ERRFLG, IMIN, IHOUR, IDAY, &
                      IYEAR

DATA VICEFLG/3.0/, PSI_LIMIT/1.0/, HICEFLG/1.0/, LZFFLG/0/, &
  EXTFLG/0/, IWFICE/3/, ERRFLG/1/

!> ((((((((((((((((((((((((((((((((((
!> Set the acceptable version numbers
!> ))))))))))))))))))))))))))))))))))
!> todo this should be input file dependant,
!>  because different files will work with different releases
!>  so, make them local variables inside each read subroutine.
      RELEASE(1) = "1.1.a01"
      RELEASE(2) = "1.1.a02"
      RELEASE(3) = "1.1.a04"
      RELEASE(4) = "1.2.000"
	  RELEASE(5) = "1.2.a01"
	  RELEASE(6) = "1.3.000"

!>=======================================================================
!>      PROGRAM START
!>!TODO: UPDATE THIS (RELEASE(6)) WITH VERSION CHANGE
WRITE (6, "(' MESH 'A, ' --- ',' ('A,')'/)"), TRIM (RELEASE(6)), &
      TRIM (VERSION) !MESH VERSION

!>=======================================================================
!> INITIALIZE CLASS VARIABLES
!> SET COMMON CLASS PARAMETERS.
CALL CLASSD
!>
!>*******************************************************************
!>
CALL READ_INITIAL_INPUTS( &
!>GENERIC VARIABLES
  RELEASE, &
!>VARIABLES FOR READ_RUN_OPTIONS
  IDISP, IZREF, ISLFD, IPCP, IWF, &
  IPAI, IHGT, IALC, IALS, IALG, ITG, ITC, ITCG, &
  IOS, PAS, N, IROVAL, WF_NUM_POINTS, &
  IYEAR_START, IDAY_START, IHOUR_START, IMIN_START, &
  IYEAR_END,IDAY_END, IHOUR_END, IMIN_END, &
  IRONAME, GENDIR_OUT, &
!>variables for drainage database or new_shd
 IGND, ILG, WF_IYMAX, WF_JXMAX, &
 WF_LAND_COUNT, &
 LATDEGMIN, LATMINMIN, LATDEGMAX, LATMINMAX, &
 LONDEGMIN, LONMINMIN, LONDEGMAX, LONMINMAX, &
 WF_LAND_MAX, WF_LAND_SUM, &
!>variables for READ_CHECK_FORCING_FILES
 NUM_CSV, NUM_R2C, &
!>variables for READ_PARAMETERS_CLASS
  TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6, &
  NAME1, NAME2, NAME3, NAME4, NAME5, NAME6, &
  PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6, &
  ILW, NLTEST, NMTEST, JLAT, ICAN, &
  DEGLAT, DEGLON, &
  HOURLY_START_DAY,  HOURLY_STOP_DAY, &
  DAILY_START_DAY,   DAILY_STOP_DAY, &
  HOURLY_START_YEAR, HOURLY_STOP_YEAR, &
  DAILY_START_YEAR,  DAILY_STOP_YEAR, &
  IHOUR, IMIN, IDAY, IYEAR, &
 !>variables for READ_SOIL_INI
 !>variables for READ_PARAMETERS_HYDROLOGY
  INDEPPAR, DEPPAR, WF_R2, M_C, &
 !>the types that are to be allocated and initialised
  op, sl, cp, sv, hp)! , si, , , , )

!INITIALIZE IMIN2  
  IMIN2 = IMIN

!>
!>***********************************************************************
!> Forcing data time step should not be less than 30 min - there is no 
!> any increase in accuracy as delt (CLASS model time step) is 30 min.
!>=======================================================================
IF(HOURLYFLAG .LT. 30)THEN
  WRITE(6,*)
  WRITE(6,*)
  WRITE(6,*)
  PRINT*,"FORCING DATA TIME STEP IS LESS THAN 30 MIN"
  WRITE(6,*)
  PRINT*,"AGGREGATE THE FORCING DATA TO 30 MIN INTERVAL AND TRY AGAIN"
  WRITE(6,*)
  WRITE(6,*)
  WRITE(6,*)
  PAUSE
  STOP
ENDIF

!>
!>***********************************************************************
!> MAM - Check for parameter values - all parameters should lie within the 
!> specified ranges in the "minmax_parameters.txt" file.
!>=======================================================================
!>
call check_parameters(WF_R2,M_C,NMTEST,cp,hp)

!>
!>*******************************************************************
!>
!>=======================================================================
!> ALLOCATE ALL VARIABLES
!> DAN * IGND, ICAN, AND ICP1 HAVE BEEN INCLUDED IN CASE THEY WILL BE
!> DAN * CONFIGURABLE IN THE FUTURE (IF IN THE RUN_OPTIONS.INI FILE)
!> DAN * (APR 20/08).


!> ANDY * Allocate some variables
ALLOCATE (WF_NHYD(NA), WF_QR(NA), &
  WF_QBASE(NA), WF_QI2(NA), WF_QO1(NA), WF_QO2(NA), &
  WF_STORE1(NA), WF_STORE2(NA), WF_QI1(NA), SNOGRD(NA), &
  FSDOWN(NA),FSDOWNPRE(NA),FSDOWNPST(NA))

!> ANDY * Zero everything we just allocated
DO I=1,NA
  WF_NHYD(I) = 0
  WF_QBASE(I) = 0
  WF_QI2(I) = 0
  WF_QO1(I) = 0
  WF_QO2(I) = 0
  WF_QR(I) = 0
  WF_STORE1(I) = 0
  WF_STORE2(I) = 0
  WF_QI1(I) = 0
ENDDO

!> GRID OUTPUT SUMMARY VARIABLES:
IF (WF_NUM_POINTS .GT. 0) THEN
  ALLOCATE (PRE_OUT(WF_NUM_POINTS), EVAP_OUT(WF_NUM_POINTS), &
      ROF_OUT(WF_NUM_POINTS), STAT=PAS)
  IF (PAS .NE. 0) THEN
      WRITE (6, *)
      WRITE (6, *)
      WRITE (6, *) "Error allocating grid output summary ", &
          "variables.  Check that these bounds are within an ", &
          "acceptable range."
      WRITE (6, *) "Bound 1 (grid output points): ", WF_NUM_POINTS
      STOP
  END IF
ELSE !FOR GENERAL PURPOSES
  ALLOCATE (PRE_OUT(1), EVAP_OUT(1), ROF_OUT(1))
END IF !(WF_NUM_POINTS .GT. 0)

!> WATROUTE INPUT FILES:
ALLOCATE (OUTARRAY(YCOUNT, XCOUNT), RUNOFF(YCOUNT, XCOUNT), &
  RECHARGE(YCOUNT, XCOUNT), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating WATROUTE input variables.  ", &
      "Check that these bounds are within an acceptable range."
  WRITE (6, *) "Bound 1 (grid square rows): ", YCOUNT
  WRITE (6, *) "Bound 2 (grid square columns): ", XCOUNT
  STOP
END IF

!> MET. FORCING DATA:


!> LAND SURFACE PROGNOSTIC VARIABLES (CLASS.INI):
ALLOCATE ( &
  TBARGAT(ILG, IGND), &
  THLQGAT(ILG, IGND), THICGAT(ILG, IGND), &
  TBASROW(NA, NTYPE), &
  CMAIROW(NA, NTYPE), TACROW(NA, NTYPE), &
  QACROW(NA, NTYPE), WSNOROW(NA, NTYPE), &
  TPNDGAT(ILG), ZPNDGAT(ILG), TBASGAT(ILG), &
  ALBSGAT(ILG), TSNOGAT(ILG), RHOSGAT(ILG), &
  SNOGAT(ILG), TCANGAT(ILG), RCANGAT(ILG), &
  SCANGAT(ILG), &
  GROGAT(ILG), CMAIGAT(ILG), TACGAT(ILG), &
  QACGAT(ILG), WSNOGAT(ILG), &
  TSFSROW(NA, NTYPE, 4), &
  TSFSGAT(ILG, 4), STAT=PAS)

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

ALLOCATE ( SUBBASIN(ILG), STAT=PAS)


IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating land surface prognostic ", &
      "variables.  Check that bounds are within an acceptable ", &
      "range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  WRITE (6, *) "Bound 3 (soil layers): ", IGND
  STOP
END IF

!     * GATHER-SCATTER COUNTS:
ALLOCATE (ILMOS(ILG), JLMOS(ILG), IWMOS(ILG), &
  JWMOS(ILG), &
  IWAT(NA), IICE(NA), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating gather-scatter count ", &
      "variables.  Check that bounds are within an acceptable ", &
      "range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  STOP
END IF


ALLOCATE ( &
  FCANGAT(ILG, ICP1), LNZ0GAT(ILG, ICP1), &
  ALVCGAT(ILG, ICP1), ALICGAT(ILG, ICP1), &
  PAIDROW(NA, NTYPE, ICAN), &
  HGTDROW(NA, NTYPE, ICAN), ACVDROW(NA, NTYPE, ICAN), &
  ACIDROW(NA, NTYPE, ICAN), &
  PAMXGAT(ILG, ICAN), PAMNGAT(ILG, ICAN), &
  CMASGAT(ILG, ICAN), ROOTGAT(ILG, ICAN), &
  RSMNGAT(ILG, ICAN), QA50GAT(ILG, ICAN), &
  VPDAGAT(ILG, ICAN), VPDBGAT(ILG, ICAN), &
  PSGAGAT(ILG, ICAN), &
  PSGBGAT(ILG, ICAN), PAIDGAT(ILG, ICAN), &
  HGTDGAT(ILG, ICAN), ACVDGAT(ILG, ICAN), &
  ACIDGAT(ILG, ICAN), &
  THPROW(NA, NTYPE, IGND), THRROW(NA, NTYPE, IGND), &
  THMROW(NA, NTYPE, IGND), &
  BIROW(NA, NTYPE, IGND), PSISROW(NA, NTYPE, IGND), &
  GRKSROW(NA, NTYPE, IGND), THRAROW(NA, NTYPE, IGND), &
  HCPSROW(NA, NTYPE, IGND), TCSROW(NA, NTYPE, IGND), &
  THFCROW(NA, NTYPE, IGND), &
  PSIWROW(NA, NTYPE, IGND), DLZWROW(NA, NTYPE, IGND), &
  ZBTWROW(NA, NTYPE, IGND), &
  THPGAT(ILG, IGND), THRGAT(ILG, IGND), &
  THMGAT(ILG, IGND), &
  BIGAT(ILG, IGND), PSISGAT(ILG, IGND), &
  GRKSGAT(ILG, IGND), THRAGAT(ILG, IGND), &
  HCPSGAT(ILG, IGND), TCSGAT(ILG, IGND), &
  THFCGAT(ILG, IGND), &
  PSIWGAT(ILG, IGND), DLZWGAT(ILG, IGND), &
  ZBTWGAT(ILG, IGND), GFLXGAT(ILG, IGND), &
  WFSFROW(NA, NTYPE),  ALGWROW(NA, NTYPE), &
  ALGDROW(NA, NTYPE), ASVDROW(NA, NTYPE), ASIDROW(NA, NTYPE), &
  AGVDROW(NA, NTYPE), &
  AGIDROW(NA, NTYPE), &
  DRNGAT(ILG), XSLPGAT(ILG), XDGAT(ILG), &
  WFSFGAT(ILG), KSGAT(ILG), ALGWGAT(ILG), &
  ALGDGAT(ILG), ASVDGAT(ILG), ASIDGAT(ILG), &
  AGVDGAT(ILG), &
  AGIDGAT(ILG), ZSNLGAT(ILG), ZPLGGAT(ILG), &
  ZPLSGAT(ILG), SDEPGAT(ILG), FAREGAT(ILG), &
  ISNDROW(NA, NTYPE, IGND), IORG(NA, NTYPE, IGND), &
  ISNDGAT(ILG, IGND), STAT=PAS)

IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating canopy and soil info. ", &
      "variables.  Check that bounds are within an acceptable ", &
      "range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  WRITE (6, *) "Bound 3 (canopy types with urban areas): ", ICP1
  WRITE (6, *) "Bound 4 (canopy types): ", ICAN
  WRITE (6, *) "Bound 5 (soil layers): ", IGND
  STOP
END IF

!> WATROF FLAGS AND VARIABLES:
ALLOCATE (DDGAT(ILG), MANNGAT(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating WATROF variables.  Check ", &
      "that bounds are within an acceptable range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  STOP
END IF

!> ATMOSPHERIC AND GRID-CONSTANT INPUT VARIABLES:
ALLOCATE ( ZDMGRD(NA), &
  ZDHGRD(NA), FSVHGRD(NA), FSIHGRD(NA), RADJGRD(NA), &
  CSZGRD(NA), FDLGRD(NA), &
  ULGRD(NA), VLGRD(NA), TAGRD(NA), QAGRD(NA), PRESGRD(NA), &
  PREGRD(NA), PADRGRD(NA), VPDGRD(NA), &
  TADPGRD(NA), RHOAGRD(NA), RPCPGRD(NA), TRPCGRD(NA), &
  SPCPGRD(NA), TSPCGRD(NA), RHSIGRD(NA), &
  FCLOGRD(NA), DLONGRD(NA), Z0ORGRD(NA), GGEOGRD(NA), UVGRD(NA), &
  XDIFFUS(NA), &
  RPREGRD(NA), SPREGRD(NA), &
  ZRFMGAT(ILG), ZRFHGAT(ILG), ZDMGAT(ILG), &
  ZDHGAT(ILG), ZBLDGAT(ILG), FSVHGAT(ILG), &
  FSIHGAT(ILG), RADJGAT(ILG), CSZGAT(ILG), &
  FDLGAT(ILG), &
  ULGAT(ILG), VLGAT(ILG), TAGAT(ILG), &
  QAGAT(ILG), PRESGAT(ILG), PREGAT(ILG), &
  PADRGAT(ILG), VPDGAT(ILG), &
  TADPGAT(ILG), RHOAGAT(ILG), RPCPGAT(ILG), &
  TRPCGAT(ILG), SPCPGAT(ILG), TSPCGAT(ILG), &
  RHSIGAT(ILG), &
  FCLOGAT(ILG), DLONGAT(ILG), Z0ORGAT(ILG), &
  GGEOGAT(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating atmospheric and grid-cst. ", &
      "variables.  Check that bounds are within an acceptable ", &
      "range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  STOP
END IF

!> LAND SURFACE DIAGNOSTIC VARIABLES:
ALLOCATE (CDHROW(NA, NTYPE), CDMROW(NA, NTYPE), &
  HFSROW(NA, NTYPE), &
  TFXROW(NA, NTYPE), QEVPROW(NA, NTYPE), QFSROW(NA, NTYPE), &
  QFXROW(NA, NTYPE), PETROW(NA, NTYPE), GAROW(NA, NTYPE), &
  EFROW(NA, NTYPE), GTROW(NA, NTYPE), &
  QGROW(NA, NTYPE), TSFROW(NA, NTYPE), ALVSROW(NA, NTYPE), &
  ALIRROW(NA, NTYPE), FSNOROW(NA, NTYPE), SFCTROW(NA, NTYPE), &
  SFCUROW(NA, NTYPE), &
  SFCVROW(NA, NTYPE), SFCQROW(NA, NTYPE), FSGVROW(NA, NTYPE), &
  FSGSROW(NA, NTYPE), FSGGROW(NA, NTYPE), FLGVROW(NA, NTYPE), &
  FLGSROW(NA, NTYPE), &
  FLGGROW(NA, NTYPE), HFSCROW(NA, NTYPE), HFSSROW(NA, NTYPE), &
  HFSGROW(NA, NTYPE), HEVCROW(NA, NTYPE), HEVSROW(NA, NTYPE), &
  HEVGROW(NA, NTYPE), &
  HMFCROW(NA, NTYPE), HMFNROW(NA, NTYPE), HTCCROW(NA, NTYPE), &
  HTCSROW(NA, NTYPE), PCFCROW(NA, NTYPE), PCLCROW(NA, NTYPE), &
  PCPNROW(NA, NTYPE), &
  PCPGROW(NA, NTYPE), QFGROW(NA, NTYPE), QFNROW(NA, NTYPE), &
  QFCLROW(NA, NTYPE), QFCFROW(NA, NTYPE), ROFROW(NA, NTYPE), &
  ROFOROW(NA, NTYPE), &
  ROFSROW(NA, NTYPE), ROFBROW(NA, NTYPE), ROFCROW(NA, NTYPE), &
  ROFNROW(NA, NTYPE), ROVGROW(NA, NTYPE), WTRCROW(NA, NTYPE), &
  WTRSROW(NA, NTYPE), &
  WTRGROW(NA, NTYPE), DRROW(NA, NTYPE), WTABROW(NA, NTYPE), &
  ILMOROW(NA, NTYPE), UEROW(NA, NTYPE), HBLROW(NA, NTYPE), &
  TROFROW(NA, NTYPE), &
  TROOROW(NA, NTYPE), TROSROW(NA, NTYPE), TROBROW(NA, NTYPE), &
  CDHGAT(ILG), CDMGAT(ILG), HFSGAT(ILG), &
  TFXGAT(ILG), QEVPGAT(ILG), QFSGAT(ILG), &
  QFXGAT(ILG), PETGAT(ILG), GAGAT(ILG), &
  EFGAT(ILG), GTGAT(ILG), &
  QGGAT(ILG), TSFGAT(ILG), ALVSGAT(ILG), &
  ALIRGAT(ILG), FSNOGAT(ILG), SFCTGAT(ILG), &
  SFCUGAT(ILG), &
  SFCVGAT(ILG), SFCQGAT(ILG), FSGVGAT(ILG), &
  FSGSGAT(ILG), FSGGGAT(ILG), FLGVGAT(ILG), &
  FLGSGAT(ILG), &
  FLGGGAT(ILG), HFSCGAT(ILG), HFSSGAT(ILG), &
  HFSGGAT(ILG), HEVCGAT(ILG), HEVSGAT(ILG), &
  HEVGGAT(ILG), &
  HMFCGAT(ILG), HMFNGAT(ILG), HTCCGAT(ILG), &
  HTCSGAT(ILG), PCFCGAT(ILG), PCLCGAT(ILG), &
  PCPNGAT(ILG), &
  PCPGGAT(ILG), QFGGAT(ILG), QFNGAT(ILG), &
  QFCLGAT(ILG), QFCFGAT(ILG), ROFGAT(ILG), &
  ROFOGAT(ILG), &
  ROFSGAT(ILG), ROFBGAT(ILG), ROFCGAT(ILG), &
  ROFNGAT(ILG), ROVGGAT(ILG), WTRCGAT(ILG), &
  WTRSGAT(ILG), &
  WTRGGAT(ILG), DRGAT(ILG), WTABGAT(ILG), &
  ILMOGAT(ILG), UEGAT(ILG), HBLGAT(ILG), &
  FTEMP(ILG),   FVAP(ILG),  RIB(ILG), TROFGAT(ILG), &
  TROOGAT(ILG), TROSGAT(ILG), TROBGAT(ILG), &
  CDHGRD(NA), CDMGRD(NA), HFSGRD(NA), &
  TFXGRD(NA), QEVPGRD(NA), QFSGRD(NA), QFXGRD(NA), PETGRD(NA), &
  GAGRD(NA), EFGRD(NA), GTGRD(NA), &
  QGGRD(NA), TSFGRD(NA), ALVSGRD(NA), ALIRGRD(NA), FSNOGRD(NA), &
  SFCTGRD(NA), SFCUGRD(NA), &
  SFCVGRD(NA), SFCQGRD(NA), FSGVGRD(NA), FSGSGRD(NA), &
  FSGGGRD(NA), FLGVGRD(NA), FLGSGRD(NA), &
  FLGGGRD(NA), HFSCGRD(NA), HFSSGRD(NA), HFSGGRD(NA), &
  HEVCGRD(NA), HEVSGRD(NA), HEVGGRD(NA), &
  HMFCGRD(NA), HMFNGRD(NA), HTCCGRD(NA), HTCSGRD(NA), &
  PCFCGRD(NA), PCLCGRD(NA), PCPNGRD(NA), &
  PCPGGRD(NA), QFGGRD(NA), QFNGRD(NA), QFCLGRD(NA), QFCFGRD(NA), &
  ROFGRD(NA), ROFOGRD(NA), &
  ROFSGRD(NA), ROFBGRD(NA), ROFCGRD(NA), ROFNGRD(NA), &
  ROVGGRD(NA), WTRCGRD(NA), WTRSGRD(NA), &
  WTRGGRD(NA), DRGRD(NA), WTABGRD(NA), ILMOGRD(NA), UEGRD(NA), &
  HBLGRD(NA), &
  HMFGROW(NA, NTYPE, IGND), HTCROW(NA, NTYPE, IGND), &
  QFCROW(NA, NTYPE, IGND), GFLXROW(NA, NTYPE, IGND), &
  HMFGGAT(ILG, IGND), HTCGAT(ILG, IGND), &
  QFCGAT(ILG, IGND), &
  HMFGGRD(NA, IGND), HTCGRD(NA, IGND), QFCGRD(NA, IGND), &
  ITCTROW(NA, NTYPE, 6, 50), &
  ITCTGAT(ILG, 6, 50), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating land surface diagnostic ", &
      "variables.  Check that bounds are within an acceptable ", &
      "range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  WRITE (6, *) "Bound 3 (soil layers): ", IGND
  STOP
END IF

!> OUTPUT VARIABLES:
ALLOCATE (PREACC(NA), GTACC(NA), QEVPACC(NA), &
  HFSACC(NA), ROFACC(NA), SNOACC(NA), ALVSACC(NA), ALIRACC(NA), &
  FSINACC(NA), FLINACC(NA), &
  TAACC(NA), UVACC(NA), PRESACC(NA), QAACC(NA), EVAPACC(NA), &
  FLUTACC(NA), ROFOACC(NA), &
  ROFSACC(NA), ROFBACC(NA), HMFNACC(NA), WTBLACC(NA), &
  WSNOACC(NA), RHOSACC(NA), TSNOACC(NA), &
  TCANACC(NA), RCANACC(NA), SCANACC(NA), GROACC(NA), CANARE(NA), &
  SNOARE(NA), &
  TBARACC(NA, IGND), THLQACC(NA, IGND), THICACC(NA, IGND), &
  THALACC(NA, IGND), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating accumulator variables.  ", &
      "Check that bounds are within an acceptable range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (soil layers): ", IGND
  STOP
END IF

!> CROSS-CLASS VARIABLES (CLASS):
ALLOCATE (TBARC(ILG, IGND), TBARG(ILG, IGND), &
  TBARCS(ILG, IGND), &
  TBARGS(ILG, IGND), THLIQC(ILG, IGND), &
  THLIQG(ILG, IGND), THICEC(ILG, IGND), &
  THICEG(ILG, IGND), FROOT(ILG, IGND), &
  HCPC(ILG, IGND), HCPG(ILG, IGND), &
  TCTOPC(ILG, IGND), TCBOTC(ILG, IGND), &
  TCTOPG(ILG, IGND), TCBOTG(ILG, IGND), &
  FC(ILG), FG(ILG), FCS(ILG), &
  FGS(ILG), RBCOEF(ILG), &
  ZSNOW(ILG), &
  FSVF(ILG), FSVFS(ILG), ALVSCN(ILG), &
  ALIRCN(ILG), ALVSG(ILG), &
  ALIRG(ILG), ALVSCS(ILG), ALIRCS(ILG), &
  ALVSSN(ILG), ALIRSN(ILG), ALVSGC(ILG), &
  ALIRGC(ILG), ALVSSC(ILG), &
  ALIRSC(ILG), TRVSCN(ILG), TRIRCN(ILG), &
  TRVSCS(ILG), TRIRCS(ILG), RC(ILG), &
  RCS(ILG), FRAINC(ILG), &
  FSNOWC(ILG),FRAICS(ILG),FSNOCS(ILG), &
  CMASSC(ILG), CMASCS(ILG), &
  DISP(ILG), DISPS(ILG), ZOMLNC(ILG), &
  ZOELNC(ILG), ZOMLNG(ILG), &
  ZOELNG(ILG), ZOMLCS(ILG), ZOELCS(ILG), &
  ZOMLNS(ILG), ZOELNS(ILG), TRSNOW(ILG), &
  CHCAP(ILG), CHCAPS(ILG), &
  GZEROC(ILG), GZEROG(ILG), GZROCS(ILG), &
  GZROGS(ILG), G12C(ILG), G12G(ILG), &
  G12CS(ILG), G12GS(ILG), G23C(ILG), &
  G23G(ILG), G23CS(ILG), G23GS(ILG), &
  QFREZC(ILG), QFREZG(ILG), QMELTC(ILG), &
  QMELTG(ILG), EVAPC(ILG), &
  EVAPCG(ILG), EVAPG(ILG), EVAPCS(ILG), &
  EVPCSG(ILG), EVAPGS(ILG), TCANO(ILG), &
  TCANS(ILG), RAICAN(ILG), &
  SNOCAN(ILG), RAICNS(ILG), SNOCNS(ILG), &
  CWLCAP(ILG), CWFCAP(ILG), CWLCPS(ILG), &
  CWFCPS(ILG), TSNOCS(ILG), &
  TSNOGS(ILG), RHOSCS(ILG), RHOSGS(ILG), &
  WSNOCS(ILG), WSNOGS(ILG), TPONDC(ILG), &
  TPONDG(ILG), TPNDCS(ILG), &
  TPNDGS(ILG), ZPLMCS(ILG), ZPLMGS(ILG), &
  ZPLIMC(ILG), ZPLIMG(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating cross-CLASS variables.  ", &
      "Check that bounds are within an acceptable range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  WRITE (6, *) "Bound 3 (soil layers): ", IGND
  STOP
END IF

!> BALANCE ERRORS (CLASS):
ALLOCATE (CTVSTP(ILG), CTSSTP(ILG), &
  CT1STP(ILG), &
  CT2STP(ILG), CT3STP(ILG), WTVSTP(ILG), &
  WTSSTP(ILG), WTGSTP(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
  WRITE (6, *)
  WRITE (6, *)
  WRITE (6, *) "Error allocating balance error variables.  ", &
      "Check that bounds are within an acceptable range."
  WRITE (6, *) "Bound 1 (grid squares): ", NA
  WRITE (6, *) "Bound 2 (GRUs): ", NTYPE
  STOP
END IF
!>
!>*******************************************************************
!>
!> *********************************************************************
!>  Open additional output files
!> *********************************************************************
OPEN(unit=85,file="./" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) // &
                  '/basin_SCA_alldays.csv')
OPEN(unit=86,file="./" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) // &
                  '/basin_SWE_alldays.csv')

!> CLASS requires that each GRU for each grid square has its own parameter value,
!> for MESH the value read in from the parameter file is assumed to be valid for
!> all grid squares in the study area - Frank Seglenieks Aug 2007

!> bjd - This would be a good spot for setting pre-distributed values

DO I=2,NA
  DO M=1,NMTEST
    DO J=1, ICP1
      cp%FCANROW(I,M,J)=   cp%FCANROW(1,M,J)
      cp%LNZ0ROW(I,M,J)=   cp%LNZ0ROW(1,M,J)
      cp%ALVCROW(I,M,J)=   cp%ALVCROW(1,M,J)
      cp%ALICROW(I,M,J)=   cp%ALICROW(1,M,J)
    ENDDO

    DO J=1, ICAN
      cp%PAMXROW(I,M,J)=   cp%PAMXROW(1,M,J)
      cp%PAMNROW(I,M,J)=   cp%PAMNROW(1,M,J)
      cp%CMASROW(I,M,J)=   cp%CMASROW(1,M,J)
      cp%ROOTROW(I,M,J)=   cp%ROOTROW(1,M,J)
      cp%RSMNROW(I,M,J)=   cp%RSMNROW(1,M,J)
      cp%QA50ROW(I,M,J)=   cp%QA50ROW(1,M,J)
      cp%VPDAROW(I,M,J)=   cp%VPDAROW(1,M,J)
      cp%VPDBROW(I,M,J)=   cp%VPDBROW(1,M,J)
      cp%PSGAROW(I,M,J)=   cp%PSGAROW(1,M,J)
      cp%PSGBROW(I,M,J)=   cp%PSGBROW(1,M,J)
    ENDDO

    DO J=1,IGND
      cp%SANDROW(I,M,J)=   cp%SANDROW(1,M,J)
      cp%CLAYROW(I,M,J)=   cp%CLAYROW(1,M,J)
      cp%ORGMROW(I,M,J)=   cp%ORGMROW(1,M,J)
!> note333 see read_s_temperature_txt.f for more TBARROW information
      cp%TBARROW(I,M,J)=   cp%TBARROW(1,M,J)
!> note444 see read_s_moisture_txt.f for more THLQROW information
      cp%THLQROW(I,M,J)=   cp%THLQROW(1,M,J)
      cp%THICROW(I,M,J)=   cp%THICROW(1,M,J)
    ENDDO

    cp%TCANROW(I,M)=     cp%TCANROW(1,M)
    cp%TSNOROW(I,M)=     cp%TSNOROW(1,M)
    cp%DRNROW(I,M)=      cp%DRNROW(1,M)
    cp%SDEPROW(I,M)=     cp%SDEPROW(1,M)
    cp%FAREROW(I,M)=     cp%FAREROW(1,M)
    cp%MANNROW(I,M)=     cp%MANNROW(1,M)
    cp%XSLPROW(I,M)=     cp%XSLPROW(1,M)
    cp%XDROW(I,M)=     cp%XDROW(1,M)
    cp%DDROW(I,M)=       cp%DDROW(1,M)
    WFSFROW(I,M)=     WFSFROW(1,M)
    cp%KSROW(I,M)=     cp%KSROW(1,M)
    cp%MIDROW(I,M)=      cp%MIDROW(1,M)
    cp%TPNDROW(I,M)=     cp%TPNDROW(1,M)
    cp%ZPNDROW(I,M)=     cp%ZPNDROW(1,M)
    cp%RCANROW(I,M)=     cp%RCANROW(1,M)
    cp%SCANROW(I,M)=     cp%SCANROW(1,M)
    cp%SNOROW(I,M)=      cp%SNOROW(1,M)
    cp%ALBSROW(I,M)=     cp%ALBSROW(1,M)
    cp%RHOSROW(I,M)=     cp%RHOSROW(1,M)
    cp%GROROW(I,M)=      cp%GROROW(1,M)
  ENDDO  !DO M=1,NMTEST
ENDDO  !DO I=2,NA

!> *********************************************************************
!>  Open and read in values from MESH_input_reservoir.txt file
!> *********************************************************************

OPEN(UNIT=21,FILE='MESH_input_reservoir.txt',STATUS='OLD')
	READ(21,'(3I5)') WF_NORESV,WF_NREL,WF_KTR
WF_NORESV_CTRL=0

IF( WF_NORESV>0 ) THEN
  DO I=1,WF_NORESV
    READ(21,'(2I5,2G10.3,25X,A12,I2)') WF_IRES(I),WF_JRES(I), &
      WF_B1(I),WF_B2(I),WF_RESNAME(I), WF_RES(I)
    WF_IRES(I)=INT((REAL(WF_IRES(I))-REAL(IYMIN))/GRDN+1.0) 
    WF_JRES(I)=INT((REAL(WF_JRES(I))-REAL(JXMIN))/GRDE+1.0)
!> check if point is in watershed and in river reaches
    WF_R(I)=0
    DO J=1,NA
      IF( WF_IRES(I)==YYY(J).AND.WF_JRES(I)==XXX(J))THEN
        WF_R(I)=J
      ENDIF
    ENDDO
    IF(WF_R(I)==0) THEN
      PRINT *, 'Reservoir Station: ',I,' is not in the basin'
	      PRINT *, 'Up/Down Coordinate: ', wf_ires(I), Iymin
	      PRINT *, 'Left/Right Coordinate: ', wf_jres(I),jxmin
      STOP
    ENDIF
    IF(WF_IREACH(WF_R(I))/=I) THEN
      PRINT *, 'Reservoir Station: ',I, &
        ' is not in the correct reach'
	      PRINT *, 'Up/Down Coordinate: ', wf_ires(I)
	      PRINT *, 'Left/Right Coordinate: ', wf_jres(I)
	      PRINT *, 'ireach value at station: ', wf_iy(I)
      STOP
	    ENDIF
    IF( WF_B1(I)==0.0 ) THEN
      WF_NORESV_CTRL=WF_NORESV_CTRL+1
    ENDIF
  ENDDO
ENDIF
!> leave file open and read in the reservoir files when needed



!> *********************************************************************
!> Open and read in values from MESH_input_streamflow.txt file
!> *********************************************************************
OPEN(UNIT=22,FILE='MESH_input_streamflow.txt',STATUS='OLD')
READ(22,*)
READ(22,'(7I5)') WF_NO,WF_NL,WF_MHRD,WF_KT, WF_START_YEAR,&
        WF_START_DAY,WF_START_HOUR
DO I=1,WF_NO
  READ(22,'(2I5,1X,A12)')WF_IY(I),WF_JX(I),WF_GAGE(I)
  WF_IY(I)=INT((REAL(WF_IY(I))-REAL(IYMIN))/GRDN+1.0)
  WF_JX(I)=INT((REAL(WF_JX(I))-REAL(JXMIN))/GRDE+1.0)

ENDDO

DO I=1,WF_NO
  WF_S(I)=0
  DO J=1,NA
    IF( WF_JX(I)==xxx(J).AND.WF_IY(I)==yyy(J) ) THEN
      WF_S(I)=J
    ENDIF
  ENDDO
  IF(WF_S(I)==0) THEN
    PRINT *, 'STREAMFLOW GAUGE: ',I,' IS NOT IN THE BASIN'
	    PRINT *, 'UP/DOWN', WF_IY(I),iymin,yyy(189),ycount
	    PRINT *, 'LEFT/RIGHT', WF_JX(I),jxmin,xxx(189),xcount
    STOP
	  ENDIF
!> ric     initialise smoothed variables
  wf_qsyn(I)=0.0
	  wf_qhyd_avg(I)=0.0
ENDDO

!>MAM - The first stream flow record is used for flow initialization
READ(22,'(100F10.3)',IOSTAT=IOS) (WF_QHYD(I),I=1,WF_NO)

	  ! fixed streamflow start time bug. add in function to enable the 
	  ! correct start time. Feb2009 aliu. 
	     call Julian_Day_ID(WF_START_YEAR, WF_START_day,&
		 Jday_IND1)
		 call Julian_Day_ID(IYEAR_START, IDAY_START,&
		 Jday_IND2)
		 call Julian_Day_ID(IYEAR,IDAY,Jday_IND3)
!          write (*,*) WF_START_YEAR, WF_START_day, Jday_IND1
		     if (iyear_start ==0) then 
		       jday_ind2=jday_ind1
			 endif
		 if (jday_ind2 < jday_ind1) then 
		 PRINT *, 'ERROR: Simulation start date too early, check ', &
          ' MESH_input_streamflow.txt, The start date in ', &
          ' MESH_input_run_options.ini may be out of range'
		  stop
		  endif
		 jday_ind_strm=(jday_ind2-jday_ind1)*24/WF_KT
		 jday_ind_met=jday_ind2-jday_ind3
		 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 !skip the unused streamflow records in streamflow.txt .      !
		 DO J=1, jday_ind_strm                                        !
	      READ(22,*,IOSTAT=IOS)                                       !
		   IF (IOS < 0) THEN                                          !
	         PRINT *, 'ERROR: end of file reached when reading ', &   !
             ' MESH_input_streamflow.txt, The start date in ', &      !
             ' MESH_input_run_options.ini may be out of range'        !
             STOP                                                     !
	       ENDIF                                                      !
		 enddo                                                        !
		  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		  PRINT *, 'Skipping',jday_ind_strm,'Registers in streamflow file'
!> leave unit open and read new streamflow each hour


!todo - verify that all checks are needed and in the right spot
!> *********************************************************************
!> Check to make sure input values are consistent
!> *********************************************************************
!> compare land classes in class.ini and drainage database files
IF(NTYPE/=NMTEST.AND.NTYPE>0) THEN
  PRINT *, 'land classes from MESH_parameters_CLASS.ini: ',NMTEST
  PRINT *, 'land classes from MESH_drainage_database.txt:', &
            NTYPE
  PRINT *, 'Please adjust these values.'
	  STOP
	ENDIF

!> check that run points are in the basin and that there are no repeats

DO I=1, WF_NUM_POINTS
  IF(op%N_OUT(I)>NA) THEN
    PRINT *, 'No. of grids from MESH_drainage_database.txt:',NA
    PRINT *, 'out point ',i,' is: ',op%N_OUT(I)
    PRINT *, 'please adjust MESH_run_options.ini file'
    STOP
  ENDIF

  IF(I<WF_NUM_POINTS) THEN
    DO J=I+1,WF_NUM_POINTS
      IF(op%N_OUT(I)==op%N_OUT(J) .AND. op%II_OUT(I) == op%II_OUT(J)) THEN
        PRINT *, 'grid number ', op%N_OUT(i)
        PRINT *, 'is repeated in MESH_run_options.ini file'
        PRINT *, 'please adjust MESH_run_options.ini file'
        STOP
      ENDIF
    ENDDO
  ENDIF
  
ENDDO

!> *********************************************************************
!> Set some more intial values and clear accumulators
!> *********************************************************************

!> ASSIGN VALUES OF LAT/LONG TO EACH SQUARE:
!> NOTE FROM FRANK
!> I got the equations to determine the actual length of a 
!> degree of latitude and longitude from this paper, thank you 
!> Geoff Kite (I have attached it):
!> http://www.agu.org/pubs/crossref/1994/94WR00231.shtml
!> This chunk of code is a way to put the actual values of 
!> longitude and latitude for each cell in a large basin.  
!> The original CLASS code just put in the same value for each cell.  
!> The problem is that the class.ini file only has a single value 
!> of long and lat (as it was only designed for a point).  So in order 
!> to get the values across the basin I assumed that the single value 
!> from the class.ini file is in the centre of the basin and then use 
!> information from the watflow.shd file to figure out the long/lat 
!> varies across the basin.  However, the watflod.shd file only gives 
!> information in kilometers not degrees of long/lat so I had 
!> to use the formulas from the above paper to go between the two.
!
!> The only value of DEGLAT is the one read in from the class.ini file, 
!> after that Diana uses RADJGRD (the value of latitude in radians) so 
!> after DEGLAT is used to calculate RADJGRD is it no longer used.  This 
!> is how it was in the original CLASS code.
DO I=1, NA
  LATLENGTH=AL/1000./(111.136-0.5623*COS(2*(DEGLAT*PI/180.0))+ &
  0.0011*COS(4*(DEGLAT*PI/180.0)))
  LONGLENGTH=AL/1000./(111.4172*COS((DEGLAT*PI/180.0))- &
  0.094*COS(3*(DEGLAT*PI/180.0))+0.0002*COS(5*(DEGLAT*PI/180.0)))
  RADJGRD(I)=( (DEGLAT-(REAL(YCOUNT)/2.0)*LATLENGTH) &
  +(YYY(I)-0.5)*LATLENGTH)*PI/180.
  DLONGRD(I)=(DEGLON-(REAL(XCOUNT)/2.0)*LONGLENGTH) &
  +(XXX(I)-0.5)*LONGLENGTH
  cp%ZRFMGRD(I)=cp%ZRFMGRD(1)
  cp%ZRFHGRD(I)=cp%ZRFHGRD(1)
  cp%ZBLDGRD(I)=cp%ZBLDGRD(1)
  cp%GCGRD(i)=cp%GCGRD(1)
  Z0ORGRD(I)=0.0
  GGEOGRD(I)=0.0
  ZDMGRD(I)=10.0
  ZDHGRD(I)=2.0
ENDDO

!> adjust NAA to the be number of outlet squares, as currently it is the
!> number of squares with outlets into other squares in the basin, and
!> we want it to be the number of squares with outlets to outside the
!> basin.
!todo - look into the logic of this and suggest how it could be changed
NAA=NA-NAA

!> set initial values of ncount and nsum
! NCOUNT = which half-hour period the current time is:
! The first period (0:00-0:30) is #1, the last period (23:30-0:00) is #48
NCOUNT=IHOUR*2+IMIN/30+1
NSUM=1

!> **********************************************************************
!>  Start of section to only run on squares that make up the watersheds
!>  that are listed in the streamflow file (subbasin)
!> **********************************************************************

IF(SUBBASINFLAG.GT.0) THEN

  DO I=1,NA
    SUBBASIN(I)=0
  ENDDO

!> Set values at guages to 1

DO I=1,WF_NO
  SUBBASIN(WF_S(I)) = 1
ENDDO

!> Set values of subbasin to 1 for all upstream grids

SUBBASINCOUNT=1

DO WHILE (SUBBASINCOUNT.GT.0) 

SUBBASINCOUNT=0

  DO I=1,NA-1
    IF(SUBBASIN( WF_NEXT(I) ).EQ.1.AND.SUBBASIN(I).EQ.0) THEN
      SUBBASIN(I)=1
      SUBBASINCOUNT=SUBBASINCOUNT+1
    ENDIF
  ENDDO

ENDDO  !DO WHILE (SUBBASINCOUNT.GT.0) 

!> Set values of frac to 0 for all grids non-upstream grids

SUBBASINCOUNT=0

  DO I=1,NA
    IF(SUBBASIN(I).EQ.0) THEN
      FRAC(I)=0
    ELSE
      SUBBASINCOUNT=SUBBASINCOUNT+1
    ENDIF
  ENDDO

ENDIF


!> **********************************************************************
!>  End of subbasin section
!> **********************************************************************



!> Set value of FAREROW: 
!todo - flag this as an issue to explore later and hide basin average code
!todo - document the problem
TOTAL_AREA=0.0
DO I=1,NA
  DO M=1,NMTEST
    cp%FAREROW(I, M) = ACLASS(I, M)*FRAC(I)
    TOTAL_AREA=TOTAL_AREA+cp%FAREROW(I,M)
    !FUTUREDO: Bruce, FRAC is calculated by EnSim
    ! using Dan Princz's instructions for EnSim
    ! FRAC can be greater than 1.00
    ! So, we cannot use FAREROW in place of BASIN_FRACTION
  ENDDO
ENDDO


!> routing parameters
WF_ROUTETIMESTEP=900
WF_TIMECOUNT=0
DRIVERTIMESTEP=DELT    ! Be sure it's REAL*8

!* JAN: The first time throught he loop, jan=1. Jan will equal 2 after that.
	JAN=1 

!todo - check that this is compatible with Saul's pre-distributed soil moisture and soil temp.
DO I=1,NA
  DO M=1,NMTEST
    DO J=1,IGND
      cp%TBARROW(I,M,J)=cp%TBARROW(I,M,J)+TFREZ
    END DO
    cp%TSNOROW(I,M)=cp%TSNOROW(I,M)+TFREZ
    cp%TCANROW(I,M)=cp%TCANROW(I,M)+TFREZ
    cp%TPNDROW(I,M)=cp%TPNDROW(I,M)+TFREZ
    TBASROW(I,M)=cp%TBARROW(I,M,3)
    CMAIROW(I,M)=0.
    WSNOROW(I,M)=0.
    TSFSROW(I,M,1)=TFREZ
    TSFSROW(I,M,2)=TFREZ
    TSFSROW(I,M,3)=cp%TBARROW(I,M,1)
    TSFSROW(I,M,4)=cp%TBARROW(I,M,1)
    TACROW (I,M)=cp%TCANROW(I,M)
    QACROW (I,M)=0.5E-2
    IF(IGND>3)THEN ! should stay this way to work with class
    !todo - if we have time, change this so that soil.ini can take more than 3 layers.
      DO J=4,IGND
        cp%THLQROW(I,M,J)=cp%THLQROW(I,M,3)
        cp%THICROW(I,M,J)=cp%THICROW(I,M,3)
        cp%TBARROW(I,M,J)=cp%TBARROW(I,M,3)
        IF(cp%SDEPROW(I,M)<(sl%ZBOT(J-1)+0.001) .AND. &
          cp%SANDROW(I,M,3)>-2.5)THEN
          cp%SANDROW(I,M,J)=-3.0
          cp%CLAYROW(I,M,J)=-3.0
          cp%ORGMROW(I,M,J)=-3.0
        ELSE
          cp%SANDROW(I,M,J)=cp%SANDROW(I,M,3)
          cp%CLAYROW(I,M,J)=cp%CLAYROW(I,M,3)
          cp%ORGMROW(I,M,J)=cp%ORGMROW(I,M,3)
        ENDIF
      ENDDO
    ENDIF
    DO K=1,6
      DO L=1,50
        ITCTROW(I,M,K,L)=0
      ENDDO
    ENDDO

  ENDDO !DO M=1,NMTEST
ENDDO !DO I=1,NA

!> clear accumulating variables
TOTAL_ROFACC=0.0
TOTAL_ROFOACC=0.0
TOTAL_ROFSACC=0.0
TOTAL_ROFBACC=0.0
TOTAL_EVAPACC=0.0
TOTAL_PREACC=0.0

DO I=1,NA
  PREACC(I)=0.
  GTACC(I)=0.
  QEVPACC(I)=0.
  EVAPACC(I)=0.
  HFSACC(I)=0.
  HMFNACC(I)=0.
  ROFACC(I)=0.
  ROFOACC(I)=0.
  ROFSACC(I)=0.
  ROFBACC(I)=0.
  WTBLACC(I)=0.
  ALVSACC(I)=0.
  ALIRACC(I)=0.
  RHOSACC(I)=0.
  SNOACC(I)=0.
  WSNOACC(I)=0.
  CANARE(I)=0.
  SNOARE(I)=0.
  TSNOACC(I)=0.
  TCANACC(I)=0.
  RCANACC(I)=0.
  SCANACC(I)=0.
  GROACC(I)=0.
  FSINACC(I)=0.
  FLINACC(I)=0.
  FLUTACC(I)=0.
  TAACC(I)=0.
  UVACC(I)=0.
  PRESACC(I)=0.
  QAACC(I)=0.
  DO J=1,IGND
    TBARACC(I,J)=0.
    THLQACC(I,J)=0.
    THICACC(I,J)=0.
    THALACC(I,J)=0.
  ENDDO
ENDDO

!> SET GRID-FORMAT WATROUTE OUTPUT           !
DO I = 1, YCOUNT                            !    
  DO J = 1, XCOUNT                          !
      RUNOFF(I, J) = 0.0                    !    
      RECHARGE(I, J) = 0.0                  !  
!> CDAN            LEAKAGE(I, J) = 0.0       ! 
   END DO                                   !  
END DO                                      !  


!> SET GRID OUPUT SUMMARY
IF (WF_NUM_POINTS .GT. 1) THEN
  DO I = 1, WF_NUM_POINTS
      PRE_OUT(I) = 0.0
      EVAP_OUT(I) = 0.0
      ROF_OUT(I) = 0.0
  END DO
ELSE
  PRE_OUT(1) = 0.0
  EVAP_OUT(1) = 0.0
  ROF_OUT(1) = 0.0
END IF

!>  SET FRAME COUNT FOR WRITE_R2C
FRAME_NO = 1
NO_FRAMES = FRAME_NO + 1

!> ******************************************************
!> echo print information to MESH_output_echo_print.txt
!> ******************************************************

OPEN(UNIT=58,FILE="./" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) // &
                  '/MESH_output_echo_print.txt')

WRITE(58,"('MESH_input_run_options.ini')")
WRITE(58,*)
WRITE(58,"('Configuration flags:')")
IF(CONFLAGS>0) THEN
  DO I=1,CONFLAGS
    WRITE (58,*)
  ENDDO
ENDIF

!> MAM - ALLOCATE AND INITIALIZE INTERPOLATION VARIABLES:
!> For 30 minute forcing data there is no need for interpolation and 
!> hence no need to assign PRE and PST variables
IF(INTERPOLATIONFLAG > 1 .OR. &
  (INTERPOLATIONFLAG == 1  .AND. HOURLYFLAG == 30))THEN
    WRITE(6,*)
    WRITE(58,*)
    WRITE(6,9000)
    WRITE(58,9000)
    WRITE(6,*)
    WRITE(58,*)
    INTERPOLATIONFLAG = 0
ENDIF

	WRITE(58,"('WF_NUM_POINTS: ',I5)") WF_NUM_POINTS
WRITE(58,"('Out directory:',5A10)") &
  (op%DIR_OUT(I),I=1,WF_NUM_POINTS)
WRITE(58,"('Grid number:  ',5I10)") &
  (op%N_OUT(I),I=1,WF_NUM_POINTS)
WRITE(58,"('Land class:   ',5I10)") &
  (op%II_OUT(I),I=1,WF_NUM_POINTS)
WRITE (58,*)

WRITE(58,"('MESH_parameters_hydrology.ini')")
WRITE(58,*)
WRITE(58,"('Option flags:')")
IF(OPTFLAGS>0) THEN
  DO I=1,OPTFLAGS
    WRITE (58,*)
  ENDDO
ENDIF

WRITE(58,"('River roughnesses:')")
WRITE(58,"(5F6.3)") (WF_R2(I),I=1,5)

WRITE(58,"('Land class independent hydrologic parameters:')")
IF(INDEPPAR>0) THEN
  DO I=1,INDEPPAR
    WRITE (58,*)
  ENDDO
ENDIF
WRITE(58,"('Land class dependent hydrologic parameters:')")
IF(DEPPAR>0) THEN
WRITE(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZSNLROW'", NMTEST
WRITE(58,NMTESTFORMAT) (hp%ZSNLROW(1,M),M=1,NMTEST)
WRITE(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZPLSROW'", NMTEST
WRITE(58,NMTESTFORMAT) (hp%ZPLSROW(1,M),M=1,NMTEST)
WRITE(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZPLGROW'", NMTEST
WRITE(58,NMTESTFORMAT) (hp%ZPLGROW(1,M),M=1,NMTEST)
ENDIF

WRITE (58,*)


WRITE(58,"('MESH_parameters_CLASS.ini')")
WRITE(58,*)
WRITE(58,'(2X,6A4)') TITLE1,TITLE2,TITLE3,TITLE4,TITLE5,TITLE6
WRITE(58,'(2X,6A4)') NAME1,NAME2,NAME3,NAME4,NAME5,NAME6
WRITE(58,'(2X,6A4)') PLACE1,PLACE2,PLACE3,PLACE4,PLACE5,PLACE6
WRITE(58,'(5F10.2,F7.1,3I5)') DEGLAT,DEGLON,cp%ZRFMGRD(1), &
  cp%ZRFHGRD(1), cp%ZBLDGRD(1), cp%GCGRD(1),ILW,NA,NMTEST
I=1
DO M=1,NMTEST
WRITE(58,'(9F8.3)') (cp%FCANROW(I,M,J),J=1,ICAN+1), &
	(cp%PAMXROW(I,M,J),J=1,ICAN)
WRITE(58,'(9F8.3)') (cp%LNZ0ROW(I,M,J),J=1,ICAN+1), &
                  (cp%PAMNROW(I,M,J),J=1,ICAN)
WRITE(58,'(9F8.3)') (cp%ALVCROW(I,M,J),J=1,ICAN+1), &
                  (cp%CMASROW(I,M,J),J=1,ICAN)
WRITE(58,'(9F8.3)') (cp%ALICROW(I,M,J),J=1,ICAN+1), &
                  (cp%ROOTROW(I,M,J),J=1,ICAN)
WRITE(58,'(4F8.3,8X,4F8.3)') (cp%RSMNROW(I,M,J),J=1,ICAN), &
                  (cp%QA50ROW(I,M,J),J=1,ICAN)
WRITE(58,'(4F8.3,8X,4F8.3)') (cp%VPDAROW(I,M,J),J=1,ICAN), &
                  (cp%VPDBROW(I,M,J),J=1,ICAN)
WRITE(58,'(4F8.3,8X,4F8.3)') (cp%PSGAROW(I,M,J),J=1,ICAN), &
                  (cp%PSGBROW(I,M,J),J=1,ICAN)
WRITE(58,'(3F8.3,F8.4)') cp%DRNROW(I,M),cp%SDEPROW(I,M), &
                  cp%FAREROW(I,M),cp%DDROW(I,M)
WRITE(58,'(4E8.1,I8)') cp%XSLPROW(I,M),cp%XDROW(I,M), &
                  cp%MANNROW(I,M),cp%KSROW(I,M),cp%MIDROW(I,M)
WRITE(58,'(6F10.1)') (cp%SANDROW(I,M,J),J=1,IGND)
WRITE(58,'(6F10.1)') (cp%CLAYROW(I,M,J),J=1,IGND)
WRITE(58,'(6F10.1)') (cp%ORGMROW(I,M,J),J=1,IGND)
WRITE(58,'(9F10.2)') (cp%TBARROW(I,M,J),J=1,IGND),cp%TCANROW(I,M), &
                  cp%TSNOROW(I,M),cp%TPNDROW(I,M)
WRITE(58,'(10F10.3)') (cp%THLQROW(I,M,J),J=1,IGND), &
                  (cp%THICROW(I,M,J),J=1,IGND),cp%ZPNDROW(I,M)
WRITE(58,'(2F10.4,F10.2,F10.3,F10.4,F10.3)') &
                  cp%RCANROW(I,M),cp%SCANROW(I,M),cp%SNOROW(I,M), &
                  cp%ALBSROW(I,M),cp%RHOSROW(I,M),cp%GROROW(I,M)
WRITE(58,*)
ENDDO

IF(INTERPOLATIONFLAG == 1)THEN
    ALLOCATE (FSVHGATPRE(ILG), FSIHGATPRE(ILG), FDLGATPRE(ILG), PREGATPRE(ILG), &
               TAGATPRE(ILG), ULGATPRE(ILG), PRESGATPRE(ILG), QAGATPRE(ILG), &
               FSVHGATPST(ILG), FSIHGATPST(ILG), FDLGATPST(ILG), PREGATPST(ILG), &
               TAGATPST(ILG), ULGATPST(ILG), PRESGATPST(ILG), QAGATPST(ILG))

    FSVHGATPRE  = 0.0
    FSIHGATPRE  = 0.0
    FDLGATPRE   = 0.0
    PREGATPRE   = 0.0
    TAGATPRE    = 0.0
    ULGATPRE    = 0.0
    PRESGATPRE  = 0.0
    QAGATPRE    = 0.0  
    FSVHGATPST  = 0.0
    FSIHGATPST  = 0.0
    FDLGATPST   = 0.0
    PREGATPST   = 0.0
    TAGATPST    = 0.0
    ULGATPST    = 0.0
    PRESGATPST  = 0.0
    QAGATPST    = 0.0
ENDIF

!>
!>****************CHECK RESUME FILE***************************************************
!>
IF (RESUMEFLAG == 1 ) THEN
  OPEN(88,FILE="class_resume.txt", STATUS="UNKNOWN", IOSTAT=IOS)
  IF (IOS /= 0) THEN
    WRITE (58, *),"WARNING: You've specified a start time", &
     " without having a resume file. Now ending run."

    PRINT*, "No class_resume.txt found."
    PRINT*, "The RESUMEFLAG in MESH_input_run_options.ini is", &
      " set to 1, which means that class_resume.txt should be here,", &
      " but it is not here."
    PRINT*,"Ending Run"
    STOP
  END IF
  CLOSE (UNIT=88)
END IF
!>
!>*******************************************************************
!>
!>
!>***************CHECK MODEL FLAG****************************************************
!>
!MODELFLG='r'
!> R2C-FORMAT OUTPUT FILES (RUNOFF, RECHARGE, AND LEAKAGE VALUES)
!> CALL WRITE_R2C TO WRITE R2C-FORMAT FILES
AUTHOR = "MESH_DRIVER"
IF (MODELFLG .EQ. "i") AUTHOR="MESH_DRIVER (rte -i)"
IF (MODELFLG .EQ. "r") AUTHOR="MESH_DRIVER (rte -r)"
IF (MODELFLG .EQ. "l") AUTHOR="MESH_DRIVER (rte -l)"
COORDSYS_TEMP = COORDSYS1
ZONE_TEMP = ZONE1
DATUM_TEMP = DATUM1
XORIGIN_TEMP = XORIGIN
YORIGIN_TEMP = YORIGIN
XCOUNT_TEMP = XCOUNT
YCOUNT_TEMP = YCOUNT
XDELTA_TEMP = XDELTA
YDELTA_TEMP = YDELTA
SOURCE_FILE_NAME = "CLASS"

!> OPEN RTE.EXE INPUT FILES (UNIT 261, UNIT 262)
!> DAN * UNIT NUMBERS HAVE BEEN PULLED FROM RTE.EXE SUBROUTINES, THEIR
!> DAN * FILE NAMES (FLN(31), FLN(32)) ARE READ FROM THE EVENT FILE
!> DAN * FILES ARE OPENED ACCORDING TO MODELFLG IN THE EVENT FILE

IF (MODELFLG.EQ."i" .OR. MODELFLG.EQ."r" .OR. MODELFLG.EQ."l") &
  THEN !WRITE RUNOFF HEADER
  NAME = "Gridded Channel Inflow"
  ATTRIBUTE_NAME = "channel_inflow"
  ATTRIBUTE_UNITS = "mm"
  ATTRIBUTE_TYPE = "flow"
  CALL WRITE_R2C (261, 31, 0, 1, 0, 1, 1)
END IF

IF (MODELFLG .EQ. "r") THEN !WRITE RECHARGE HEADER
  NAME = "Gridded Recharge"
  ATTRIBUTE_NAME = "recharge"
  ATTRIBUTE_UNITS = "mm"
  ATTRIBUTE_TYPE = "flow"
  CALL WRITE_R2C (262, 32, 0, 1, 0, 1, 1)
END IF

!+     IF (MODELFLG .EQ. "l") THEN !WRITE RECHARGE HEADER
!+        NAME = "Gridded Leakage"
!+        ATTRIBUTE_NAME = "leakage"
!+        ATTRIBUTE_UNITS = "cms"
!+        ATTRIBUTE_TYPE = " "
!+        CALL WRITE_R2C (263, 33, 0, 1, 0, 1, 1)
!+      END IF

!> *********************************************************************
!> Open the MESH_input_forcing.bin file
!> *********************************************************************
!todo - if we have time (or later), change the binary forcing files to 
!       one for each forcing variable
!> Only open if there are not enough separate forcing files
IF (NUM_R2C + NUM_CSV < 7) THEN
  OPEN(UNIT=51,FILE='MESH_input_forcing.bin',STATUS='OLD', &
           FORM='UNFORMATTED')
ENDIF

!todo - leave these in for event based runs
!> IYEAR is set in the MESH_parameters_CLASS.ini file
!> IYEAR_START is set in the MESH_input_run_options.ini file
!> !P : IYEAR_START is set in the MESH_parameters_class.ini file

!> the following code is used to skip entries at the start
!> of the bin file

!PARAMESH

nyy = IYEAR_START - IYEAR
ndy = IDAY_START  - IDAY
nmy = IMIN_START  - IMIN !P
nhy = IHOUR_START - IHOUR !P
!P      nmy = IMIN
!P      nhy = 24 - IHOUR
! set ISTEP_START based on HOURLYFLAG
!  (could be optimised as ISTEP_START = 2 - HOURLYFLAG)
!HOURLYFLAG is 1 if the data is every hour, and 0 if the data is every half-hour
!ISTEP_START is used to calculate nrs, and doubles the effect of the hours and
! minutes if the data is in half-hourly format
!IF (HOURLYFLAG == 1) THEN
!  ISTEP_START = 1
!ELSE
!  ISTEP_START = 2
!ENDIF
!Note added by M. Mekonnen
!ISTEP_START is used to count the number of records in one hour, 
!hence a 30 minute interval forcing data will have 2 records per hour (ISTEP_START = 2)
!and a 1 hour interval forcing data will have 1 record per hour (ISTEP_START = 1). To 
!accomodate forcing data with time intervals greater than 1 hour, 
!it is better to count the number of records in a day:
ISTEP_START = 24*60 / HOURLYFLAG
if(mod(24*60,HOURLYFLAG) /= 0)then
   write(*,*)
   write(*,*)"Forcing data time interval needs to be in either"
   write(*,*)"of the following values:"
   write(*,*)"30 or n*60 where n can be either 1,2,3,4,6,8 or 12"
   write(*,*)
   pause
   stop
endif

if ((jday_ind2 < jday_ind3) .and. (iyear_start /= 0)) then 
   PRINT *, 'ERROR: Simulation start date too early, check ', &
            ' THE MET FORCING DATA RANGE.  The start date in ', &
            ' MESH_input_run_options.ini may be out of range'
   stop
endif
!Notes added by M. Mekonnen - To keep nrs calculation as before
!(and to be compatible with the above modification) we need to 
!divide ISTEP_START by 24.
!nrs =JDAY_IND_MET*ISTEP_START*24 + nhy*ISTEP_START + nmy/30  !aLIU
nrs =JDAY_IND_MET*ISTEP_START + nhy*ISTEP_START/24 + nmy/30
PRINT *,'NRS=',NRS
! FIX BUG IN JULIAN DAY CALCULATION FOR NRS ---ALIU FEB2009
IF (IYEAR_START == 0 .AND. IDAY_START == 0 .AND. IMIN_START == 0 &
    .AND. IHOUR_START == 0) THEN !P
  IYEAR_START = IYEAR
  IDAY_START = IDAY
  IHOUR_START = IHOUR !P
  IMIN_START = IMIN !P
  nrs = 0
ELSEIF (nrs<0) THEN
  PRINT*,'Desired start date is before the start of the ', &
    'data in MESH_input_forcing.bin'
  PRINT *, 'Please adjust the start date in ', &
    'MESH_input_run_options.ini'
  STOP
ENDIF

PRINT *, 'Skipping',NRS,'Registers in bin file'
IYEAR = IYEAR_START
IDAY = IDAY_START
!+      IHOUR = IHOUR_START
!+      IMIN = IMIN_START

!> skip the values in the forcing files
toskip = 7 - NUM_R2C - NUM_CSV
DO i=1,nrs
  DO J=1,toskip
    READ(51,END=999) !Skip the bin's information
  ENDDO
  IF(BASINSHORTWAVEFLAG==1)THEN !Skip the r2c file's information
      READ (90, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (90, *, END=999) 
     END DO
      READ (90, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINLONGWAVEFLAG==1)THEN
    READ (91, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (91, *, END=999) 
     END DO
      READ (91, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINRAINFLAG==1)THEN
    READ (92, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (92, *, END=999) 
     END DO
      READ (92, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINTEMPERATUREFLAG==1)THEN
    READ (93, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (93, *, END=999) 
     END DO
      READ (93, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINWINDFLAG==1)THEN
    READ (94, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (94, *, END=999) 
     END DO
      READ (94, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINPRESFLAG==1)THEN
    READ (95, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (95, *, END=999) 
     END DO
      READ (95, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINHUMIDITYFLAG==1)THEN
    READ (96, *, END=999) !:Frame line
     DO m = 1,YCOUNT
       READ (96, *, END=999) 
     END DO
      READ (96, *, END=999) !:EndFrame line
  ENDIF
  IF(BASINSHORTWAVEFLAG==2)THEN !Skip the csv file's information
    READ(90,*,END=999)
  ENDIF
  IF(BASINLONGWAVEFLAG==2)THEN
    READ(91,*,END=999)
  ENDIF
  IF(BASINRAINFLAG==2)THEN
    READ(92,*,END=999)
  ENDIF
  IF(BASINTEMPERATUREFLAG==2)THEN
    READ(93,*,END=999)
  ENDIF
  IF(BASINWINDFLAG==2)THEN
    READ(94,*,END=999)
  ENDIF
  IF(BASINPRESFLAG==2)THEN
    READ(95,*,END=999)
  ENDIF
  IF(BASINHUMIDITYFLAG==2)THEN
    READ(96,*,END=999)
  ENDIF
ENDDO
      

!> *********************************************************************
!> Open and print header information to the output files
!> *********************************************************************

OPEN(UNIT=70,FILE="./" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) // &
                  '/MESH_output_streamflow.csv')

OPEN(UNIT=71,FILE="./" // GENDIR_OUT(1:INDEX(GENDIR_OUT," ")-1) // &
                  '/MESH_output_streamflow_all.csv')

!> Set up the CLASSOF* files to print out into the correct directory
DO I=1, wf_num_points
  BNAM=op%DIR_OUT(i)
  OPEN(UNIT=150+i*10+1,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF1.csv")
  OPEN(UNIT=150+i*10+2,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF2.csv")
  OPEN(UNIT=150+i*10+3,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF3.csv")
  OPEN(UNIT=150+i*10+4,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF4.csv")
  OPEN(UNIT=150+i*10+5,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF5.csv")
  OPEN(UNIT=150+i*10+6,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF6.csv")
  OPEN(UNIT=150+i*10+7,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF7.csv")
  OPEN(UNIT=150+i*10+8,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF8.csv")
  OPEN(UNIT=150+i*10+9,FILE="./"//BNAM(1:INDEX(BNAM," ")-1)// &
   "/CLASSOF9.csv")

  DO j=1, 9
    WRITE(150+i*10+j,'("CLASS TEST RUN:     ",6A4)') TITLE1, &
                           TITLE2,TITLE3,TITLE4,TITLE5,TITLE6
    WRITE(150+i*10+j,'("RESEARCHER:         ",6A4)') NAME1, &
                           NAME2,NAME3,NAME4,NAME5,NAME6
    WRITE(150+i*10+j,'("INSTITUTION:        ",6A4)') PLACE1, &
                           PLACE2,PLACE3,PLACE4,PLACE5,PLACE6
  ENDDO

  WRITE(150+i*10+1,"('IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,SNOMLT,BEG,"// &
   "GTOUT,SNOACC(I),RHOSACC(I),WSNOACC(I),ALTOT,ROFACC(I),"// &
   "ROFOACC(I),ROFSACC(I),ROFBACC(I)')")
  WRITE(150+i*10+2,"('IDAY,IYEAR,"// &
   "TBARACC(I 1)-TFREZ,THLQACC(I 1),THICACC(I 1),"// &
   "TBARACC(I 2)-TFREZ,THLQACC(I 2),THICACC(I 2),"// &
   "TBARACC(I 3)-TFREZ,THLQACC(I 3),THICACC(I 3),"// &
   "TBARACC(I 4)-TFREZ,THLQACC(I 4),THICACC(I 4),"// &
   "TBARACC(I 5)-TFREZ,THLQACC(I 5),THICACC(I 5),"// &
   "TBARACC(I 6)-TFREZ,THLQACC(I 6),THICACC(I 6),"// &
   "TCN,RCANACC(I),SCANACC(I),TSN,ZSN')")
  WRITE(150+i*10+3,"('IDAY,IYEAR,FSINACC(I),FLINACC(I),"// &
   "TAACC(I)-TFREZ,UVACC(I),PRESACC(I),QAACC(I),PREACC(I),"// &
   "EVAPACC(I)')")
  WRITE(150+i*10+4,"('IHOUR,IMIN,IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,"// &
   "SNOMLT,BEG,GTOUT,SNOROW(I M),RHOSROW(I M),WSNOROW(I M),ALTOT,"// &
   "ROFROW(I M),TPN,ZPNDROW(I M)')")
  WRITE(150+i*10+5,"('IHOUR,IMIN,IDAY,IYEAR,"// &
   "TBARROW(I M 1)-TFREZ,THLQROW(I M 1),THICROW(I M 1),"// &
   "TBARROW(I M 2)-TFREZ,THLQROW(I M 2),THICROW(I M 2),"// &
   "TBARROW(I M 3)-TFREZ,THLQROW(I M 3),THICROW(I M 3),"// &
   "TBARROW(I M 4)-TFREZ,THLQROW(I M 4),THICROW(I M 4),"// &
   "TBARROW(I M 5)-TFREZ,THLQROW(I M 5),THICROW(I M 5),"// &
   "TBARROW(I M 6)-TFREZ,THLQROW(I M 6),THICROW(I M 6),"// &
   "TCN,cp%RCANROW(I M),SCANROW(I M),TSN,ZSN')")
  WRITE(150+i*10+6,"('IHOUR,IMIN,IDAY,FSDOWN(I),FDLGRD(I),"// &
   "PREGRD(I),TAGRD(I)-TFREZ,UVGRD(I),PRESGRD(I),QAGRD(I)')")
  WRITE(150+i*10+7,"('TROFROW(I M),TROOROW(I M),TROSROW(I M),"// &
   "TROBROW(I M),ROFROW(I M),ROFOROW(I M),ROFSROW(I M),"// &
   "ROFBROW(I M),FCS(I),FGS(I),FC(I),FG(I)')")
  WRITE(150+i*10+8,"('FSGVROW(I M),FSGSROW(I M),FSGGROW(I M),"// &
   "FLGVROW(I M),FLGSROW(I M),FLGGROW(I M),HFSCROW(I M),"// &
   "HFSSROW(I M),HFSGROW(I M),HEVCROW(I M),HEVSROW(I M),"// &
   "HEVGROW(I M),HMFCROW(I M),HMFNROW(I M),HMFGROW(I M 1),"// &
   "HMFGROW(I M 2),HMFGROW(I M 3),HTCCROW(I M),HTCSROW(I M),"// &
   "HTCROW(I M 1),HTCROW(I M 2),HTCROW(I M 3)')")
  WRITE(150+I*10+9,"('PCFCROW(I M),PCLCROW(I M),PCPNROW(I M),"// &
   "PCPGROW(I M),QFCFROW(I M),QFCLROW(I M),QFNROW(I M),QFGROW(I M),"// &
   "QFCROW(I M 1),QFCROW(I M 2),QFCROW(I M 3),ROFCROW(I M),"// &
   "ROFNROW(I M),ROFOROW(I M),ROFROW(I M),WTRCROW(I M),"// &
   "WTRSROW(I M),WTRGROW(I M)')")
ENDDO


!> *********************************************************************
!> Open and read in values from wfo_spec.txt file
!> *********************************************************************
!todo - check documentation of wfo_spec.txt file in our user's guide
!> ENSIM: Open wfo_spec.txt to read in which parameters to output
  OPEN(unit=56,file='wfo_spec.txt',status='old',iostat=ensim_ios)
!> IOSTAT returns 0 on successful file open
  IF(ensim_ios==0)THEN
    READ(56,*)
    READ(56,'(I5)',iostat=ios)nj
    READ(56,'(I5)',iostat=ios)ireport

!>        Allocate the necessary arrays
    ALLOCATE (wfo_pick(nj))
    ALLOCATE (wfo_attributes(nj))

    IF(ios/=0)THEN
      PRINT*,' Problem reading the first two lines of the'
      PRINT*,' wfo_spec.txt file'
      PRINT*
      STOP
    ENDIF
    PRINT*,' WFO_SPEC.TXT file found,'
    PRINT*,' The following EnSim output will be written:'

    DO j=1,nj
      READ(56,'(i1,5x,a50)',iostat=ios)wfo_pick(j), &
        wfo_attributes(j)
!>          IOSTAT returns 0 on successful file open
      IF(ios/=0)THEN
        PRINT*,'iostat code =',ios
        PRINT*,' Read to line ',j,' in wfo_spec.txt'
        PRINT*,' then a problem was found'
        STOP
      ENDIF
      IF(wfo_pick(j)==1)THEN
        PRINT*,wfo_attributes(j)
      ENDIF
    ENDDO
    CLOSE(unit=56,status='keep')
  ELSE
    PRINT*,'WFO_SPEC.TXT file not found, no EnSim output'// &
           ' will be written'
  ENDIF
  PRINT *


!>>>>>>>>>>>>>>>>>> AB:  ENSIM HEADERS

!>         WRITE THE HEADER FOR ENSIM FILES:

IF(ensim_ios==0)THEN
 CALL write_both_headers('UTM     ',XCOUNT,YCOUNT,3000.0, &
         477000.0,6699000.0,NMTEST,jan,wfo_pick,wf_landclassname, &
         NTYPE,currec)
ENDIF

!> For the ENSIM timestamp
wfo_seq=0

!> End of ENSIM Changes




!> *********************************************************************
!> Output information to screen
!> *********************************************************************

PRINT *, 'NUMBER OF GRID SQUARES: ',NA
	PRINT *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NMTEST
	PRINT *, 'NUMBER OF RIVER CLASSES: ', NRVR
	PRINT *, 'MINIMUM NUMBER FOR ILG: ',NA*NMTEST
PRINT *, 'NUMBER OF GRID SQUARES IN West-East DIRECTION: ', XCOUNT
PRINT *, 'NUMBER OF GRID SQUARES IN South-North DIRECTION: ', YCOUNT
PRINT *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', AL
	PRINT *, 'NUMBER OF DRAINAGE OUTLETS: ', NAA

	PRINT *, 'NUMBER OF STREAMFLOW GUAGES: ', WF_NO
DO I=1,WF_NO
  PRINT *,'STREAMFLOW STATION: ',I,'I: ',WF_IY(I),'J: ',WF_JX(I)
ENDDO
PRINT *, 'NUMBER OF RESERVOIR STATIONS: ', WF_NORESV
IF( WF_NORESV>0 ) THEN
  DO I=1,WF_NORESV
 PRINT *,'RESERVOIR STATION: ',I,'I: ',WF_IRES(I),'J: ',WF_JRES(I)
  ENDDO
ENDIF


PRINT *
PRINT *, 'Found these output locations:'
PRINT *, 'Output Directory, grid number, land class number'
DO I=1, WF_NUM_POINTS
  PRINT *, op%DIR_OUT(I),op%N_OUT(I),op%II_OUT(I)
ENDDO

PRINT *
PRINT *
PRINT *
IF(PREEMPTIONFLAG == 1)THEN
  WRITE(6,*)"================================================="
  WRITE (6,*)
  PRINT*,"     SA_MESH IS RUNNING IN AUTOCALIBRATION MODE"
  WRITE (6,*)
  PRINT*,"                USING PRE-EMPTION"
  WRITE (6,*)
  WRITE(6,*)"================================================="
  WRITE (6,*)
ENDIF
PRINT *
IF(TESTCSVFLAG == 1)THEN
    PRINT*,"TEST PROPER DISTRIBUTION OF CSV FORCING DATA" 
ELSE
    PRINT *
    PRINT *, 'DONE INTITIALIZATION'
    PRINT *
    WRITE (6, *) "STARTING MESH (PRECIP, EVAP, ", &
          "RUNOFF)"
ENDIF

!> *********************************************************************
!> Call CLASSB to set more CLASS variables
!> *********************************************************************
!> bjd - July 25, 2005: For inputting field measured soil properties.

IF(SOILINIFLAG == 0) THEN

  CALL CLASSB(THPROW,THRROW,THMROW,BIROW,PSISROW,GRKSROW, &
            THRAROW,HCPSROW,TCSROW,THFCROW,PSIWROW, &
            DLZWROW,ZBTWROW,ALGWROW,ALGDROW, &
            cp%SANDROW,cp%CLAYROW,cp%ORGMROW,sl%DELZ,sl%ZBOT, &
            cp%SDEPROW,ISNDROW, &
            IORG,NA,NTYPE,NA,NMTEST,IGND)

ELSE
!todo : change this to use sv instead of a bunch of the parts thereof
  CALL CLASSBHYD(THPROW,THRROW,THMROW,BIROW,PSISROW,GRKSROW, &
            THRAROW,HCPSROW,TCSROW,THFCROW,PSIWROW, &
            DLZWROW,ZBTWROW,ALGWROW,ALGDROW, &
            cp%SANDROW,cp%CLAYROW,cp%ORGMROW,sl%DELZ,sl%ZBOT, &
            cp%SDEPROW,ISNDROW, &
            IORG,NA,NTYPE,NA,NMTEST,IGND,sv%wc_thpor,sv%wc_thlret, &
            sv%wc_thlmin,sv%wc_bi,sv%wc_psisat,sv%wc_grksat, &
            sv%wc_hcps,sv%wc_tcs,sv%wc_algwet,sv%wc_algdry)

ENDIF
!>
!>*******************************************************************
!>
!> Check if we are reading in a resume file
IF (RESUMEFLAG /= 0) THEN
  PRINT *, 'Reading saved state variables'
call resume_state( &
   HOURLYFLAG, IMIN, IMIN2, &
   BASINSHORTWAVEFLAG, BASINLONGWAVEFLAG, &
   BASINRAINFLAG, BASINTEMPERATUREFLAG, &
   BASINWINDFLAG, BASINPRESFLAG, BASINHUMIDITYFLAG, &
   FSDOWN, FSVHGRD, FSIHGRD, FDLGRD, &
   I, J, XCOUNT, YCOUNT, jan, &
   VPDGRD, TADPGRD, PADRGRD, RHOAGRD, RHSIGRD, &
   RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, TAGRD, &
   QAGRD, PREGRD, RPREGRD, SPREGRD, PRESGRD, &

!> MAM - FOR FORCING DATA INTERPOLATION
   FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
   TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &

   IPCP, NA, NA, ILMOS, JLMOS, IWMOS, JWMOS, &
   IWAT, IICE, NML, NMW, NWAT, NICE, &
   cp%GCGRD, cp%FAREROW, cp%MIDROW, NTYPE, ILG, NMTEST, &
   TBARGAT, THLQGAT, THICGAT, TPNDGAT, ZPNDGAT, &
   TBASGAT, ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, &
   TCANGAT, RCANGAT, SCANGAT, GROGAT, CMAIGAT, &
   FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
   PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
   VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
   HGTDGAT, ACVDGAT, ACIDGAT, TSFSGAT, WSNOGAT, &
   THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
   GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
   PSIWGAT, DLZWGAT, ZBTWGAT, ZSNLGAT, ZPLGGAT, &
   ZPLSGAT, TACGAT, QACGAT, DRNGAT, XSLPGAT, &
   XDGAT, WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, &
   ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ISNDGAT, &
   RADJGAT, ZBLDGAT, Z0ORGAT, ZRFMGAT, ZRFHGAT, &
   ZDMGAT, ZDHGAT, FSVHGAT, FSIHGAT, CSZGAT, &
   FDLGAT, ULGAT, VLGAT, TAGAT, QAGAT, PRESGAT, &
   PREGAT, PADRGAT, VPDGAT, TADPGAT, RHOAGAT, &
   RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
   FCLOGAT, DLONGAT, GGEOGAT, CDHGAT, CDMGAT, &
   HFSGAT, TFXGAT, QEVPGAT, QFSGAT, QFXGAT, &
   PETGAT, GAGAT, EFGAT, GTGAT, QGGAT, TSFGAT, &
   ALVSGAT, ALIRGAT, SFCTGAT, SFCUGAT, SFCVGAT, &
   SFCQGAT, FSNOGAT, FSGVGAT, FSGSGAT, FSGGGAT, &
   FLGVGAT, FLGSGAT, FLGGGAT, HFSCGAT, HFSSGAT, &
   HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, HMFCGAT, &
   HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, &
   PCPNGAT, PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, &
   QFCFGAT, ROFGAT, ROFOGAT, ROFSGAT, ROFBGAT, &
   TROFGAT, TROOGAT, TROSGAT, TROBGAT, ROFCGAT, &
   ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, WTRGGAT, &
   DRGAT, HMFGGAT, HTCGAT, QFCGAT, ITCTGAT, &
   IGND, ICAN, ICP1, &
   cp%TBARROW, cp%THLQROW, cp%THICROW, cp%TPNDROW, cp%ZPNDROW, &
   TBASROW, cp%ALBSROW, cp%TSNOROW, cp%RHOSROW, cp%SNOROW, &
   cp%TCANROW, cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, &
   cp%FCANROW, cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
   cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, cp%QA50ROW, &
   cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, cp%PSGBROW, PAIDROW, &
   HGTDROW, ACVDROW, ACIDROW, TSFSROW, WSNOROW, &
   THPROW, THRROW, THMROW, BIROW, PSISROW, &
   GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
   PSIWROW, DLZWROW, ZBTWROW, hp%ZSNLROW, hp%ZPLGROW, &
   hp%ZPLSROW, TACROW, QACROW, cp%DRNROW, cp%XSLPROW, &
   cp%XDROW, WFSFROW, cp%KSROW, ALGWROW, ALGDROW, &
   ASVDROW, ASIDROW, AGVDROW, AGIDROW, &
   ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
   cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, CSZGRD, &
   ULGRD, VLGRD, FCLOGRD, DLONGRD, GGEOGRD, &
   cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
   CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
   WTVSTP, WTSSTP, WTGSTP, &
   sl%DELZ, FCS, FGS, FC, FG, N, &
   ALVSCN, ALIRCN, ALVSG, ALIRG, ALVSCS, &
   ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, &
   ALVSSC, ALIRSC, TRVSCN, TRIRCN, TRVSCS, &
   TRIRCS, FSVF, FSVFS, &
   RAICAN, RAICNS, SNOCAN, SNOCNS, &
   FRAINC, FSNOWC, FRAICS, FSNOCS, &
   DISP, DISPS, ZOMLNC, ZOMLCS, ZOELNC, ZOELCS, &
   ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
   CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, &
   CWFCAP, CWLCPS, CWFCPS, RC, RCS, RBCOEF, &
   FROOT, ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, &
   TRSNOW, ZSNOW, IDAY, JLAT, IDISP, &
   IZREF, IWF, IPAI, IHGT, IALC, IALS, IALG, &
   TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
   THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, &
   TCTOPG, TCBOTG, &
   GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
   G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
   QFREZC, QFREZG, QMELTC, QMELTG, &
   EVAPC, EVAPCG,EVAPG, EVAPCS, EVPCSG, EVAPGS, &
   TCANO, TCANS, TPONDC, TPONDG, TPNDCS, TPNDGS, &
   TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
   WTABGAT, &
   ILMOGAT, UEGAT, HBLGAT, &
   ILW, ITC, ITCG, ITG, ISLFD, &
   NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
   GFLXGAT, CDHROW, CDMROW, HFSROW, TFXROW, &
   QEVPROW, QFSROW, QFXROW, PETROW, GAROW, &
   EFROW, GTROW, QGROW, TSFROW, ALVSROW, &
   ALIRROW, SFCTROW, SFCUROW, SFCVROW, SFCQROW, &
   FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
   FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, &
   HEVSROW, HEVGROW, HMFCROW, HMFNROW, HTCCROW, &
   HTCSROW, PCFCROW, PCLCROW, PCPNROW, PCPGROW, &
   QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, &
   ROFOROW, ROFSROW, ROFBROW, TROFROW, TROOROW, &
   TROSROW, TROBROW, ROFCROW, ROFNROW, ROVGROW, &
   WTRCROW, WTRSROW, WTRGROW, DRROW, WTABROW, &
   ILMOROW, UEROW, HBLROW, HMFGROW, HTCROW, &
   QFCROW, FSNOROW, ITCTROW, NCOUNT, ireport, &
   wfo_seq, IYEAR, ensim_MONTH, ensim_DAY, &
   IHOUR, XXX, YYY, NA, &
   NTYPE, DELT, TFREZ, UVGRD, SBC, RHOW, CURREC, &
   M_C, M_S, M_R, &

     WF_ROUTETIMESTEP,WF_R1,WF_R2,NAA,IYMIN, &
     WF_IYMAX,JXMIN,WF_JXMAX,WF_IBN,WF_IROUGH, &
     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE, &
     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE,WF_ELEV,FRAC, &
     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX, &
     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R, &
     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME, &
     WF_B1,WF_B2,WF_QREL, WF_QR, &
     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2, &
     WF_STORE1,WF_STORE2, &
     DRIVERTIMESTEP,ROFGRD, &
     WF_S, &

  TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
  FINAL_STORE, TOTAL_AREA)
ENDIF

CALL GATPREP(ILMOS,JLMOS,IWMOS,JWMOS,IWAT,IICE, &
             NML,NMW,NWAT,NICE,cp%GCGRD,cp%FAREROW,cp%MIDROW, &
             NA,NTYPE,ILG,1,NA,NMTEST)

!> *********************************************************************
!> MAM - Initialize ENDDATE and ENDDATA
!> *********************************************************************
ENDDATE = .FALSE.
ENDDATA = .FALSE.

!> *********************************************************************
!> MAM - Read in initial meteorological forcing data
!> *********************************************************************
IF(INTERPOLATIONFLAG == 0)THEN
    CALL READ_FORCING_DATA(YCOUNT,XCOUNT,NTYPE,NA,NML,ILMOS,JLMOS,YYY,XXX,ENDDATA,cp%FAREROW, &
                           FSDOWN,FSVHGRD,FSIHGRD,FDLGRD,PREGRD,TAGRD,ULGRD,PRESGRD,QAGRD, &
                           FSVHGAT, FSIHGAT, FDLGAT, PREGAT, TAGAT, ULGAT, PRESGAT, QAGAT)
ELSEIF(INTERPOLATIONFLAG == 1)THEN
    IF(RESUMEFLAG == 0)THEN
        CALL READ_FORCING_DATA(YCOUNT,XCOUNT,NTYPE,NA,NML,ILMOS,JLMOS,YYY,XXX,ENDDATA,cp%FAREROW, &
                           FSDOWN,FSVHGRD,FSIHGRD,FDLGRD,PREGRD,TAGRD,ULGRD,PRESGRD,QAGRD, &
                           FSVHGATPRE,FSIHGATPRE,FDLGATPRE,PREGATPRE,TAGATPRE,ULGATPRE, &
                           PRESGATPRE,QAGATPRE)
        CALL READ_FORCING_DATA(YCOUNT,XCOUNT,NTYPE,NA,NML,ILMOS,JLMOS,YYY,XXX,ENDDATA,cp%FAREROW, &
                               FSDOWN,FSVHGRD,FSIHGRD,FDLGRD,PREGRD,TAGRD,ULGRD,PRESGRD,QAGRD, &
                               FSVHGATPST,FSIHGATPST,FDLGATPST,PREGATPST,TAGATPST,ULGATPST, &
                               PRESGATPST,QAGATPST)
    ELSE
        CALL READ_FORCING_DATA(YCOUNT,XCOUNT,NTYPE,NA,NML,ILMOS,JLMOS,YYY,XXX,ENDDATA,cp%FAREROW, &
                               FSDOWN,FSVHGRD,FSIHGRD,FDLGRD,PREGRD,TAGRD,ULGRD,PRESGRD,QAGRD, &
                               FSVHGATPST,FSIHGATPST,FDLGATPST,PREGATPST,TAGATPST,ULGATPST, &
                               PRESGATPST,QAGATPST)
    ENDIF
ENDIF

!> *********************************************************************
!> MAM - INITIALIZE OR READ PRE-EMPTION VALUE
!> *********************************************************************
IF(PREEMPTIONFLAG == 1)THEN
  INQUIRE(FILE="pre_emption_value.txt", EXIST = EXISTS)
  IF(EXISTS)THEN
    OPEN(100,FILE="pre_emption_value.txt")
    READ(100,*)SAEPRE
    CLOSE(100)
  ELSE
    SAEPRE = +1.0e+10
  ENDIF
ENDIF
NCAL  = 0
VLGRD = 0.0
VLGAT = 0.0

!> *********************************************************************
!> Start of main loop that is run each half hour
!> *********************************************************************
DO WHILE(.NOT.ENDDATE .AND. .NOT.ENDDATA)

!* N: is only used for debugging purposes.
!> N is incremented at the beginning of each loop. so you can tell which
!> iteration of the loop you are on by what the value of N is. 
!> N is printed out with each of the error messages in CLASSZ.
N=N+1

!> MAM - Linearly interpolate forcing data for intermediate time steps
IF(INTERPOLATIONFLAG == 1)THEN
    TRATIO     = MIN(1.0, FLOAT(IMIN2) / HOURLYFLAG)
    FSVHGAT    = FSVHGATPRE   + TRATIO *(FSVHGATPST   - FSVHGATPRE)
    FSIHGAT    = FSIHGATPRE   + TRATIO *(FSIHGATPST   - FSIHGATPRE)
    FDLGAT     = FDLGATPRE    + TRATIO *(FDLGATPST    - FDLGATPRE)
    PREGAT     = PREGATPRE    + TRATIO *(PREGATPST    - PREGATPRE)
    TAGAT      = TAGATPRE     + TRATIO *(TAGATPST     - TAGATPRE)
    ULGAT      = ULGATPRE     + TRATIO *(ULGATPST     - ULGATPRE)
    PRESGAT    = PRESGATPRE   + TRATIO *(PRESGATPST   - PRESGATPRE)
    QAGAT      = QAGATPRE     + TRATIO *(QAGATPST     - QAGATPRE)

!> INTERPOLATE GRD VARIABLES
    DO K = 1, NML
       FSVHGRD(ILMOS(K)) = FSVHGAT(K)
       FSIHGRD(ILMOS(K)) = FSIHGAT(K)
       FDLGRD (ILMOS(K)) = FDLGAT (K)
       ULGRD  (ILMOS(K)) = ULGAT  (K)
       TAGRD  (ILMOS(K)) = TAGAT  (K)
       QAGRD  (ILMOS(K)) = QAGAT  (K)
       PRESGRD(ILMOS(K)) = PRESGAT(K)
       PREGRD (ILMOS(K)) = PREGAT (K)
    ENDDO
    FSDOWN = 2.0*FSVHGRD
    
ENDIF
UVGRD=MAX(VMIN,ULGRD)

!> *********************************************************************
!> Read in current reservoir release value
!> *********************************************************************

!> only read in current value if we are on the correct time step
!> however put in an exception if this is the first time through (ie. jan=1),
!> otherwise depending on the hour of the first time step
!> there might not be any data in wf_qrel, wf_qhyd
!> make sure we have a controlled reservoir (if not the mod(IHOUR,wf_ktr)
!> may give an error. Frank S Jun 2007
IF(WF_NORESV_CTRL>0) THEN
  IF(MOD(IHOUR,WF_KTR)==0.AND.IMIN==0) THEN
!>        READ in current reservoir value
    READ(21,'(100F10.3)',IOSTAT=IOS)(WF_QREL(I), &
		I=1,WF_NORESV_CTRL)
    IF(IOS/=0) THEN
      PRINT *, 'ran out of reservoir data before met data'
      STOP
	    ENDIF
  ELSE
    IF (JAN==1.AND.WF_NORESV_CTRL>0) THEN
      READ(21,'(100F10.3)',IOSTAT=IOS)(WF_QREL(I), &
	      I=1,WF_NORESV_CTRL)
      REWIND 21
      READ(21,*)
      DO I=1,WF_NORESV
        READ(21,*)
   	      ENDDO
    ENDIF
  ENDIF
ENDIF

! *********************************************************************
!> Read in current streamflow value
!> *********************************************************************

!> only read in current value if we are on the correct time step
!> also read in the first value if this is the first time through
IF(MOD(IHOUR,WF_KT)==0.AND.IMIN==0 .AND. JAN > 1) THEN
!>       read in current streamflow value
  READ(22,'(100F10.3)',IOSTAT=IOS) (WF_QHYD(I),I=1,WF_NO)
  IF(IOS/=0) THEN
    PRINT *, 'ran out of streamflow data before met data'
	STOP
  ENDIF
ENDIF

!> *********************************************************************
!> Set some more CLASS parameters
!> *********************************************************************

!> This estimates the fractional cloud cover (FCLOGRD) by the basis
!>  of the solar zenith angle and the occurrence of precipitation.
!>  Assumed to be 1 (100%) when precipitation occurs and somewhere
!>  in the range of [0.1,1] based on the location of the sun in the
!>  sky when precipitation is not occuring. (0.1 when the sun is at
!>  the zenith, 1 when the sun is at the horizon).
RDAY=REAL(IDAY)+(REAL(IHOUR)+REAL(IMIN)/60.)/24.
DECL=SIN(2.*PI*(284.+RDAY)/365.)*23.45*PI/180.
HOUR=(REAL(IHOUR)+REAL(IMIN)/60.)*PI/12.-PI
COSZ=SIN(RADJGRD(1))*SIN(DECL)+COS(RADJGRD(1))*COS(DECL)*COS(HOUR)

DO I=1,NA
  CSZGRD(I)=SIGN(MAX(ABS(COSZ),1.0E-3),COSZ)
  IF(PREGRD(I)>0.) THEN
    XDIFFUS(I)=1.0
  ELSE
    XDIFFUS(I)=MAX(0.0,MIN(1.0-0.9*COSZ,1.0))
  ENDIF
  FCLOGRD(I)=XDIFFUS(I)
ENDDO

CALL GATPREP(ILMOS,JLMOS,IWMOS,JWMOS,IWAT,IICE, &
             NML,NMW,NWAT,NICE,cp%GCGRD,cp%FAREROW,cp%MIDROW, &
             NA,NTYPE,ILG,1,NA,NMTEST)

!> *********************************************************************
!> Test proper distribution of csv forcing data
!> *********************************************************************
IF(TESTCSVFLAG==1)THEN
   IF(HOURLYFLAG == 30 .OR. IMIN2 == 0) &
   WRITE(*,'(I4,1X,I3,1X,I2,1X,I2)')IYEAR,IDAY,IHOUR,IMIN
ELSE   

!> *********************************************************************
!> Start of calls to CLASS subroutines
!> *********************************************************************

CALL CLASSG (TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
             TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT, &
             TCANGAT,RCANGAT,SCANGAT,GROGAT, CMAIGAT, &
             FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT, &
             PAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT, &
             VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,PAIDGAT, &
             HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT, &
             THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT, &
             GRKSGAT,THRAGAT,HCPSGAT,TCSGAT, &
             THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT, &
             ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT, &
             DRNGAT, XSLPGAT,XDGAT,WFSFGAT,KSGAT, &
             ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT, &
             AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT, &
             ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT, &
             FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT, &
             TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT, &
             VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT, &
             SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT, &
             GGEOGAT, &
             CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
             QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT, &
             GTGAT,  QGGAT,  TSFGAT, ALVSGAT,ALIRGAT, &
             SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT, &
             FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
             FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
             HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
             HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
             QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT, &
             ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
             TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
             WTRCGAT,WTRSGAT,WTRGGAT,DRGAT, GFLXGAT, &
             HMFGGAT,HTCGAT, QFCGAT, ITCTGAT, &
             ILMOS,JLMOS,IWMOS,JWMOS,NML,NA,NTYPE, &
             NA*NTYPE,IGND,ICAN,ICP1,cp%TBARROW,cp%THLQROW, &
             cp%THICROW,cp%TPNDROW,cp%ZPNDROW,TBASROW,cp%ALBSROW, &
             cp%TSNOROW,cp%RHOSROW,cp%SNOROW,cp%TCANROW, &
             cp%RCANROW,cp%SCANROW,cp%GROROW, CMAIROW,cp%FCANROW, &
             cp%LNZ0ROW,cp%ALVCROW,cp%ALICROW,cp%PAMXROW, &
             cp%PAMNROW,cp%CMASROW,cp%ROOTROW,cp%RSMNROW, &
             cp%QA50ROW,cp%VPDAROW,cp%VPDBROW,cp%PSGAROW, &
             cp%PSGBROW,PAIDROW,HGTDROW,ACVDROW,ACIDROW,TSFSROW, &
             WSNOROW, THPROW, THRROW, THMROW, BIROW,  PSISROW, &
             GRKSROW,THRAROW,HCPSROW,TCSROW, &
             THFCROW,PSIWROW,DLZWROW,ZBTWROW, &
             hp%ZSNLROW,hp%ZPLGROW,hp%ZPLSROW,TACROW, QACROW, &
             cp%DRNROW, cp%XSLPROW,cp%XDROW,WFSFROW,cp%KSROW, &
             ALGWROW,ALGDROW,ASVDROW,ASIDROW,AGVDROW, &
             AGIDROW,ISNDROW,RADJGRD,cp%ZBLDGRD,Z0ORGRD, &
             cp%ZRFMGRD,cp%ZRFHGRD,ZDMGRD, ZDHGRD, FSVHGRD, &
             FSIHGRD,CSZGRD, FDLGRD, ULGRD,  VLGRD, &
             TAGRD,  QAGRD,  PRESGRD,PREGRD, PADRGRD, &
             VPDGRD, TADPGRD,RHOAGRD,RPCPGRD,TRPCGRD, &
             SPCPGRD,TSPCGRD,RHSIGRD,FCLOGRD,DLONGRD, &
             GGEOGRD,cp%MANNROW,MANNGAT,cp%DDROW,DDGAT)

CALL CLASSI(VPDGAT,TADPGAT,PADRGAT,RHOAGAT,RHSIGAT, &
            RPCPGAT,TRPCGAT,SPCPGAT,TSPCGAT,TAGAT,QAGAT, &
            PREGAT,PRESGAT, &
            IPCP,NML,1,NA)

!> Calculate initial storage (after reading in resume.txt file if applicable)
IF(JAN==1) THEN
  INIT_STORE=0.0
  DO I=1,NA
  DO M=1,NMTEST
    IF(FRAC(I)>0.0)THEN
      INIT_STORE=INIT_STORE+(cp%RCANROW(I,M)+cp%SCANROW(I,M) &
      +cp%SNOROW(I,M)+(cp%THLQROW(I,M,1)*RHOW+cp%THICROW(I,M,1) &
      *RHOICE)*DLZWROW(I,M,1)+cp%ZPNDROW(I,M)*RHOW &
      +(cp%THLQROW(I,M,2)*RHOW+cp%THICROW(I,M,2)*RHOICE) &
      *DLZWROW(I,M,2)+(cp%THLQROW(I,M,3)*RHOW+cp%THICROW(I,M,3) &
      *RHOICE)*DLZWROW(I,M,3))*cp%FAREROW(I,M)
	    ENDIF
  ENDDO
  ENDDO
ENDIF

!> ========================================================================
CALL CLASSZ (0,      CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
             WTVSTP, WTSSTP, WTGSTP, &
             FSGVGAT,FLGVGAT,HFSCGAT,HEVCGAT,HMFCGAT,HTCCGAT, &
             FSGSGAT,FLGSGAT,HFSSGAT,HEVSGAT,HMFNGAT,HTCSGAT, &
             FSGGGAT,FLGGGAT,HFSGGAT,HEVGGAT,HMFGGAT,HTCGAT, &
             PCFCGAT,PCLCGAT,QFCFGAT,QFCLGAT,ROFCGAT,WTRCGAT, &
             PCPNGAT,QFNGAT, ROFNGAT,WTRSGAT,PCPGGAT,QFGGAT, &
             QFCGAT, ROFGAT, WTRGGAT,CMAIGAT,RCANGAT,SCANGAT, &
             TCANGAT,SNOGAT, WSNOGAT,TSNOGAT,THLQGAT,THICGAT, &
             HCPSGAT,THPGAT, DLZWGAT,TBARGAT,ZPNDGAT,TPNDGAT, &
             sl%DELZ,   FCS,    FGS,    FC,     FG, &
             1,      NML,    ILG,    IGND,   N    )
!> ========================================================================
!> ALBEDO AND TRANSMISSIVITY CALCULATIONS; GENERAL VEGETATION
!> CHARACTERISTICS.

CALL CLASSA    (FC,     FG,     FCS,    FGS,    ALVSCN, ALIRCN, &
                ALVSG,  ALIRG,  ALVSCS, ALIRCS, ALVSSN, ALIRSN, &
                ALVSGC, ALIRGC, ALVSSC, ALIRSC, TRVSCN, TRIRCN, &
                TRVSCS, TRIRCS, FSVF,   FSVFS, &
                RAICAN, RAICNS, SNOCAN, SNOCNS, FRAINC, FSNOWC, &
                FRAICS, FSNOCS, &
                DISP,   DISPS,  ZOMLNC, ZOMLCS, &
                ZOELNC, ZOELCS, ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
                CHCAP,  CHCAPS, CMASSC, CMASCS, CWLCAP, CWFCAP, &
                CWLCPS, CWFCPS, RC,     RCS,    RBCOEF, FROOT, &
                ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TRSNOW, ZSNOW, &
                WSNOGAT,ALVSGAT,ALIRGAT,HTCCGAT,HTCSGAT,HTCGAT, &
                WTRCGAT,WTRSGAT,WTRGGAT,CMAIGAT,FSNOGAT, &
                FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT,PAMNGAT, &
                CMASGAT,ROOTGAT,RSMNGAT,QA50GAT,VPDAGAT,VPDBGAT, &
                PSGAGAT,PSGBGAT,PAIDGAT,HGTDGAT,ACVDGAT,ACIDGAT, &
                ASVDGAT,ASIDGAT,AGVDGAT,AGIDGAT,ALGWGAT,ALGDGAT, &
                THLQGAT,THICGAT,TBARGAT,RCANGAT,SCANGAT,TCANGAT, &
                GROGAT, SNOGAT, TSNOGAT,RHOSGAT,ALBSGAT,ZBLDGAT, &
                Z0ORGAT,ZSNLGAT,ZPLGGAT,ZPLSGAT, &
                FCLOGAT,TAGAT,  VPDGAT, RHOAGAT,CSZGAT, &
                FSVHGAT,RADJGAT,DLONGAT,RHSIGAT,sl%DELZ,DLZWGAT, &
                ZBTWGAT,THPGAT, THMGAT, PSISGAT,BIGAT,  PSIWGAT, &
                HCPSGAT,ISNDGAT,IDAY,   ILG,    1,      NML, &
                JLAT,N, ICAN,   ICAN+1, IGND,   IDISP,  IZREF, &
                IWF,    IPAI,   IHGT,   IALC,   IALS,   IALG  )
!
!-----------------------------------------------------------------------
!          * SURFACE TEMPERATURE AND FLUX CALCULATIONS.
!
CALL  CLASST     (TBARC,  TBARG,  TBARCS, TBARGS, THLIQC, THLIQG, &
  THICEC, THICEG, HCPC,   HCPG,   TCTOPC, TCBOTC, TCTOPG, TCBOTG, &
  GZEROC, GZEROG, GZROCS, GZROGS, G12C,   G12G,   G12CS,  G12GS, &
  G23C,   G23G,   G23CS,  G23GS,  QFREZC, QFREZG, QMELTC, QMELTG, &
  EVAPC,  EVAPCG, EVAPG,  EVAPCS, EVPCSG, EVAPGS, TCANO,  TCANS, &
  RAICAN, SNOCAN, RAICNS, SNOCNS, CHCAP,  CHCAPS, TPONDC, TPONDG, &
  TPNDCS, TPNDGS, TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
  ITCTGAT,CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT,QFSGAT, QFXGAT, &
  PETGAT, GAGAT,  EFGAT,  GTGAT,  QGGAT,  TSFGAT, SFCTGAT,SFCUGAT, &
  SFCVGAT,SFCQGAT,FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT,FLGGGAT, &
  HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT,HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT, &
  HTCCGAT,HTCSGAT,HTCGAT, QFCFGAT,QFCLGAT,DRGAT,  WTABGAT,ILMOGAT, &
  UEGAT,  HBLGAT, TACGAT, QACGAT, ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, &
  VPDGAT, TADPGAT,RHOAGAT,FSVHGAT,FSIHGAT,FDLGAT, ULGAT,  VLGAT, &
  TAGAT,  QAGAT,  PADRGAT,FC,     FG,     FCS,    FGS,    RBCOEF, &
  FSVF,   FSVFS,  ALVSCN, ALIRCN, ALVSG,  ALIRG, &
  ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, ALIRSC, &
  TRVSCN, TRIRCN, TRVSCS, TRIRCS, RC,     RCS, WTRGGAT, &
  FRAINC, FSNOWC, FRAICS, FSNOCS, CMASSC, CMASCS, DISP,   DISPS, &
  ZOMLNC, ZOELNC, ZOMLNG, ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS, &
  TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT,TBASGAT,TCANGAT,TSNOGAT, &
  ZSNOW,  TRSNOW, RHOSGAT,WSNOGAT,THPGAT, THRGAT, THMGAT, THFCGAT, &
  RADJGAT,PREGAT, HCPSGAT,TCSGAT, TSFSGAT,sl%DELZ,DLZWGAT,ZBTWGAT, &
  FTEMP,  FVAP,   RIB, &
   ISNDGAT,ITC,    ITCG,   ITG,   ILG,    1,NML,  JLAT,N, ICAN, &
  IGND,   IZREF,  ISLFD,  NLANDCS,NLANDGS,NLANDC, NLANDG, NLANDI)
!
!-----------------------------------------------------------------------
!          * WATER BUDGET CALCULATIONS.
!
    CALL CLASSW  (THLQGAT,THICGAT,TBARGAT,TCANGAT,RCANGAT,SCANGAT, &
                  ROFGAT, TROFGAT,SNOGAT, TSNOGAT,RHOSGAT,ALBSGAT, &
                  WSNOGAT,ZPNDGAT,TPNDGAT,GROGAT, TBASGAT,GFLXGAT, &
                  PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT,QFCFGAT,QFCLGAT, &
                  QFNGAT, QFGGAT, QFCGAT, HMFCGAT,HMFGGAT,HMFNGAT, &
                  HTCCGAT,HTCSGAT,HTCGAT, ROFCGAT,ROFNGAT,ROVGGAT, &
                  WTRSGAT,WTRGGAT,ROFOGAT,ROFSGAT,ROFBGAT, &
                  TROOGAT,TROSGAT,TROBGAT,QFSGAT, &
                  TBARC,  TBARG,  TBARCS, TBARGS, THLIQC, THLIQG, &
                  THICEC, THICEG, HCPC,   HCPG,   RPCPGAT,TRPCGAT, &
                  SPCPGAT,TSPCGAT,PREGAT, TAGAT,  RHSIGAT,GGEOGAT, &
                  FC,     FG,     FCS,    FGS,    TPONDC, TPONDG, &
                  TPNDCS, TPNDGS, EVAPC,  EVAPCG, EVAPG,  EVAPCS, &
                  EVPCSG, EVAPGS, QFREZC, QFREZG, QMELTC, QMELTG, &
                  RAICAN, SNOCAN, RAICNS, SNOCNS, FROOT,  FSVF, &
                  FSVFS,  CWLCAP, CWFCAP, CWLCPS, CWFCPS, TCANO, &
                  TCANS,  CHCAP,  CHCAPS, CMASSC, CMASCS, ZSNOW, &
                  GZEROC, GZEROG, GZROCS, GZROGS, G12C,   G12G, &
                  G12CS,  G12GS,  G23C,   G23G,   G23CS,  G23GS, &
                  TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
                  ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TSFSGAT, &
                  TCTOPC, TCBOTC, TCTOPG, TCBOTG, &
                  THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT,GRKSGAT, &
                  THRAGAT,THFCGAT,DRNGAT, HCPSGAT,sl%DELZ, &
                  DLZWGAT,ZBTWGAT,XSLPGAT,XDGAT,WFSFGAT,KSGAT, &
                  ISNDGAT,IWF,    NA*NTYPE,    1,      NML, N, &
                  JLAT,   ICAN,   IGND,   IGND+1, IGND+2, &
                  NLANDCS,NLANDGS,NLANDC, NLANDG,NLANDI, &
                  MANNGAT,DDGAT)
!
!========================================================================
!
CALL CLASSZ (1,      CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
             WTVSTP, WTSSTP, WTGSTP, &
             FSGVGAT,FLGVGAT,HFSCGAT,HEVCGAT,HMFCGAT,HTCCGAT, &
             FSGSGAT,FLGSGAT,HFSSGAT,HEVSGAT,HMFNGAT,HTCSGAT, &
             FSGGGAT,FLGGGAT,HFSGGAT,HEVGGAT,HMFGGAT,HTCGAT, &
             PCFCGAT,PCLCGAT,QFCFGAT,QFCLGAT,ROFCGAT,WTRCGAT, &
             PCPNGAT,QFNGAT, ROFNGAT,WTRSGAT,PCPGGAT,QFGGAT, &
             QFCGAT, ROFGAT, WTRGGAT,CMAIGAT,RCANGAT,SCANGAT, &
             TCANGAT,SNOGAT, WSNOGAT,TSNOGAT,THLQGAT,THICGAT, &
             HCPSGAT,THPGAT, DLZWGAT,TBARGAT,ZPNDGAT,TPNDGAT, &
             sl%DELZ,   FCS,    FGS,    FC,     FG, &
             1,      NML,    ILG,    IGND,   N    )
!
!=======================================================================

CALL CLASSS (cp%TBARROW,cp%THLQROW,cp%THICROW,cp%TPNDROW, &
             cp%ZPNDROW,TBASROW,cp%ALBSROW,cp%TSNOROW,cp%RHOSROW, &
             cp%SNOROW,cp%TCANROW,cp%RCANROW,cp%SCANROW,cp%GROROW, &
             TSFSROW,CDHROW, CDMROW, HFSROW, TFXROW, QEVPROW, &
             QFSROW, QFXROW, PETROW, GAROW,  EFROW, &
             GTROW,  QGROW,  TSFROW, ALVSROW,ALIRROW, &
             CMAIROW,SFCTROW,SFCUROW,SFCVROW,SFCQROW, &
             FSGVROW,FSGSROW,FSGGROW,FLGVROW,FLGSROW, &
             FLGGROW,HFSCROW,HFSSROW,HFSGROW,HEVCROW, &
             HEVSROW,HEVGROW,HMFCROW,HMFNROW,HTCCROW, &
             HTCSROW,PCFCROW,PCLCROW,PCPNROW,PCPGROW, &
             QFGROW, QFNROW, QFCLROW,QFCFROW,ROFROW, &
             ROFOROW,ROFSROW,ROFBROW,TROFROW,TROOROW, &
             TROSROW,TROBROW,ROFCROW,ROFNROW,ROVGROW, &
             WTRCROW,WTRSROW,WTRGROW,DRROW,  WTABROW, &
             ILMOROW,UEROW,  HBLROW, TACROW, QACROW, &
             HMFGROW,HTCROW, QFCROW, WSNOROW,FSNOROW, &
             GFLXROW,ITCTROW,ILMOS,JLMOS,IWMOS,JWMOS, &
             NML,NA,NTYPE,ILG,IGND,ICAN,ICAN+1, &
             TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
             TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT, &
             TCANGAT,RCANGAT,SCANGAT,GROGAT,TSFSGAT, &
             CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
             QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT, &
             GTGAT,  QGGAT,  TSFGAT, ALVSGAT,ALIRGAT, &
             CMAIGAT,SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT, &
             FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
             FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
             HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
             HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
             QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT, &
             ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
             TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
             WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  WTABGAT, &
             ILMOGAT,UEGAT,  HBLGAT, TACGAT, QACGAT, &
             HMFGGAT,HTCGAT, QFCGAT, WSNOGAT,FSNOGAT, &
             GFLXGAT,ITCTGAT,cp%MANNROW,MANNGAT,cp%DDROW,DDGAT )

! *********************************************************************
! Calculate values for output files and print them out
! *********************************************************************

!
!=======================================================================
!     * WRITE FIELDS FROM CURRENT TIME STEP TO OUTPUT FILES.
DO I=1,NA
  DO M=1,NMTEST
    IF(FSDOWN(I)>0.0) THEN
      ALTOT=(ALVSROW(I,M)+ALIRROW(I,M))/2.0
    ELSE
      ALTOT=0.0
    ENDIF

    FSSTAR=FSDOWN(I)*(1.0-ALTOT)
    FLSTAR=FDLGRD(I)-SBC*GTROW(I,M)**4
    QH=HFSROW(I,M)
    QE=QEVPROW(I,M)
    BEG=FSSTAR+FLSTAR-QH-QE
    SNOMLT=HMFNROW(I,M)

    IF(cp%RHOSROW(I,M)>0.0) THEN
      ZSN=cp%SNOROW(I,M)/cp%RHOSROW(I,M)
    ELSE
      ZSN=0.0
    ENDIF

    IF(cp%TCANROW(I,M)>0.01) THEN
      TCN=cp%TCANROW(I,M)-TFREZ
    ELSE
      TCN=0.0
    ENDIF

    IF(cp%TSNOROW(I,M)>0.01) THEN
      TSN=cp%TSNOROW(I,M)-TFREZ
    ELSE
      TSN=0.0
    ENDIF

    IF(cp%TPNDROW(I,M)>0.01) THEN
      TPN=cp%TPNDROW(I,M)-TFREZ
    ELSE
      TPN=0.0
    ENDIF

    IF(ILW==1) THEN
      GTOUT=GTROW(I,M)-TFREZ
    ELSE
      GTOUT=0.0
    ENDIF

I_OUT=0
DO K=1, WF_NUM_POINTS
  IF(I==op%N_OUT(K).AND.M==op%II_OUT(k)) THEN
!>        figure out ilmos and jlmos of grid square I
    DO J=1, NML
      IF(ILMOS(J)==op%N_OUT(K).AND.JLMOS(J)==op%II_OUT(K)) THEN
        I_OUT=J
      ENDIF
	    ENDDO

    IF(I_OUT==0) THEN
      PRINT *,'In the input file there the following'
      PRINT *, 'grid square', i, ' has no area in land class', m
      PRINT *,'Please adjust the MESH_input_run_options file, as a guide here'
      PRINT *,'are the land class fractions for that square:'
      DO J=1, NMTEST
        PRINT *, 'land class ',J,' has an area of:',ACLASS(i,J)
      ENDDO
	      STOP
    ENDIF


    WRITE(150+k*10+4,'((I2,","),(I3,","),(I5,","),(I6,","),'// &
                   '9(F8.2,","),2(F7.3,","),(E11.3,","),(F8.2,","),'// &
                   '(F12.4,","))') &
                   IHOUR,IMIN,IDAY,IYEAR,FSSTAR,FLSTAR,QH, &
                   QE,SNOMLT,BEG,GTOUT,cp%SNOROW(I,M), &
                   cp%RHOSROW(I,M),WSNOROW(I,M),ALTOT,ROFROW(I,M), &
                   TPN,cp%ZPNDROW(I,M)
    WRITE(150+k*10+5,'((I2,","),(I3,","),(I5,","),(I6,","),'// &
                   '6(F7.2,",",2(F6.3,",")),(F8.2,","),2(F8.4,","),'// &
                   '(F8.2,","),(F8.3,","))') &
                   IHOUR,IMIN,IDAY,IYEAR, &
                   (cp%TBARROW(I,M,J)-TFREZ,cp%THLQROW(I,M,J), &
                   cp%THICROW(I,M,J),J=1,IGND),TCN, &
                   cp%RCANROW(I,M),cp%SCANROW(I,M),TSN,ZSN
    WRITE(150+k*10+6,'((I2,",")(I3,",")(I5,",")2(F10.2,",")'// &
                   '(F12.6,",")(F10.2,",")(F8.2,",")(F10.2,",")'// &
                   '(F15.9,","))') &
                   IHOUR,IMIN,IDAY,FSDOWN(I),FDLGRD(I), &
                   PREGRD(I),TAGRD(I)-TFREZ,UVGRD(I),PRESGRD(I), &
                   QAGRD(I)
    WRITE(150+k*10+7,'(12(E11.4,","))') &
                   TROFROW(I,M),TROOROW(I,M),TROSROW(I,M), &
                   TROBROW(I,M),ROFROW(I,M),ROFOROW(I,M), &
                   ROFSROW(I,M),ROFBROW(I,M), &
                   FCS(I),FGS(I),FC(I),FG(I)
    WRITE(150+k*10+8,'(22(F10.4,","))') &
                   FSGVROW(I,M),FSGSROW(I,M),FSGGROW(I,M), &
                   FLGVROW(I,M),FLGSROW(I,M),FLGGROW(I,M), &
                   HFSCROW(I,M),HFSSROW(I,M),HFSGROW(I,M), &
                   HEVCROW(I,M),HEVSROW(I,M),HEVGROW(I,M), &
                   HMFCROW(I,M),HMFNROW(I,M), &
                   (HMFGROW(I,M,J),J=1,IGND), &
                   HTCCROW(I,M),HTCSROW(I,M), &
                   (HTCROW(I,M,J),J=1,IGND)
    WRITE(150+k*10+9,'(21(E12.4,","))') &
                   PCFCROW(I,M),PCLCROW(I,M),PCPNROW(I,M), &
                   PCPGROW(I,M),QFCFROW(I,M),QFCLROW(I,M), &
                   QFNROW(I,M),QFGROW(I,M),(QFCROW(I,M,J), &
                   J=1,IGND),ROFCROW(I,M),ROFNROW(I,M), &
                   ROFOROW(I,M),ROFROW(I,M),WTRCROW(I,M), &
                   WTRSROW(I,M),WTRGROW(I,M)

  ENDIF !IF(I==op%N_OUT(K).AND.M==op%II_OUT(k)) THEN
ENDDO !DO K=1, WF_NUM_POINTS
ENDDO !DO M=1,NMTEST
ENDDO !DO I=1,NA
!> Write ENSIM output
!> -----------------------------------------------------c
!>
IF(ensim_ios==0)THEN
  !calculate month/day
  CALL FIND_MONTH (IDAY, IYEAR, ensim_month)
  CALL FIND_DAY (IDAY, IYEAR, ensim_day)

  CALL ENSIM(NML, NA, NMTEST, NCOUNT, IMIN, ireport, &
    wfo_seq, IYEAR, ensim_MONTH, ensim_DAY, IHOUR, IMIN, 0, &
    0, XXX, YYY, YCOUNT, XCOUNT, wfo_pick, &
    NA, NTYPE, PREGRD, DELT, TAGRD, TFREZ, FSDOWN, FDLGRD, UVGRD, &
    PRESGRD, QAGRD, ROFBROW, ROFSROW, ROFOROW, ROFROW, cp%FAREROW, &
    QFSROW, QEVPROW, HFSROW, SBC, GTROW, ALVSROW, &
    ALIRROW, FC, FG, FCS, FGS, GZEROC, GZEROG, &
!TODO: check that fsnorow is correct (bjd - Jan 15/08)
    GZROCS, GZROGS, cp%SNOROW, ZSNOW, FSNOROW, cp%TSNOROW, &
    cp%TBARROW, cp%THLQROW, cp%THICROW, RHOW, sl%DELZ,ILMOS,JLMOS, &
    ILG, CURREC)

ENDIF

!> =======================================================================
!>     * CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.

!> many of these varibles are currently not being used for anything,
!> but we want to keep them because they may be useful in the future.
!> these variables hold the grid cell averages. 
!> In the future, someone will need to use them.
DO I=1,NA
    CDHGRD(I)=0.
    CDMGRD(I)=0.
    HFSGRD(I)=0.
    TFXGRD(I)=0.
    QEVPGRD(I)=0.
    QFSGRD(I)=0.
    QFXGRD(I)=0.
    PETGRD(I)=0.
    GAGRD(I)=0.
    EFGRD(I)=0.
    GTGRD(I)=0.
    QGGRD(I)=0.
    TSFGRD(I)=0.
    ALVSGRD(I)=0.
    ALIRGRD(I)=0.
    SFCTGRD(I)=0.
    SFCUGRD(I)=0.
    SFCVGRD(I)=0.
    SFCQGRD(I)=0.
    FSNOGRD(I)=0.
    FSGVGRD(I)=0.
    FSGSGRD(I)=0.
    FSGGGRD(I)=0.
    SNOGRD(I)=0.
    FLGVGRD(I)=0.
    FLGSGRD(I)=0.
    FLGGGRD(I)=0.
    HFSCGRD(I)=0.
    HFSSGRD(I)=0.
    HFSGGRD(I)=0.
    HEVCGRD(I)=0.
    HEVSGRD(I)=0.
    HEVGGRD(I)=0.
    HMFCGRD(I)=0.
    HMFNGRD(I)=0.
    HTCCGRD(I)=0.
    HTCSGRD(I)=0.
    PCFCGRD(I)=0.
    PCLCGRD(I)=0.
    PCPNGRD(I)=0.
    PCPGGRD(I)=0.
    QFGGRD(I)=0.
    QFNGRD(I)=0.
    QFCLGRD(I)=0.
    QFCFGRD(I)=0.
    ROFGRD(I)=0.
    ROFOGRD(I)=0.
    ROFSGRD(I)=0.
    ROFBGRD(I)=0.
    ROFCGRD(I)=0.
    ROFNGRD(I)=0.
    ROVGGRD(I)=0.
    WTRCGRD(I)=0.
    WTRSGRD(I)=0.
    WTRGGRD(I)=0.
    DRGRD(I)=0.
    WTABGRD(I)=0.
    ILMOGRD(I)=0.
    UEGRD(I)=0.
    HBLGRD(I)=0.
    DO J=1,IGND
      HMFGGRD(I,J)=0.
      HTCGRD(I,J)=0.
      QFCGRD(I,J)=0.
!- Diane added GFLXGRD       
!-            GFLXGRD(I,J)=0.
    ENDDO
ENDDO !DO I=1,NA
!>
!>*******************************************************************
!>
DO I=1,NA
  DO M=1,NMTEST
    CDHGRD(I)=CDHGRD(I)+CDHROW(I,M)*cp%FAREROW(I,M)
    CDMGRD(I)=CDMGRD(I)+CDMROW(I,M)*cp%FAREROW(I,M)
    HFSGRD(I)=HFSGRD(I)+HFSROW(I,M)*cp%FAREROW(I,M)
    TFXGRD(I)=TFXGRD(I)+TFXROW(I,M)*cp%FAREROW(I,M)
    QEVPGRD(I)=QEVPGRD(I)+QEVPROW(I,M)*cp%FAREROW(I,M)
    QFSGRD(I)=QFSGRD(I)+QFSROW(I,M)*cp%FAREROW(I,M)
    QFXGRD(I)=QFXGRD(I)+QFXROW(I,M)*cp%FAREROW(I,M)
    PETGRD(I)=PETGRD(I)+PETROW(I,M)*cp%FAREROW(I,M)
    GAGRD(I)=GAGRD(I)+GAROW(I,M)*cp%FAREROW(I,M)
    EFGRD(I)=EFGRD(I)+EFROW(I,M)*cp%FAREROW(I,M)
    GTGRD(I)=GTGRD(I)+GTROW(I,M)*cp%FAREROW(I,M)
    QGGRD(I)=QGGRD(I)+QGROW(I,M)*cp%FAREROW(I,M)
    TSFGRD(I)=TSFGRD(I)+TSFROW(I,M)*cp%FAREROW(I,M)
    ALVSGRD(I)=ALVSGRD(I)+ALVSROW(I,M)*cp%FAREROW(I,M)
    ALIRGRD(I)=ALIRGRD(I)+ALIRROW(I,M)*cp%FAREROW(I,M)
    SFCTGRD(I)=SFCTGRD(I)+SFCTROW(I,M)*cp%FAREROW(I,M)
    SFCUGRD(I)=SFCUGRD(I)+SFCUROW(I,M)*cp%FAREROW(I,M)
    SFCVGRD(I)=SFCVGRD(I)+SFCVROW(I,M)*cp%FAREROW(I,M)
    SFCQGRD(I)=SFCQGRD(I)+SFCQROW(I,M)*cp%FAREROW(I,M)
    FSNOGRD(I)=FSNOGRD(I)+FSNOROW(I,M)*cp%FAREROW(I,M)
    FSGVGRD(I)=FSGVGRD(I)+FSGVROW(I,M)*cp%FAREROW(I,M)
    FSGSGRD(I)=FSGSGRD(I)+FSGSROW(I,M)*cp%FAREROW(I,M)
    FSGGGRD(I)=FSGGGRD(I)+FSGGROW(I,M)*cp%FAREROW(I,M)
    SNOGRD(I)=SNOGRD(I)+cp%SNOROW(I,M)*cp%FAREROW(I,M)
    FLGVGRD(I)=FLGVGRD(I)+FLGVROW(I,M)*cp%FAREROW(I,M)
    FLGSGRD(I)=FLGSGRD(I)+FLGSROW(I,M)*cp%FAREROW(I,M)
    FLGGGRD(I)=FLGGGRD(I)+FLGGROW(I,M)*cp%FAREROW(I,M)
    HFSCGRD(I)=HFSCGRD(I)+HFSCROW(I,M)*cp%FAREROW(I,M)
    HFSSGRD(I)=HFSSGRD(I)+HFSSROW(I,M)*cp%FAREROW(I,M)
    HFSGGRD(I)=HFSGGRD(I)+HFSGROW(I,M)*cp%FAREROW(I,M)
    HEVCGRD(I)=HEVCGRD(I)+HEVCROW(I,M)*cp%FAREROW(I,M)
    HEVSGRD(I)=HEVSGRD(I)+HEVSROW(I,M)*cp%FAREROW(I,M)
    HEVGGRD(I)=HEVGGRD(I)+HEVGROW(I,M)*cp%FAREROW(I,M)
    HMFCGRD(I)=HMFCGRD(I)+HMFCROW(I,M)*cp%FAREROW(I,M)
    HMFNGRD(I)=HMFNGRD(I)+HMFNROW(I,M)*cp%FAREROW(I,M)
    HTCCGRD(I)=HTCCGRD(I)+HTCCROW(I,M)*cp%FAREROW(I,M)
    HTCSGRD(I)=HTCSGRD(I)+HTCSROW(I,M)*cp%FAREROW(I,M)
    PCFCGRD(I)=PCFCGRD(I)+PCFCROW(I,M)*cp%FAREROW(I,M)
    PCLCGRD(I)=PCLCGRD(I)+PCLCROW(I,M)*cp%FAREROW(I,M)
    PCPNGRD(I)=PCPNGRD(I)+PCPNROW(I,M)*cp%FAREROW(I,M)
    PCPGGRD(I)=PCPGGRD(I)+PCPGROW(I,M)*cp%FAREROW(I,M)
    QFGGRD(I)=QFGGRD(I)+QFGROW(I,M)*cp%FAREROW(I,M)
    QFNGRD(I)=QFNGRD(I)+QFNROW(I,M)*cp%FAREROW(I,M)
    QFCLGRD(I)=QFCLGRD(I)+QFCLROW(I,M)*cp%FAREROW(I,M)
    QFCFGRD(I)=QFCFGRD(I)+QFCFROW(I,M)*cp%FAREROW(I,M)
    ROFGRD(I)=ROFGRD(I)+ROFROW(I,M)*cp%FAREROW(I,M)
    ROFOGRD(I)=ROFOGRD(I)+ROFOROW(I,M)*cp%FAREROW(I,M)
    ROFSGRD(I)=ROFSGRD(I)+ROFSROW(I,M)*cp%FAREROW(I,M)
    ROFBGRD(I)=ROFBGRD(I)+ROFBROW(I,M)*cp%FAREROW(I,M)
    ROFCGRD(I)=ROFCGRD(I)+ROFCROW(I,M)*cp%FAREROW(I,M)
    ROFNGRD(I)=ROFNGRD(I)+ROFNROW(I,M)*cp%FAREROW(I,M)
    ROVGGRD(I)=ROVGGRD(I)+ROVGROW(I,M)*cp%FAREROW(I,M)
    WTRCGRD(I)=WTRCGRD(I)+WTRCROW(I,M)*cp%FAREROW(I,M)
    WTRSGRD(I)=WTRSGRD(I)+WTRSROW(I,M)*cp%FAREROW(I,M)
    WTRGGRD(I)=WTRGGRD(I)+WTRGROW(I,M)*cp%FAREROW(I,M)
    DRGRD(I)=DRGRD(I)+DRROW(I,M)*cp%FAREROW(I,M)
    WTABGRD(I)=WTABGRD(I)+WTABROW(I,M)*cp%FAREROW(I,M)
    ILMOGRD(I)=ILMOGRD(I)+ILMOROW(I,M)*cp%FAREROW(I,M)
    UEGRD(I)=UEGRD(I)+UEROW(I,M)*cp%FAREROW(I,M)
    HBLGRD(I)=HBLGRD(I)+HBLROW(I,M)*cp%FAREROW(I,M)
    DO J=1,IGND
        HMFGGRD(I,J)=HMFGGRD(I,J)+HMFGROW(I,M,J)*cp%FAREROW(I,M)
        HTCGRD(I,J)=HTCGRD(I,J)+HTCROW(I,M,J)*cp%FAREROW(I,M)
        QFCGRD(I,J)=QFCGRD(I,J)+QFCROW(I,M,J)*cp%FAREROW(I,M)
!- Diane added GFLXGRD june 17/08
!-              GFLXGRD(I,J)=GFLXGRD(I,J)+GFLXROW(I,M,J)*FAREROW(I,M)
    ENDDO
  ENDDO !DO M=1,NMTEST
ENDDO !DO I=1,NA

CALL tile_connector(runoff, recharge, null(), ncount, ROFOGRD, ROFSGRD, ROFBGRD, DELT)

!> =======================================================================
!> * WRITE WATROUTE INPUT FILES
!> CDAN * FILES ARE ONLY WRITTEN ON THE HOUR (WATROUTE READS HOURLY DATA).
!> CDAN * HOURLY TIME STEPS ARE ODD-NUMBERED INTEGERS.

IF (MOD (REAL (NCOUNT), 2.0) .EQ. 0.0) THEN !HOURLY TIME STEP
  YEAR1 = IYEAR
  CALL FIND_MONTH (IDAY, IYEAR, MONTH_NOW)
  CALL FIND_DAY (IDAY, IYEAR, DAY_NOW)
  HOUR_NOW = IHOUR + 1 !ROUTING USES 1-24 RANGE, MESH USES 0-23

  IF (MODELFLG.EQ."i" .OR. MODELFLG.EQ."r" .OR. MODELFLG.EQ."l") &
      THEN !WRITE RUNOFF DATA
      OUTARRAY = RUNOFF !PASS RUNOFF TO OUTARRAY IN WRITE_R2C
      CALL WRITE_R2C(261, 31, NO_FRAMES, 1, FRAME_NO, 1, 6)
 END IF
!
 IF (MODELFLG .EQ. "r") THEN !WRITE RECHARGE DATA
      OUTARRAY = RECHARGE !PASS RUNOFF TO OUTARRAY IN WRITE_R2C
      CALL WRITE_R2C(262, 32, NO_FRAMES, 1, FRAME_NO, 1, 6)
  END IF

  FRAME_NO = FRAME_NO + 1 !UPDATE COUNTERS
  NO_FRAMES = FRAME_NO + 1
END IF !(MOD (REAL (NCOUNT), 2.0) .EQ. 0.0)


!> calculate and write the basin avg SCA similar to watclass3.0f5
!> Same code than in wf_ensim.f subrutine of watclass3.0f8
!> Especially for version MESH_Prototype 3.3.1.7b (not to be incorporated in future versions)
!> calculate and write the basin avg SWE using the similar fudge factor!!!

IF (BASIN_FRACTION(1) == -1) THEN
  DO I = 1, NA ! NA = number of grid squares
!>         BASIN_FRACTION is the basin snow cover
!>         (portions of the grids outside the basin are not included)
!>         for a given day - IDAY in the if statement
    BASIN_FRACTION(I) = FRAC(I)
    !TODO: FRAC is not actually the fraction of the grid square
    !within the basin, we should be using some other value, but I'm
    !not sure what.
    !todo: calculate frac and write document to send to someone else.
  ENDDO
ENDIF

IF((IHOUR==12).AND.(IMIN==0))  THEN

    basin_SCA = 0.0
    basin_SWE = 0.0

!    do I=1,NA
!       if(BASIN_FRACTION(I)/=0.0) then
!          basin_SCA = basin_SCA + FSNOGRD(I)/BASIN_FRACTION(I)
!          basin_SWE = basin_SWE + SNOGRD(I)/BASIN_FRACTION(I)
!       endif
!    enddo
!
!   basin_SCA = basin_SCA/NA
!   basin_SWE = basin_SWE/NA

! BRUCE DAVISON - AUG 17, 2009 (see notes in my notebook for this day)
! Fixed calculation of basin averages. Needs documenting and testing.
    do I=1,NML
       basin_SCA = basin_SCA + FSNOGAT(I)*cp%FAREROW(ilmos(I),jlmos(I))
       basin_SWE = basin_SWE + SNOGAT(I)*cp%FAREROW(ilmos(I),jlmos(I))
    enddo

   basin_SCA = basin_SCA/TOTAL_AREA
   basin_SWE = basin_SWE/TOTAL_AREA

ENDIF


IF ((IHOUR==12).AND.(IMIN==0))  THEN
  WRITE(85,'(I5, ",", F10.3)') IDAY, basin_SCA
  WRITE(86,'(I5, ",", F10.3)') IDAY, basin_SWE
ENDIF

!> =======================================================================
!> ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.

DO I=1,NA
  DO M=1,NMTEST
    PREACC(I)=PREACC(I)+PREGRD(I)*cp%FAREROW(I,M)*DELT
    GTACC(I)=GTACC(I)+GTROW(I,M)*cp%FAREROW(I,M)
    QEVPACC(I)=QEVPACC(I)+QEVPROW(I,M)*cp%FAREROW(I,M)
    EVAPACC(I)=EVAPACC(I)+QFSROW(I,M)*cp%FAREROW(I,M)*DELT
    HFSACC(I)=HFSACC(I)+HFSROW(I,M)*cp%FAREROW(I,M)
    HMFNACC(I)=HMFNACC(I)+HMFNROW(I,M)*cp%FAREROW(I,M)
    ROFACC(I)=ROFACC(I)+ROFROW(I,M)*cp%FAREROW(I,M)*DELT
    ROFOACC(I)=ROFOACC(I)+ROFOROW(I,M)*cp%FAREROW(I,M)*DELT
    ROFSACC(I)=ROFSACC(I)+ROFSROW(I,M)*cp%FAREROW(I,M)*DELT
    ROFBACC(I)=ROFBACC(I)+ROFBROW(I,M)*cp%FAREROW(I,M)*DELT
    WTBLACC(I)=WTBLACC(I)+WTABROW(I,M)*cp%FAREROW(I,M)
    DO J=1,IGND
      TBARACC(I,J)=TBARACC(I,J)+cp%TBARROW(I,M,J)*ACLASS(I,M)
      THLQACC(I,J)=THLQACC(I,J)+cp%THLQROW(I,M,J)*cp%FAREROW(I,M)
      THICACC(I,J)=THICACC(I,J)+cp%THICROW(I,M,J)*cp%FAREROW(I,M)
      THALACC(I,J)=THALACC(I,J)+(cp%THLQROW(I,M,J)+ &
                  cp%THICROW(I,M,J))*cp%FAREROW(I,M)
    ENDDO
    ALVSACC(I)=ALVSACC(I)+ALVSROW(I,M)*cp%FAREROW(I,M)*FSVHGRD(I)
    ALIRACC(I)=ALIRACC(I)+ALIRROW(I,M)*cp%FAREROW(I,M)*FSIHGRD(I)
    IF(cp%SNOROW(I,M)>0.0) THEN
      RHOSACC(I)=RHOSACC(I)+cp%RHOSROW(I,M)*cp%FAREROW(I,M)
      TSNOACC(I)=TSNOACC(I)+cp%TSNOROW(I,M)*cp%FAREROW(I,M)
      WSNOACC(I)=WSNOACC(I)+WSNOROW(I,M)*cp%FAREROW(I,M)
      SNOARE(I)=SNOARE(I)+cp%FAREROW(I,M)
    ENDIF
    IF(cp%TCANROW(I,M)>0.5) THEN
      TCANACC(I)=TCANACC(I)+cp%TCANROW(I,M)*cp%FAREROW(I,M)
      CANARE(I)=CANARE(I)+cp%FAREROW(I,M)
    ENDIF
    SNOACC(I)=SNOACC(I)+cp%SNOROW(I,M)*cp%FAREROW(I,M)
    RCANACC(I)=RCANACC(I)+cp%RCANROW(I,M)*cp%FAREROW(I,M)
    SCANACC(I)=SCANACC(I)+cp%SCANROW(I,M)*cp%FAREROW(I,M)
    GROACC(I)=GROACC(I)+cp%GROROW(I,M)*cp%FAREROW(I,M)
    FSINACC(I)=FSINACC(I)+FSDOWN(I)*cp%FAREROW(I,M)
    FLINACC(I)=FLINACC(I)+FDLGRD(I)*cp%FAREROW(I,M)
    FLUTACC(I)=FLUTACC(I)+SBC*GTROW(I,M)**4*cp%FAREROW(I,M)
    TAACC(I)=TAACC(I)+TAGRD(I)*cp%FAREROW(I,M)
    UVACC(I)=UVACC(I)+UVGRD(I)*cp%FAREROW(I,M)
    PRESACC(I)=PRESACC(I)+PRESGRD(I)*cp%FAREROW(I,M)
    QAACC(I)=QAACC(I)+QAGRD(I)*cp%FAREROW(I,M)
  ENDDO !DO M=1,NMTEST
ENDDO !DO I=1,NA

!> CALCULATE AND PRINT DAILY AVERAGES.


!todo: use delta t here
IF(NCOUNT==48) THEN !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

  DO I=1,NA
    PREACC(I)=PREACC(I)
    GTACC(I)=GTACC(I)/REAL(NSUM)
    QEVPACC(I)=QEVPACC(I)/REAL(NSUM)
    EVAPACC(I)=EVAPACC(I)
    HFSACC(I)=HFSACC(I)/REAL(NSUM)
    HMFNACC(I)=HMFNACC(I)/REAL(NSUM)
    ROFACC(I)=ROFACC(I)
    ROFOACC(I)=ROFOACC(I)
    ROFSACC(I)=ROFSACC(I)
    ROFBACC(I)=ROFBACC(I)
    WTBLACC(I)=WTBLACC(I)/REAL(NSUM)

    DO J=1,IGND
      TBARACC(I,J)=TBARACC(I,J)/REAL(NSUM)
      THLQACC(I,J)=THLQACC(I,J)/REAL(NSUM)
      THICACC(I,J)=THICACC(I,J)/REAL(NSUM)
      THALACC(I,J)=THALACC(I,J)/REAL(NSUM)
    ENDDO

    IF(FSINACC(I)>0.0) THEN
      ALVSACC(I)=ALVSACC(I)/(FSINACC(I)*0.5)
      ALIRACC(I)=ALIRACC(I)/(FSINACC(I)*0.5)
    ELSE
      ALVSACC(I)=0.0
      ALIRACC(I)=0.0
    ENDIF

    IF(SNOARE(I)>0.0) THEN
      RHOSACC(I)=RHOSACC(I)/SNOARE(I)
      TSNOACC(I)=TSNOACC(I)/SNOARE(I)
      WSNOACC(I)=WSNOACC(I)/SNOARE(I)
    ENDIF

    IF(CANARE(I)>0.0) THEN
      TCANACC(I)=TCANACC(I)/CANARE(I)
    ENDIF

    SNOACC(I)=SNOACC(I)/REAL(NSUM)
    RCANACC(I)=RCANACC(I)/REAL(NSUM)
    SCANACC(I)=SCANACC(I)/REAL(NSUM)
    GROACC(I)=GROACC(I)/REAL(NSUM)
    FSINACC(I)=FSINACC(I)/REAL(NSUM)
    FLINACC(I)=FLINACC(I)/REAL(NSUM)
    FLUTACC(I)=FLUTACC(I)/REAL(NSUM)
    TAACC(I)=TAACC(I)/REAL(NSUM)
    UVACC(I)=UVACC(I)/REAL(NSUM)
    PRESACC(I)=PRESACC(I)/REAL(NSUM)
    QAACC(I)=QAACC(I)/REAL(NSUM)
!* ALTOT: the average of the visible spectrum and infrared spectrum
    ALTOT=(ALVSACC(I)+ALIRACC(I))/2.0
    FSSTAR=FSINACC(I)*(1.-ALTOT)
    FLSTAR=FLINACC(I)-FLUTACC(I)
    QH=HFSACC(I)
    QE=QEVPACC(I)
    BEG=FSSTAR+FLSTAR-QH-QE
    SNOMLT=HMFNACC(I)
    IF(RHOSACC(I)>0.0) THEN
      ZSN=SNOACC(I)/RHOSACC(I)
    ELSE
      ZSN=0.0
    ENDIF

    IF(TCANACC(I)>0.01) THEN 
      TCN=TCANACC(I)-TFREZ
    ELSE
      TCN=0.0
    ENDIF

    IF(TSNOACC(I)>0.01) THEN 
      TSN=TSNOACC(I)-TFREZ
    ELSE
      TSN=0.0
    ENDIF

    IF(ILW==1) THEN
      GTOUT=GTACC(I)-TFREZ
    ELSE
      GTOUT=0.0
    ENDIF

!> see if we are at one of the output points
    DO K=1, WF_NUM_POINTS
      IF(I==op%N_OUT(K)) THEN
!> figure out nlmos and mlmos of grid square I
        DO J=1, NML
          IF(ILMOS(J)==op%N_OUT(K)) THEN
            I_OUT=J
          ENDIF
        ENDDO

        WRITE(150+k*10+1,'((I4,","),(I5,","),9(F8.2,","),2(F8.3,","),'// &
                        '(F12.4,","),4(F12.4,","))') &
                        IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,SNOMLT, &
                        BEG,GTOUT,SNOACC(I),RHOSACC(I), &
                        WSNOACC(I),ALTOT,ROFACC(I),ROFOACC(I), &
                        ROFSACC(I),ROFBACC(I)
        WRITE(150+k*10+2,'((I4,","),(I5,","),6((F8.2,","),'// &
                        '2(F6.3,",")),(F8.2,","),2(F7.4,","),'// &
                        '2(F8.2,","),(E12.5,","))') &
                        IDAY,IYEAR,(TBARACC(I,J)-TFREZ, &
                        THLQACC(I,J),THICACC(I,J),J=1,IGND), &
                        TCN,RCANACC(I),SCANACC(I),TSN,ZSN
        WRITE(150+k*10+3,'((I4,","),(I5,","),3(F9.2,","),(F8.2,","),'// &
                        '(F10.2,","),(E12.3,","),2(F12.3,","),'// &
                        '(F8.3,","))') &
                        IDAY,IYEAR,FSINACC(I),FLINACC(I), &
                        TAACC(I)-TFREZ,UVACC(I),PRESACC(I), &
                        QAACC(I),PREACC(I),EVAPACC(I)
      ENDIF  !IF(I==op%N_OUT(K)) THEN
    ENDDO  !DO K=1, WF_NUM_POINTS

!> update components for final tally
    TOTAL_ROFACC=TOTAL_ROFACC+ROFACC(I)
    TOTAL_ROFOACC=TOTAL_ROFOACC+ROFOACC(I)
    TOTAL_ROFSACC=TOTAL_ROFSACC+ROFSACC(I)
    TOTAL_ROFBACC=TOTAL_ROFBACC+ROFBACC(I)
    TOTAL_EVAPACC=TOTAL_EVAPACC+EVAPACC(I)
    TOTAL_PREACC=TOTAL_PREACC+PREACC(I)

    IF (WF_NUM_POINTS > 0) THEN !SUMMARY VALUES FOR SCREEN
      DO J = 1, WF_NUM_POINTS !FOR MORE THAN 1 OUTPUT
        IF (I == op%N_OUT(J)) THEN
          PRE_OUT(J) = PREACC(I)
          EVAP_OUT(J) = EVAPACC(I)
          ROF_OUT(J) = ROFACC(I)
        END IF
      END DO
    ELSEIF (I == CEILING(REAL(NA) / 2)) THEN !GENERAL CASE
      PRE_OUT(1) = PREACC(I)
      EVAP_OUT(1) = EVAPACC(I)
      ROF_OUT(1) = ROFACC(I)
    END IF

!> RESET ACCUMULATOR ARRAYS.

    PREACC(I)=0.
    GTACC(I)=0.
    QEVPACC(I)=0.
    HFSACC(I)=0.
    HMFNACC(I)=0.
    ROFACC(I)=0.
    SNOACC(I)=0.
    CANARE(I)=0.
    SNOARE(I)=0.
    ROFOACC(I)=0.
    ROFSACC(I)=0.
    ROFBACC(I)=0.
    WTBLACC(I)=0.
    DO J=1,IGND
      TBARACC(I,J)=0.
      THLQACC(I,J)=0.
      THICACC(I,J)=0.
      THALACC(I,J)=0.
    ENDDO
    ALVSACC(I)=0.
    ALIRACC(I)=0.
    RHOSACC(I)=0.
    TSNOACC(I)=0.
    WSNOACC(I)=0.
    TCANACC(I)=0.
    RCANACC(I)=0.
    SCANACC(I)=0.
    GROACC(I)=0.
    FSINACC(I)=0.
    FLINACC(I)=0.
    TAACC(I)=0.
    UVACC(I)=0.
    PRESACC(I)=0.
    QAACC(I)=0.
    EVAPACC(I)=0.
    FLUTACC(I)=0.
  END DO

ENDIF  ! IF(NCOUNT==48) THEN

NCOUNT=NCOUNT+1 !todo: does this work with hourly forcing data?
NSUM=NSUM+1
IF(NCOUNT>48) THEN !48 is the last half-hour period of the day
                      ! when they're numbered 1-48
  NCOUNT=1
  NSUM=1
ENDIF

!> *********************************************************************
!> Call routing routine
!> *********************************************************************
CALL WF_ROUTE(WF_ROUTETIMESTEP,WF_R1,WF_R2, &
     NA,NAA,NTYPE,YCOUNT,XCOUNT,IYMIN, &
     WF_IYMAX,JXMIN,WF_JXMAX,YYY,XXX,WF_IBN,WF_IROUGH, &
     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE, &
     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE,WF_ELEV,FRAC, &
     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX, &
     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R, &
     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME, &
     WF_B1,WF_B2,WF_QREL, WF_QR, &
     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2, &
     WF_STORE1,WF_STORE2, &
     DRIVERTIMESTEP,ROFGRD, NA, M_C,M_R,M_S, NA, &
     WF_S, JAN,IDAY,IHOUR,IMIN)

DO I=1,WF_NO
  WF_QSYN(I)     = WF_QO2(WF_S(I))
  WF_QSYN_AVG(I) = WF_QSYN_AVG(I) + WF_QO2(WF_S(I)) 
  WF_QHYD_AVG(I) = WF_QHYD(I) !(MAM)THIS SEEMS WORKING OKAY (AS IS THE CASE IN THE READING) FOR A DAILY STREAM FLOW DATA.
ENDDO

IF (JAN == 1) THEN
!>     this is done so that INIT_STORE is not recalculated for
!>     each iteration when wf_route is not used
  JAN = 2
ENDIF



!> *********************************************************************
!> Write measured and simulated streamflow to file and screen
!> Also write daily summary (pre, evap, rof)
!> *********************************************************************

! write streamflow each timestep if asked for in mesh_input_run_options.ini file
IF(STREAMFLOWFLAG==1) THEN

!>      write out the MESH_output_streamflow_all.csv file
  WRITE(71,'(I5,",",I5,",",I5,",",F10.3,100(",",F10.3))') IDAY,IHOUR,IMIN,(WF_QHYD(I), &
    WF_QSYN(I),I=1,WF_NO)

ENDIF

IF(NCOUNT==48) THEN !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

!>      write out the spl.csv file
  WRITE(70,'(I5,",",F10.3,100(",",F10.3))') IDAY,(WF_QHYD_AVG(I), &
    WF_QSYN_AVG(I)/NCOUNT,I=1,WF_NO)

  IF (WF_NUM_POINTS .GT. 1) THEN !FOR MORE THAN ONE OUTPUT

    WRITE (6, "(2I5,100F10.3)") IYEAR, IDAY, &
          (WF_QHYD_AVG(I),WF_QSYN(I),I=1,WF_NO)

    DO I = 1, WF_NUM_POINTS
      WRITE(6, "('  'A, T18, 3F10.3)") op%DIR_OUT(I), &
        PRE_OUT(I), EVAP_OUT(I), ROF_OUT(I)
      PRE_OUT(I) = 0.0 !RESET ACCUMULATORS
      EVAP_OUT(I) = 0.0
      ROF_OUT = 0.0
    END DO
  ELSE !FOR GENERAL CASE OR SINGLE GRID OUTPUT POINT

    WRITE(6, "(2I5, 100F10.3)") IYEAR, IDAY, &
      (WF_QHYD_AVG(I),WF_QSYN_AVG(I)/NCOUNT,I=1,WF_NO), PRE_OUT(1), &
      EVAP_OUT(1), ROF_OUT(1)

    
    PRE_OUT(1) = 0.0
    EVAP_OUT = 0.0
    ROF_OUT = 0.0
  END IF
  IF(PREEMPTIONFLAG==1)THEN
     NCAL       = NCAL + 1
     QOBS(NCAL) = WF_QHYD_AVG(1)
     QSIM(NCAL) = WF_QSYN_AVG(1)/NCOUNT
  ENDIF

  WF_QSYN_AVG = 0.0
ENDIF

!> =====================================================================      
!> During first time through loop, write out the variables:
!>  - wf_qi1
!>  - wf_qo1
!>  - wf_store1
!>  - wf_over
!>  - wf_lzs
!> =====================================================================
!>    NOTE : FIND REAL NAMES OF YHEIGHT, XWIDTH
If (jan == 2) Then
  jan = 3
  
  Open(Unit=109, File='flow_init.r2c')
  write(109,'(a40)')'########################################'
  write(109,'(a40)')':FileType r2c  ASCII  EnSim 1.0         '
  write(109,'(a40)')'#                                       '
  write(109,'(a40)')'# DataType               2D Rect Cell   '
  write(109,'(a40)')'#                                       '
  write(109,'(a40)')':Application             EnSimHydrologic'
  write(109,'(a40)')':Version                 2.1.23         '
  write(109,'(2a20)')':WrittenBy          ',author
  call date_and_time(cday,time)
  write(109,"(a20,a4,'/',a2,'/',a2,2x,a2,':',a2)") &
       ':CreationDate       ', &
       cday(1:4),cday(5:6),cday(7:8),time(1:2),time(3:4)
  write(109,'(a40)')'#                                       '
  write(109,'(a40)')'#---------------------------------------'
  write(109,'(a20,a40)')':SourceFileName     ', &
   '                                        '
  write(109,'(a40)')'#                                       '
  write(109,'(a20,a10,2x,a10)')':Projection         ',coordsys1
	  if(coordsys1.eq.'UTM       ')then
    write(109,'(a20,a10,2x,a10)')':Zone               ',zone1
    write(109,'(a20,a10,2x,a10)')':Ellipsoid          ',datum1
  endif
  if(coordsys1.eq.'LATLONG   ')then
    write(109,'(a20,a10,2x,a10)')':Ellipsoid          ',datum1
  endif
  write(109,'(a40)')'#                                       '
  write(109,'(a20,f16.7)')':xOrigin            ',xorigin
  write(109,'(a20,f16.7)')':yOrigin            ',yorigin
  write(109,'(a40)')'#                                       '
  write(109,'(a30)')':AttributeName 1 qi1          ' 
  write(109,'(a30)')':AttributeName 2 qo1          '  
  write(109,'(a30)')':AttributeName 3 store1       '
  write(109,'(a30)')':AttributeName 4 over         ' 
  write(109,'(a30)')':AttributeName 5 lzs          ' 
  write(109,'(a40)')'#                                       '
  write(109,'(a20,i16)')':xCount             ',xcount
  write(109,'(a20,i16)')':yCount             ',ycount
  write(109,'(a20,f16.7)')':xDelta             ',xdelta
  write(109,'(a20,f16.7)')':yDelta             ',ydelta
  write(109,'(a40)')'#                                       '
  write(109,'(a40)')':EndHeader                              '

!        Do I = 1, ycount
!          Write (109, '(99999E10.3)') (WF_QI1(I, J), J = 1, xcount)
!        End Do'
  found = 0
  
  DO K = 1, ycount
    DO J = 1, xcount
      Do I = 1, NA
        if (xxx(i) == j .AND. yyy(i) == k) then
          WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0 !wf_qi1(i)
          found = 1
        end if
      end do
      if (found == 0) then
        WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0
      endif
      found = 0
    end do
    WRITE( 109, *)
  end do
  
  DO K = 1, ycount
    DO J = 1, xcount
      Do I = 1, NA
        if (xxx(i) == j .AND. yyy(i) == k) then
          WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0 !WF_QO1(i)
          found = 1
        end if
      end do
      if (found == 0) then
        WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0
      endif
      found = 0
    end do
    WRITE( 109, *)
  end do
  
  DO K = 1, ycount
    DO J = 1, xcount
      Do I = 1, NA
        if (xxx(i) == j .AND. yyy(i) == k) then
          WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0 !WF_STORE1(i)
          found = 1
        end if
      end do
      if (found == 0) then
        WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0
      endif
      found = 0
    end do
    WRITE( 109, *)
  end do
  
  DO K = 1, ycount
    DO J = 1, xcount
      Do I = 1, NA
        if (xxx(i) == j .AND. yyy(i) == k) then
          WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0 !over(i)
          found = 1
        end if
      end do
      if (found == 0) then
        WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0
      endif
      found = 0
    end do
    WRITE( 109, *)
  end do
  
  DO K = 1, ycount
    DO J = 1, xcount
      Do I = 1, NA
        if (xxx(i) == j .AND. yyy(i) == k) then
          WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0 !lzs(i)
          found = 1
        end if
      end do
      if (found == 0) then
        WRITE( 109, "(1X, E10.3)" ,ADVANCE="no") 0.0
      endif
      found = 0
    end do
    WRITE( 109, *)
  end do
  Close(109)
End If

ENDIF !TESTCSVFLAG

! *********************************************************************
! Update time counters and return to beginning of main loop
! *********************************************************************
IMIN = IMIN + 30 ! increment the current time by 30 minutes
IF (IMIN == 60) THEN
  IMIN = 0
  IHOUR = IHOUR + 1
  IF (IHOUR==24) THEN
    IHOUR = 0
    IF(PREEMPTIONFLAG == 1)THEN
      SAENEW = SAE(QOBS(1:NCAL),QSIM(1:NCAL),NCAL)
      IF(SAENEW > SAEPRE)GOTO 199
    ENDIF
    IDAY = IDAY + 1
    IF (IDAY >= 366) THEN
      IF (MOD(IYEAR,400) == 0) THEN !LEAP YEAR
        IF (IDAY == 367) THEN
          IDAY = 1
          IYEAR = IYEAR + 1
        ENDIF
      ELSE IF (MOD(IYEAR,100) == 0) THEN !NOT A LEAP YEAR
        IDAY = 1
        IYEAR = IYEAR + 1
      ELSE IF (MOD(IYEAR,4) == 0) THEN !LEAP YEAR
        IF (IDAY == 367) THEN
          IDAY = 1
          IYEAR = IYEAR + 1
        ENDIF
      ELSE !NOT A LEAP YEAR
        IDAY = 1
        IYEAR = IYEAR + 1
      ENDIF
    ENDIF
  ENDIF
ENDIF

!> check if we should terminate the run yet
IF (IYEAR >= IYEAR_END .AND. IYEAR_END > 0) THEN
  IF(IYEAR > IYEAR_END) THEN
    ENDDATE = .TRUE.
  ELSEIF (IYEAR == IYEAR_END .AND. IDAY >= IDAY_END) THEN
    IF (IDAY > IDAY_END) THEN
      ENDDATE = .TRUE.
    ELSEIF (IDAY == IDAY_END .AND. IHOUR >= IHOUR_END) THEN
      IF (IHOUR > IHOUR_END) THEN
        ENDDATE = .TRUE.
      ELSEIF (IHOUR == IHOUR_END .AND. IMIN >= IMIN_END) THEN
        ENDDATE = .TRUE.
      ENDIF
    ENDIF
  ENDIF
ENDIF

IMIN2 = IMIN2 + 30
IF(IMIN2 == HOURLYFLAG)IMIN2 = 0

!> *********************************************************************
!> Read in meteorological forcing data
!> *********************************************************************
IF(HOURLYFLAG == 30 .OR. IMIN2 == 0) THEN
    IF(INTERPOLATIONFLAG == 1)THEN
        FSVHGATPRE    = FSVHGATPST
        FSIHGATPRE    = FSIHGATPST
        FDLGATPRE     = FDLGATPST
        PREGATPRE     = PREGATPST
        TAGATPRE      = TAGATPST
        ULGATPRE      = ULGATPST
        PRESGATPRE    = PRESGATPST
        QAGATPRE      = QAGATPST
        CALL READ_FORCING_DATA(YCOUNT,XCOUNT,NTYPE,NA,NML,ILMOS,JLMOS,YYY,XXX,ENDDATA,cp%FAREROW, &
                           FSDOWN,FSVHGRD,FSIHGRD,FDLGRD,PREGRD,TAGRD,ULGRD,PRESGRD,QAGRD, &
                           FSVHGATPST,FSIHGATPST,FDLGATPST,PREGATPST,TAGATPST,ULGATPST, &
                           PRESGATPST,QAGATPST)

    ELSE
        CALL READ_FORCING_DATA(YCOUNT,XCOUNT,NTYPE,NA,NML,ILMOS,JLMOS,YYY,XXX,ENDDATA,cp%FAREROW, &
                               FSDOWN,FSVHGRD,FSIHGRD,FDLGRD,PREGRD,TAGRD,ULGRD,PRESGRD,QAGRD, &
                               FSVHGAT, FSIHGAT, FDLGAT, PREGAT, TAGAT, ULGAT, PRESGAT, QAGAT)
    ENDIF
ENDIF

ENDDO

!> *********************************************************************
!> Run is now over, print final results to the screen and close files
!> *********************************************************************

!> Write the resume file
IF (SAVERESUMEFLAG > 0) THEN !todo: done: use a flag
  PRINT *, 'Saving state variables'
  call SAVE_STATE( &
   HOURLYFLAG, IMIN, IMIN2, &
   BASINSHORTWAVEFLAG, BASINLONGWAVEFLAG, &
   BASINRAINFLAG, BASINTEMPERATUREFLAG, &
   BASINWINDFLAG, BASINPRESFLAG, BASINHUMIDITYFLAG, &
   FSDOWN, FSVHGRD, FSIHGRD, FDLGRD, &
   I, J, XCOUNT, YCOUNT, jan, &
   VPDGRD, TADPGRD, PADRGRD, RHOAGRD, RHSIGRD, &
   RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, TAGRD, &
   QAGRD, PREGRD, RPREGRD, SPREGRD, PRESGRD, &

!MAM - FOR FORCING DATA INTERPOLATION
   FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
   TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &
   
   IPCP, NA, NA, ILMOS, JLMOS, IWMOS, JWMOS, &
   IWAT, IICE, NML, NMW, NWAT, NICE, &
   cp%GCGRD, cp%FAREROW, cp%MIDROW, NTYPE, ILG, NMTEST, &
   TBARGAT, THLQGAT, THICGAT, TPNDGAT, ZPNDGAT, &
   TBASGAT, ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, &
   TCANGAT, RCANGAT, SCANGAT, GROGAT, CMAIGAT, &
   FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
   PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
   VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
   HGTDGAT, ACVDGAT, ACIDGAT, TSFSGAT, WSNOGAT, &
   THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
   GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
   PSIWGAT, DLZWGAT, ZBTWGAT, ZSNLGAT, ZPLGGAT, &
   ZPLSGAT, TACGAT, QACGAT, DRNGAT, XSLPGAT, &
   XDGAT, WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, &
   ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ISNDGAT, &
   RADJGAT, ZBLDGAT, Z0ORGAT, ZRFMGAT, ZRFHGAT, &
   ZDMGAT, ZDHGAT, FSVHGAT, FSIHGAT, CSZGAT, &
   FDLGAT, ULGAT, VLGAT, TAGAT, QAGAT, PRESGAT, &
   PREGAT, PADRGAT, VPDGAT, TADPGAT, RHOAGAT, &
   RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
   FCLOGAT, DLONGAT, GGEOGAT, CDHGAT, CDMGAT, &
   HFSGAT, TFXGAT, QEVPGAT, QFSGAT, QFXGAT, &
   PETGAT, GAGAT, EFGAT, GTGAT, QGGAT, TSFGAT, &
   ALVSGAT, ALIRGAT, SFCTGAT, SFCUGAT, SFCVGAT, &
   SFCQGAT, FSNOGAT, FSGVGAT, FSGSGAT, FSGGGAT, &
   FLGVGAT, FLGSGAT, FLGGGAT, HFSCGAT, HFSSGAT, &
   HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, HMFCGAT, &
   HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, &
   PCPNGAT, PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, &
   QFCFGAT, ROFGAT, ROFOGAT, ROFSGAT, ROFBGAT, &
   TROFGAT, TROOGAT, TROSGAT, TROBGAT, ROFCGAT, &
   ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, WTRGGAT, &
   DRGAT, HMFGGAT, HTCGAT, QFCGAT, ITCTGAT, &
   IGND, ICAN, ICP1, &
   cp%TBARROW, cp%THLQROW, cp%THICROW, cp%TPNDROW, cp%ZPNDROW, &
   TBASROW, cp%ALBSROW, cp%TSNOROW, cp%RHOSROW, cp%SNOROW, &
   cp%TCANROW, cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, &
   cp%FCANROW, cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
   cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, cp%QA50ROW, &
   cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, cp%PSGBROW, PAIDROW, &
   HGTDROW, ACVDROW, ACIDROW, TSFSROW, WSNOROW, &
   THPROW, THRROW, THMROW, BIROW, PSISROW, &
   GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
   PSIWROW, DLZWROW, ZBTWROW, hp%ZSNLROW, hp%ZPLGROW, &
   hp%ZPLSROW, TACROW, QACROW, cp%DRNROW, cp%XSLPROW, &
   cp%XDROW, WFSFROW, cp%KSROW, ALGWROW, ALGDROW, &
   ASVDROW, ASIDROW, AGVDROW, AGIDROW, &
   ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
   cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, CSZGRD, &
   ULGRD, VLGRD, FCLOGRD, DLONGRD, GGEOGRD, &
   cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
   CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
   WTVSTP, WTSSTP, WTGSTP, &
   sl%DELZ, FCS, FGS, FC, FG, N, &
   ALVSCN, ALIRCN, ALVSG, ALIRG, ALVSCS, &
   ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, &
   ALVSSC, ALIRSC, TRVSCN, TRIRCN, TRVSCS, &
   TRIRCS, FSVF, FSVFS, &
   RAICAN, RAICNS, SNOCAN, SNOCNS, &
   FRAINC, FSNOWC, FRAICS, FSNOCS, &
   DISP, DISPS, ZOMLNC, ZOMLCS, ZOELNC, ZOELCS, &
   ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
   CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, &
   CWFCAP, CWLCPS, CWFCPS, RC, RCS, RBCOEF, &
   FROOT, ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, &
   TRSNOW, ZSNOW, IDAY, JLAT, IDISP, &
   IZREF, IWF, IPAI, IHGT, IALC, IALS, IALG, &
   TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
   THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, &
   TCTOPG, TCBOTG, &
   GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
   G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
   QFREZC, QFREZG, QMELTC, QMELTG, &
   EVAPC, EVAPCG,EVAPG, EVAPCS, EVPCSG, EVAPGS, &
   TCANO, TCANS, TPONDC, TPONDG, TPNDCS, TPNDGS, &
   TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
   WTABGAT, &
   ILMOGAT, UEGAT, HBLGAT, &
   ILW, ITC, ITCG, ITG, ISLFD, &
   NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
   GFLXGAT, CDHROW, CDMROW, HFSROW, TFXROW, &
   QEVPROW, QFSROW, QFXROW, PETROW, GAROW, &
   EFROW, GTROW, QGROW, TSFROW, ALVSROW, &
   ALIRROW, SFCTROW, SFCUROW, SFCVROW, SFCQROW, &
   FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
   FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, &
   HEVSROW, HEVGROW, HMFCROW, HMFNROW, HTCCROW, &
   HTCSROW, PCFCROW, PCLCROW, PCPNROW, PCPGROW, &
   QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, &
   ROFOROW, ROFSROW, ROFBROW, TROFROW, TROOROW, &
   TROSROW, TROBROW, ROFCROW, ROFNROW, ROVGROW, &
   WTRCROW, WTRSROW, WTRGROW, DRROW, WTABROW, &
   ILMOROW, UEROW, HBLROW, HMFGROW, HTCROW, &
   QFCROW, FSNOROW, ITCTROW, NCOUNT, ireport, &
   wfo_seq, IYEAR, ensim_MONTH, ensim_DAY, &
   IHOUR, XXX, YYY, NA, &
   NTYPE, DELT, TFREZ, UVGRD, SBC, RHOW, CURREC, &
   M_C, M_S, M_R, &
     WF_ROUTETIMESTEP,WF_R1,WF_R2,NAA,IYMIN, &
     WF_IYMAX,JXMIN,WF_JXMAX,WF_IBN,WF_IROUGH, &
     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE, &
     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE ,WF_ELEV,FRAC, &
     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX, &
     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R, &
     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME, &
     WF_B1,WF_B2,WF_QREL, WF_QR, &
     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2, &
     WF_STORE1,WF_STORE2, &
     DRIVERTIMESTEP,ROFGRD, &
     WF_S, &
  TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
  FINAL_STORE, TOTAL_AREA)
ENDIF

IF(ENDDATA)PRINT *, 'Reached end of forcing data'
IF(ENDDATE)PRINT *, 'Reached end of simulation date'

!> Calculate final storage
FINAL_STORE=0.0
DO I=1,NA
DO M=1,NMTEST
		IF(FRAC(I)/=0.0)THEN
    FINAL_STORE=FINAL_STORE+(cp%RCANROW(I,M)+cp%SCANROW(I,M)+ &
    cp%SNOROW(I,M)+(cp%THLQROW(I,M,1)*RHOW+cp%THICROW(I,M,1)* &
    RHOICE)*DLZWROW(I,M,1)+cp%ZPNDROW(I,M)*RHOW+(cp%THLQROW(I,M,2) &
    *RHOW+cp%THICROW(I,M,2)*RHOICE)*DLZWROW(I,M,2) &
    +(cp%THLQROW(I,M,3)*RHOW+cp%THICROW(I,M,3)*RHOICE) &
    *DLZWROW(I,M,3))*cp%FAREROW(I,M)
		ENDIF
ENDDO
ENDDO

!> write out final totals to screen
   WRITE(6,*)
   WRITE(6,'(A,F11.3)') '  Total Precipitation         (mm) = ', &
        TOTAL_PREACC/TOTAL_AREA
   WRITE(6,'(A,F11.3)') '  Total Evaporation           (mm) = ', &
        TOTAL_EVAPACC/TOTAL_AREA
   WRITE(6,'(A,F11.3)') '  Total Runoff                (mm) = ', &
        TOTAL_ROFACC/TOTAL_AREA
   WRITE(6,'(A,3F11.3)') '  Storage(Change/Init/Final)  (mm) = ', &
        (FINAL_STORE-INIT_STORE)/TOTAL_AREA, &
        INIT_STORE/TOTAL_AREA, &
        FINAL_STORE/TOTAL_AREA
   WRITE(6,*)
   WRITE(6,'(A,F11.3)') '  Total Overland flow         (mm) = ', &
        TOTAL_ROFOACC/TOTAL_AREA
   WRITE(6,'(A,F11.3)') '  Total Interflow             (mm) = ', &
        TOTAL_ROFSACC/TOTAL_AREA
   WRITE(6,'(A,F11.3)') '  Total Baseflow              (mm) = ', &
        TOTAL_ROFBACC/TOTAL_AREA
   WRITE(6,*)
   WRITE(6,'(A32)') 'Program has terminated normally.'
   WRITE(6,*)
!> write out final totals to file
   WRITE(58,*)
   WRITE(58,'(A,F11.3)') '  Total Precipitation         (mm) = ', &
        TOTAL_PREACC/TOTAL_AREA
   WRITE(58,'(A,F11.3)') '  Total Evaporation           (mm) = ', &
        TOTAL_EVAPACC/TOTAL_AREA
   WRITE(58,'(A,F11.3)') '  Total Runoff                (mm) = ', &
        TOTAL_ROFACC/TOTAL_AREA
   WRITE(58,'(A,3F11.3)')'  Storage(Change/Init/Final)  (mm) = ', &
        (FINAL_STORE-INIT_STORE)/TOTAL_AREA, &
        INIT_STORE/TOTAL_AREA, &
        FINAL_STORE/TOTAL_AREA
   WRITE(58,'(A,F11.3)') '  Total Overland flow         (mm) = ', &
        TOTAL_ROFOACC/TOTAL_AREA
   WRITE(58,'(A,F11.3)') '  Total Interflow             (mm) = ', &
        TOTAL_ROFSACC/TOTAL_AREA
   WRITE(58,'(A,F11.3)') '  Total Baseflow              (mm) = ', &
        TOTAL_ROFBACC/TOTAL_AREA
   WRITE(58,*)
   WRITE(58,*)
   WRITE(58,'(A32)') 'Program has terminated normally.'
   WRITE(58,*)

199 CONTINUE

IF(PREEMPTIONFLAG == 1)THEN
  OPEN(100,FILE="function_out.txt")
  WRITE(100,*)SAENEW*NCALMAX/NCAL
  CLOSE(100)
  PRINT *
  PRINT*,"PRE-EMPTION INVOKED"
  PRINT *
ENDIF

DO I=1, wf_num_points
  CLOSE(UNIT=150+i*10+1)
  CLOSE(UNIT=150+i*10+2)
  CLOSE(UNIT=150+i*10+3)
  CLOSE(UNIT=150+i*10+4)
  CLOSE(UNIT=150+i*10+5)
  CLOSE(UNIT=150+i*10+6)
  CLOSE(UNIT=150+i*10+7)
  CLOSE(UNIT=150+i*10+8)
  CLOSE(UNIT=150+i*10+9)
ENDDO

999 CONTINUE

!> Diane      CLOSE(UNIT=21)
!>      CLOSE(UNIT=22)
CLOSE(UNIT=51)
CLOSE(UNIT=58)
CLOSE(UNIT=70)
CLOSE(UNIT=71)
close(unit=85)
close(unit=86)
close(unit=90)

9000 FORMAT('INTERPOLATIONFLAG is not specified correctly and is set to 0 by the model.',/, &
            '0: No interpolation of forcing data.',/, &
            '1: linearly interpolates forcing data for intermediate time steps.',/,& 
            'Note: INTERPOLATIONFLAG should be set to 0 for 30 minute forcing data.')        
STOP
END
