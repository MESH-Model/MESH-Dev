program RUNMESH

!>       MESH DRIVER
!>
!>       NOV 2015 - DGP. Moved incrementing the counters to
!>                  after routing has finished. This impacts when daily
!>                  and cumulative daily streamflow are written to file
!>                  and screen. The average daily streamflow was
!>                  calculated between 23:00-23:30 before the fix, tied
!>                  to an if statement about NCOUNT == 48, which
!>                  occurred shortly after NCOUNT = NCOUNT + 1 in the
!>                  same time-step. Average daily streamflow is
!>                  calculated between 23:30-24:00 after the fix. The
!>                  change causes results in MESH_output_streamflow.csv
!>                  and MESH_output_streamflow_cumulative.csv to differ
!>                  by the amount of flow calculated between
!>                  23:30-24:00. Metrics calculated based on streamflow
!>                  also change. The daily runoff generated by CLASS
!>                  remains unchanged.
!>                  Because metrics and streamflow results differ
!>                  between this and prior revisions, r909 might be
!>                  considered the start of MESH 1.4.
!>
!>       JAN 2013 - K.C.KORNELSEN
!>                - INCORPORATED LOCATION FLAG FOR INCREASING PRECISION
!>                - OF STREAMFLOW AND RESERVOIR INPUTS
!>                - INCLUDED NSE AND NEGATIVE NSE AS OBJFN'S
!>       JAN 2014 - M. MACDONALD.  INCORPORATED BLOWING SNOW ALGORITHMS
!>       AUG 2013 - M. MACDONALD
!>                - INCORPORATE OPTIONAL COUPLING OF CLASS WITH CTEM
!>                - MOVE SOME INITIALIZATION AND SCATTER OF CLASS
!>                  DIAGNOSTIC VARIABLES IN TO MESH_DRIVER
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.

    use sa_mesh_shared_variabletypes
    use sa_mesh_shared_variables

    use EF_MODULE
    use MESH_INPUT_MODULE
    use FLAGS

    use module_mpi_flags
    use module_mpi_shared_variables
    use module_mpi

    use sa_mesh_run_within_tile
    use sa_mesh_run_within_grid
    use sa_mesh_run_between_grid

    use MODEL_OUTPUT
    use model_output_variabletypes
    use climate_forcing
    use model_dates
    use SIMSTATS_config
    use SIMSTATS
    use model_files_variabletypes
    use model_files_variables
    use model_files
    use strings

    use process_CLASS_constants
    use process_CLASS_variables
    use process_CLASS_config

    implicit none

    !> ierr: For status return from MPI
    !> istop: To stop all MPI process
    !* inp: Number of active tasks.
    !* ipid: Current process ID.
    integer :: ierr = 0
    integer ipid_recv, itag, ierrcode, istop
    logical lstat

    integer iun, u, invars

    !+ For split-vector approach
    integer ii1, ii2, iilen

    integer, dimension(:), allocatable :: irqst
    integer, dimension(:, :), allocatable :: imstat

!todo: Investigate what this is
    integer ireport

    !> Local variables.
    integer NA, NTYPE, NML, IGND, ik, jk

!>  INTEGER CONSTANTS.
    integer, parameter :: M_C = 5

!INTEGER IGND
    real IGND_TEST, IGND_DEEP

!> IOSTAT VARIABLE
    integer IOS

!> FOR OUTPUT
    character(450) GENDIR_OUT

!todo clean up commets and arrange variables a bit better

!> SCA variables

!todo clean up comments and make sure the variables
!todo are in groups that make sense
    real basin_SCA
    real basin_SWE

!> FOR INITIALIZATION OF BASIN STORAGE
    integer JAN
    integer imonth_now, imonth_old

!>     FOR ROUTING
!* WF_R1: MANNING'S N FOR RIVER CHANNEL
!* WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
    real WF_R1(M_C), WF_R2(M_C)

!>==========
!>
!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
    character(10) wf_landclassname(10)
    integer(kind = 4) wfo_yy, wfo_mm, wfo_dd, wfo_hh, wfo_mi, wfo_ss, &
        wfo_ms, nj, ensim_month, ensim_day
    integer(kind = 4) WFO_SEQ, ENSIM_IOS
    integer(kind = 4) CURREC
!> End of ENSIM Changes 
!>== ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

!> *******************************************************************
!> For reading in the last information in mesh_paramters_hydrology.ini
!> *******************************************************************
    character(30) NMTESTFORMAT

!>=======================================================================
!>     * DIMENSION STATEMENTS

!> FIRST SET OF DEFINITIONS:

!> BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!> VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!> THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!> MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!> "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!> A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!> ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!> GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!> DIAGNOSTIC VARIABLES.

!> THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!> REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!> LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!> NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!> SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!> ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!> NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!> VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!> DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!> THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!> "ROW" VARIABLES.

!>     * CONSTANTS (PARAMETER DEFINITIONS):

!* M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
!* M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
!* M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
!* M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
!* M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
!* M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS

!* VERSION: MESH_DRIVER VERSION
!* RELEASE: PROGRAM RELEASE VERSIONS
!> ANDY * VER_OK: IF INPUT FILES ARE CORRECT VERSION FOR PROGRAM
    character(24) :: VERSION = 'TRUNK (918)'
!+CHARACTER :: VERSION*24 = 'TAG'
    character(8) RELEASE
    logical VER_OK
!>
!>*******************************************************************
!>
!> OPERATIONAL VARIABLES:

!* IOS: IOSTAT (ERROR) RETURN ON READ EXTERNAL FILE
!* IY: Y-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* JX: X-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* NN: GRID SQUARE, USED TO READ DRAINAGE DATABASE
!* II: GRU, USED TO READ DRAINAGE DATABASE
!* JAN: IS USED TO INITIALISE BASEFLOW (WHEN JAN = 1)
!* N: COUNTER USED BY CLASS
!* NCOUNT: HALF-HOURLY BASED TIME STEP (200 LOOP)
!* NSUM: NUMBER OF ITERATIONS, TIME STEPS PASSED (200 LOOP)
!* NSUM_TOTAL: total number of iterations
!* i: COUNTER
!* j: COUNTER
!* k: COUNTER
!* l: COUNTER
!* m: COUNTER
!* CONFLAGS: NUMBER OF CONTROL FLAGS
!* OPTFLAGS: NUMBER OF OPTFLAGS
!* INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
!* DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
!* PAS: STAT (ERROR) RETURN ON ALLOCATE VARIABLE
!* OPN: OPENED RETURN ON INQUIRE STATEMENT (USED TO CHECK IF AN
!*      EXTERNAL FILE HAS BEEN OPENED BY THE PROGRAM)
!* FILE_VER: FILE VERSION USED TO SEEK INPUT FILE COMPATIBILITY
!*           (COMPARED TO "RELEASE")
    character(8) FILE_VER
    integer :: N = 0, NCOUNT, NSUM
    integer i, j, k, l, m, &
        INDEPPAR, DEPPAR, PAS, NSUM_TOTAL
    logical OPN

    integer DRIVERTIMESTEP

    integer FRAME_NO_NEW

!> GRID OUTPUT POINTS
!* BNAM: TEMPORARY HOLD FOR OUTPUT DIRECTORY (12 CHARACTER STRING)
!    character(12) BNAM

!>PBSM VARIABLES (GRU)
!* DrySnow: 0 = air temperature above 0 degC
!*          1 = air temperature below 0 degC
!* SnowAge: hours since last snowfall
!* Drift: blowing snow transport (kg/m^2)
!* Subl: blowing snow sublimation (kg/m^2)
!    real, dimension(:), allocatable :: DrySnowGAT, SnowAgeGAT, &
!        TSNOdsGAT, RHOSdsGAT, DriftGAT, SublGAT, DepositionGAT
!    real, dimension(:, :), allocatable :: DrySnowROW, SnowAgeROW, &
!        TSNOdsROW, RHOSdsROW, DriftROW, SublROW, DepositionROW

!>CLASS SUBAREA VARIABLES NEEDED FOR PBSM
!    real, dimension(:), allocatable :: ZSNOCS, ZSNOGS, ZSNOWC, ZSNOWG, &
!        HCPSCS, HCPSGS, HCPSC, HCPSG, TSNOWC, TSNOWG, &
!        RHOSC, RHOSG, XSNOWC, XSNOWG, XSNOCS, XSNOGS

!* PBSM parameters
!  fetch: fetch distance (m)
!  Ht: vegetation height (m)
!  N_S:vegetation density (number/m^2)
!  A_S: vegetation width (m)
!  Distrib: Inter-GRU snow redistribution factor
!    real, dimension(:), allocatable :: &
!        fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT

!> WATROF FLAGS AND VARIABLES:
!* VICEFLG: VERTICAL ICE FLAG OR LIMIT
!* HICEFLG: HORIZONTAL ICE FLAG OR LIMIT
!    integer LZFFLG, EXTFLG, IWFICE, ERRFLG, IWFOFLW
!    real VICEFLG, PSI_LIMIT, HICEFLG
!    real, dimension(:, :), allocatable :: BTC, BCAP, DCOEFF, BFCAP, &
!        BFCOEFF, BFMIN, BQMAX

!> MAM - logical variables to control simulation runs:
    logical :: ENDDATE = .false., ENDDATA = .false.

!> OUTPUT VARIABLES:
!> THE SUFFIX "ACC" REFERS TO THE ACCUMULATOR ARRAYS USED IN
!> CALCULATING TIME AVERAGES.
!* ALL: DEFINITIONS IN CLASS DOCUMENTATION
!    real, dimension(:), allocatable :: PREACC, GTACC, QEVPACC, &
!        HFSACC, ROFACC, SNOACC, ALVSACC, ALIRACC, FSINACC, FLINACC, &
!        TAACC, UVACC, PRESACC, QAACC, EVAPACC, FLUTACC, ROFOACC, &
!        ROFSACC, ROFBACC, HMFNACC, WTBLACC, WSNOACC, RHOSACC, TSNOACC, &
!        TCANACC, RCANACC, SCANACC, GROACC, CANARE, SNOARE, ZPNDACC

!> FIELD OF DELTA STORAGE AND INITIAL STORAGE
    real, dimension(:), allocatable :: DSTG, STG_I

!    real, dimension(:, :), allocatable :: TBARACC, THLQACC, THICACC, &
!        THALACC , THLQ_FLD, THIC_FLD, GFLXACC

!* TOTAL_ROFACC: TOTAL RUNOFF
!* TOTAL_EVAPACC: TOTAL EVAPORATION
!* TOTAL_PREACC: TOTAL PRECIPITATION
!* INIT_STORE: INITIAL STORAGE
!* FINAL_STORE: FINAL STORAGE
!* TOTAL_AREA: TOTAL FRACTIONED DRAINAGE AREA
    real TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
        TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
        FINAL_STORE, TOTAL_AREA, &
        TOTAL_PRE_ACC_M, TOTAL_EVAP_ACC_M, TOTAL_ROF_ACC_M, &
        TOTAL_ROFO_ACC_M, TOTAL_ROFS_ACC_M, TOTAL_ROFB_ACC_M, &
        TOTAL_PRE_M, TOTAL_EVAP_M, TOTAL_ROF_M, &
        TOTAL_ROFO_M, TOTAL_ROFS_M, TOTAL_ROFB_M, &
        TOTAL_SCAN_M, TOTAL_RCAN_M, &
        TOTAL_SNO_M, TOTAL_WSNO_M, &
        TOTAL_ZPND_M, &
        TOTAL_STORE_M, TOTAL_STORE_2_M, &
        TOTAL_STORE_ACC_M

!* TOTAL_HFS = TOTAL SENSIBLE HEAT FLUX
!* TOTAL_QEVP = TOTAL LATENT HEAT FLUX
    real TOTAL_HFSACC, TOTAL_QEVPACC

    real TOTAL_STORE, TOTAL_STORE_2, TOTAL_RCAN, TOTAL_SCAN, TOTAL_SNO, TOTAL_WSNO, TOTAL_ZPND
    real TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
    real, dimension(:), allocatable :: TOTAL_THLQ, TOTAL_THIC, &
        TOTAL_THLQ_M, TOTAL_THIC_M

!> CTEM-RELATED FIELDS (NOT USED IN STANDARD OFFLINE CLASS RUNS).
!    real, dimension(:), allocatable :: &
!        CO2CONC, COSZS, XDIFFUSC, CFLUXCG, CFLUXCS
!    real, dimension(:, :), allocatable :: &
!        AILCG, AILCGS, FCANC, FCANCS, CO2I1CG, CO2I1CS, CO2I2CG, CO2I2CS, &
!        SLAI, FCANCMX, ANCSVEG, ANCGVEG, RMLCSVEG, RMLCGVEG, &
!        AILC, PAIC, &
!        FIELDSM, WILTSM
!    real, dimension(:, :, :), allocatable :: &
!        RMATCTEM, RMATC
!    integer, dimension(:), allocatable :: NOL2PFTS
!    integer ICTEMMOD, L2MAX

!    real, dimension(3) :: THPORG, THRORG, THMORG, BORG, PSISORG, &
!        GRKSORG

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

    integer SUBBASINCOUNT
    integer, dimension(:), allocatable :: SUBBASIN

!> These are the types defined in mesh_input_module.f that contain arrays
!> that need to be allocated in read_initial_inputs.f.
    type(ShedGridParams) :: shd
    type(SoilLevels) :: sl
    type(SoilValues) :: sv
    type(HydrologyParameters) :: hp
    type(fl_ids) :: fls

    !* printoutwb: Print components of the water balance to the
    !*             console if enabled.
    logical printoutwb

    !* printoutstfl: Print members of the simulation hydrograph to the
    !*               console if enabled.
    logical printoutstfl, printoutqhyd

!>THESE ARE THTE TYPES DEFINED IN MODEL_OUTPUT.F95 NEED TO WRITE OUTPUT FIELD ACCUMULATED
!> OR AVERAGE FOR THE WATER BALANCE AND SOME OTHER STATES VARIABLES
    type(OUT_FLDS) :: VR
    type(dates_model) :: ts
    type(iter_counter) :: ic
    type(INFO_OUT) :: ifo
    type(CLIM_INFO) :: cm
    type(met_data) :: md
    type(water_balance) :: wb, wb_h
    type(energy_balance) :: eb
    type(soil_statevars) :: sp
    type(streamflow_hydrograph) :: stfl
    type(reservoir_release) :: rrls

    logical R2COUTPUT
    integer, parameter :: R2CFILEUNITSTART = 500
    integer NR2C, DELTR2C, NR2CFILES, NR2CSTATES, NR2C_R, DELTR2C_R, NR2C_S, DELTR2C_S
    integer, allocatable, dimension(:) :: GRD, GAT, GRDGAT, GRD_R, GAT_R, GRDGAT_R, GRD_S, GAT_S, GRDGAT_S
    character(50), allocatable, dimension(:, :) :: R2C_ATTRIBUTES, R2C_ATTRIBUTES_R, R2C_ATTRIBUTES_S

!    integer NMELT
!    real SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS
!    integer, dimension(:), allocatable :: INFILTYPE
!    real, dimension(:), allocatable :: SI, TSI, SNOWMELTD, SNOWMELTD_LAST, &
!        SNOWINFIL, CUMSNOWINFILCS, MELTRUNOFF, CUMSNOWINFILGS

!* PDMROF
!    real ZPND, FSTR
!    real, dimension(:), allocatable   :: CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM, &
!        ZPNDPRECS, ZPONDPREC, ZPONDPREG, ZPNDPREGS, &
!        UM1CS, UM1C, UM1G, UM1GS, &
!        QM1CS, QM1C, QM1G, QM1GS, &
!        QM2CS, QM2C, QM2G, QM2GS, UMQ, &
!        FSTRCS, FSTRC, FSTRG, FSTRGS

! To use with variable format expressions in writing some output files
    character(20) IGND_CHAR
    character(2000) FMT

    character(500) WRT_900_1, WRT_900_2, WRT_900_3, WRT_900_4, WRT_900_f
    character(500) fl_listMesh
    character(5) strInt

!> THE FOLLOWING COMMON BLOCKS ARE DEFINED FOR WATROF
!    data VICEFLG/3.0/, PSI_LIMIT/1.0/, HICEFLG/1.0/, LZFFLG/0/, &
!        EXTFLG/0/, IWFICE/3/, ERRFLG/1/

    real :: startprog, endprog
    integer :: narg
!real :: alpharain
!character*50 :: alphCh

!> ((((((((((((((((((((((((((((((((((
!> Set the acceptable version numbers
!> ))))))))))))))))))))))))))))))))))
!> todo this should be input file dependant,
!>  because different files will work with different releases
!>  so, make them local variables inside each read subroutine.
    RELEASE = '1.4'

    call cpu_time(startprog)
!>=======================================================================
!>      PROGRAM START

    !> Initialize MPI.
    call mpi_init(ierr)
    if (ierr /= mpi_success) then
        print *, 'Failed to initialize MPI.'
        call mpi_abort(mpi_comm_world, ierrcode, ierr)
        print *, 'ierrcode ', ierrcode, 'ierr ', ierr
    end if

    !> Grab number of total processes and current process ID.
    call mpi_comm_size(mpi_comm_world, inp, ierr)
    call mpi_comm_rank(mpi_comm_world, ipid, ierr)

    !> izero is active if the head node is used for booking and lateral flow
    !> processes.
    if (inp > 1) then
        izero = 1
    else
        izero = 0
    end if

    !> Reset verbose flag for worker nodes.
    if (ipid > 0) ro%VERBOSEMODE = 0

!>!TODO: UPDATE THIS (RELEASE(*)) WITH VERSION CHANGE
    if (ro%VERBOSEMODE > 0) print 951, trim(RELEASE), trim(VERSION)

951 format(1x, 'MESH ', a, ' ---  (', a, ')', /)

!File handled for variable in/out names
!At the moment only class,hydro parameters and some outputs

    !> Check if any command line arguments are found.
    narg = command_argument_count()
    !print *, narg
    if (narg > 0) then
        VARIABLEFILESFLAG = 1
        if (narg >= 1) then
            call get_command_argument(1, fl_listMesh)
!            print *, fl_listMesh
!        else if (narg == 2) then
!            call get_command_argument(1, fl_listMesh)
!            print *, fl_listMesh
!todo: re-instate alpha
!            call get_command_argument(2, alphCh)
!            call value(alphCh, alpharain, ios)
!            cm%clin(8)%alpharain = alpharain
!            print *, cm%clin(8)%alpharain
        end if
        call Init_fls(fls, trim(adjustl(fl_listMesh)))
    else
!todo: Call this anyway, make loading values from file an alternate subroutine of module_files
        call Init_fls(fls)
    end if !(narg > 0) then

    !> Determine the value of IGND from MESH_input_soil_levels.txt
!todo: Move this to read_soil_levels
    shd%lc%IGND = 0

    !> Open soil levels file and check for IOSTAT errors.
    iun = fls%fl(mfk%f52)%iun
    open(iun, file = trim(adjustl(fls%fl(mfk%f52)%fn)), status = 'old', action = 'read', iostat = ios)
    if (ios /= 0) then
        print 1002
        stop
    end if

    !> Count the number of soil layers.
    IGND_TEST = 1.0
    do while (IGND_TEST /= 0.0 .and. ios == 0)
        read(52, *, iostat = ios) IGND_TEST, IGND_DEEP
        shd%lc%IGND = shd%lc%IGND + 1
    end do

    !> because IGND increments the first time that IGND_TEST = 0.0
    shd%lc%IGND = shd%lc%IGND - 1
    print *, 'IGND = ', shd%lc%IGND
    close(iun)

1002 format(/1x, 'MESH_input_soil_levels.txt could not be opened.', &
            /1x, 'Ensure that the file exists and restart the program.', /)

    call READ_INITIAL_INPUTS( &
!>GENERIC VARIABLES
                             RELEASE, &
!>VARIABLES FOR READ_RUN_OPTIONS
                             GENDIR_OUT, &
 !>variables for READ_PARAMETERS_HYDROLOGY
                             INDEPPAR, DEPPAR, WF_R2, M_C, &
 !>the types that are to be allocated and initialised
                             shd, &
                             sl, &
                             sv, hp, ts, cm, &
                             SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS, fls)

!>***********************************************************************
!> Forcing data time step should not be less than 30 min - there is no
!> any increase in accuracy as delt (CLASS model time step) is 30 min.
!>=======================================================================

!todo: Move this to climate module.
    if (HOURLYFLAG < 30) then
        print 1028
        stop
    end if

1028 format(/1x, 'FORCING DATA TIME STEP IS LESS THAN 30 MIN', &
            /1x, 'AGGREGATE THE FORCING DATA TO 30 MIN INTERVAL AND TRY AGAIN', /)

!>
!>***********************************************************************
!> MAM - Check for parameter values - all parameters should lie within the
!> specified ranges in the "minmax_parameters.txt" file.
!>=======================================================================
!>
!    call check_parameters(WF_R2, M_C, NMTEST, cp, hp, soil_por_max, soil_depth, s0, t_ice_lens)

    !> Assign shed values to local variables.
    NA = shd%NA
    NTYPE = shd%lc%NTYPE
    IGND = shd%lc%IGND

    call run_within_tile_ini(shd, fls, ts, ic, cm, wb, eb, sp, stfl, rrls)

    call init_iter_counter(ic, YEAR_NOW, JDAY_NOW, HOUR_NOW, MINS_NOW, int(DELT))

!> Set value of FAREROW:
!todo - flag this as an issue to explore later and hide basin average code
!todo - document the problem
    !FUTUREDO: Bruce, FRAC is calculated by EnSim
    ! using Dan Princz's instructions for EnSim
    ! FRAC can be greater than 1.00
    ! So, we cannot use FAREROW in place of BASIN_FRACTION
    TOTAL_AREA = sum(cp%FAREROW)

    NML = shd%lc%NML

!todo+++: Perhaps land-unit indexing can be done prior in the sequence
!todo+++: of initialization, after reading the drainage database.
!todo+++: Then, variables could be allocated (il1:il2) instead of
!todo+++: (1:ILG) to reduce the memory footprint of the model per node.
!> *********************************************************************
!> Calculate Indices
!> *********************************************************************

!    call GetIndices(inp, izero, ipid, shd%lc%NML, shd%lc%ILMOS, il1, il2, ilen)
!    if (ro%DIAGNOSEMODE > 0) print 1062, ipid, shd%lc%NML, ilen, il1, il2

!1062 format(/1x, 'Configuration and distribution of the domain', &
!            /3x, 'Current process: ', i10, &
!            /3x, 'Tile land elements: ', i10, &
!            /3x, 'Length of single array: ', i10, &
!            /3x, 'Starting index: ', i10, &
!            /3x, 'Stopping index: ', i10, /)

!>=======================================================================
!> ALLOCATE ALL VARIABLES

1114 format(/1x, 'Error allocating ', a, ' variables.', &
            /1x, 'Check that these bounds are within an acceptable range.', /)
1118 format(3x, a, ': ', i6)

!> PBSM PROGNOSTIC VARIABLES
!    allocate(DrySnowROW(NA, NTYPE), SnowAgeROW(NA, NTYPE), &
!             DrySnowGAT(NML), SnowAgeGAT(NML), &
!             TSNOdsROW(NA, NTYPE), RHOSdsROW(NA, NTYPE), &
!             TSNOdsGAT(NML), RHOSdsGAT(NML), &
!             DriftROW(NA, NTYPE), SublROW(NA, NTYPE), DepositionROW(NA, NTYPE), &
!             DriftGAT(NML), SublGAT(NML), DepositionGAT(NML), &
!             ZSNOCS(NML), ZSNOGS(NML), &
!             ZSNOWC(NML), ZSNOWG(NML), &
!             HCPSCS(NML), HCPSGS(NML), &
!             HCPSC(NML), HCPSG(NML), &
!             TSNOWC(NML), TSNOWG(NML), &
!             RHOSC(NML), RHOSG(NML), &
!             XSNOWC(NML), XSNOWG(NML), &
!             XSNOCS(NML), XSNOGS(NML), stat = PAS)

!> LAND SURFACE PROGNOSTIC VARIABLES (for Basin_average_water_balance.csv):
    allocate(TOTAL_THLQ(IGND), TOTAL_THIC(IGND), &
             TOTAL_THLQ_M(IGND), TOTAL_THIC_M(IGND), stat = PAS)

    if (PAS /= 0) then
        print 1114, 'land surface prognostic'
        print 1118, 'Grid squares', NA
        print 1118, 'GRUs', NTYPE
        print 1118, 'Soil layers', IGND
        stop
    end if

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

    allocate(SUBBASIN(NML), stat = PAS)

    if (PAS /= 0) then
        print 1114, 'subbasin grid'
        print 1118, 'Grid squares', NA
        print 1118, 'GRUs', NTYPE
        print 1118, 'Total tile elements', NML
        stop
    end if

!    allocate( &
!             fetchGAT(NML), HtGAT(NML), N_SGAT(NML), A_SGAT(NML), &
!             DistribGAT(NML), stat = PAS)

!    if (PAS /= 0) then
!        print 1114, 'canopy and soil info.'
!        print 1118, 'Grid squares', NA
!        print 1118, 'GRUs', NTYPE
!        print 1118, 'Total tile elements', NML
!        print 1118, 'Canopy types with urban areas', ICP1
!        print 1118, 'Canopy types', ICAN
!        print 1118, 'Soil layers', IGND
!        stop
!    end if

!> WATROF FLAGS AND VARIABLES:
!    allocate(DDGAT(NML), MANNGAT(NML), stat = PAS)
!    if (PAS /= 0) then
!        print 1114, 'WATROF'
!        print 1118, 'Grid squares', NA
!        print 1118, 'GRUs', NTYPE
!        print 1118, 'Total tile elements', NML
!        stop
!    end if

!> OUTPUT VARIABLES:
    allocate(PREACC(NA), GTACC(NA), QEVPACC(NA), &
             HFSACC(NA), ROFACC(NA), SNOACC(NA), ALVSACC(NA), ALIRACC(NA), &
             FSINACC(NA), FLINACC(NA), &
             TAACC(NA), UVACC(NA), PRESACC(NA), QAACC(NA), EVAPACC(NA), &
             FLUTACC(NA), ROFOACC(NA), &
             ROFSACC(NA), ROFBACC(NA), HMFNACC(NA), WTBLACC(NA), ZPNDACC(NA), &
             WSNOACC(NA), RHOSACC(NA), TSNOACC(NA), &
             TCANACC(NA), RCANACC(NA), SCANACC(NA), GROACC(NA), CANARE(NA), &
             SNOARE(NA), &
             TBARACC(NA, IGND), THLQACC(NA, IGND), THICACC(NA, IGND), &
             THALACC(NA, IGND), GFLXACC(NA, IGND), &
             STG_I(NA), DSTG(NA), THLQ_FLD(NA, IGND), THIC_FLD(NA, IGND), &
             stat = PAS)
    if (PAS /= 0) then
        print 1114, 'accumulator'
        print 1118, 'Grid squares', NA
        print 1118, 'Soil layers', IGND
        stop
    end if

!> CTEM ERRORS (CLASS):
!    allocate(CO2CONC(NML), COSZS(NML), XDIFFUSC(NML), CFLUXCG(NML), CFLUXCS(NML), &
!             AILCG(NML, ICTEM), AILCGS(NML, ICTEM), FCANC(NML, ICTEM), FCANCS(NML, ICTEM), &
!             CO2I1CG(NML, ICTEM), CO2I1CS(NML, ICTEM), CO2I2CG(NML, ICTEM), CO2I2CS(NML, ICTEM), &
!             SLAI(NML, ICTEM), FCANCMX(NML, ICTEM), ANCSVEG(NML, ICTEM), ANCGVEG(NML, ICTEM), &
!             RMLCSVEG(NML, ICTEM), RMLCGVEG(NML, ICTEM), &
!             AILC(NML, ICAN), PAIC(NML, ICAN), FIELDSM(NML, IGND), WILTSM(NML, IGND), &
!             RMATCTEM(NML, ICTEM, IGND), RMATC(NML, ICAN, IGND), NOL2PFTS(ICAN), stat = PAS)
!    if (PAS /= 0) then
!        print 1114, 'CTEM'
!        print 1118, 'Grid squares', NA
!        print 1118, 'GRUs', NTYPE
!        print 1118, 'Total tile elements', NML
!        print 1118, 'Canopy types', ICAN
!        print 1118, 'Soil layers', IGND
!        print 1118, 'CTEM flag', ICTEM
!        stop
!    end if

!> *********************************************************************
!>  Open additional output files
!> *********************************************************************

    if (ipid == 0 .and. BASINSWEOUTFLAG > 0) then
        open(85, file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/basin_SCA_alldays.csv')
        open(86, file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/basin_SWE_alldays.csv')
    end if !(BASINSWEOUTFLAG > 0) then

    if (ipid == 0) call run_between_grid_ini(shd, ts, ic, stfl, rrls, &
                                             LOCATIONFLAG, STREAMFLOWOUTFLAG, &
                                             GENDIR_OUT)

!> *********************************************************************
!> Set some more intial values and clear accumulators
!> *********************************************************************

    !> Read an intial value for geothermal flux from file.
    if (GGEOFLAG == 1) then
        iun = fls%fl(mfk%f18)%iun
        open(iun, file = trim(adjustl(fls%fl(mfk%f18)%fn)), status = 'old', action = 'read', iostat = ios)
        read(iun, *) GGEOGRD(1)
        close(iun)
    else
        GGEOGRD(1) = 0.0
    end if

!> ASSIGN VALUES OF LAT/LONG TO EACH SQUARE:
!> NOTE FROM FRANK
!> I got the equations to determine the actual length of a 
!> degree of latitude and longitude from this paper, thank you 
!> Geoff Kite (I have attached it):
!> http://www.agu.org/pubs/crossref/1994/94WR00231.shtml
!> This chunk of code is a way to put the actual values of 
!> longitude and latitude for each cell in a large basin.  
!> The original CLASS code just put in the same value for each cell.  
!> The problem is that the class.ini file only has a single value 
!> of long and lat (as it was only designed for a point).  So in order 
!> to get the values across the basin I assumed that the single value 
!> from the class.ini file is in the centre of the basin and then use 
!> information from the watflow.shd file to figure out the long/lat 
!> varies across the basin.  However, the watflod.shd file only gives 
!> information in kilometers not degrees of long/lat so I had 
!> to use the formulas from the above paper to go between the two.
!
!> The only value of DEGLAT is the one read in from the class.ini file, 
!> after that Diana uses RADJGRD (the value of latitude in radians) so 
!> after DEGLAT is used to calculate RADJGRD is it no longer used.  This 
!> is how it was in the original CLASS code.

	do i = 1, NA
        !LATLENGTH = shd%AL/1000.0/(111.136 - 0.5623*cos(2*(DEGLAT*PI/180.0)) + 0.0011*cos(4*(DEGLAT*PI/180.0)))
        !LONGLENGTH = shd%AL/1000.0/(111.4172*cos((DEGLAT*PI/180.0)) - 0.094*cos(3*(DEGLAT*PI/180.0)) + 0.0002*cos(5*(DEGLAT*PI/180.0)))
        RADJGRD(i) = ((shd%yOrigin + shd%yDelta*shd%yyy(i)) - shd%yDelta/2.0)*PI/180.0
        DLONGRD(i) = (shd%xOrigin + shd%xDelta*shd%xxx(i)) - shd%xDelta/2.0
        Z0ORGRD(i) = 0.0
        GGEOGRD(i) = GGEOGRD(1)
        ZDMGRD(i) = 10.0
        ZDHGRD(i) = 2.0
	end do

!> adjust NAA to the be number of outlet squares, as currently it is the
!> number of squares with outlets into other squares in the basin, and
!> we want it to be the number of squares with outlets to outside the
!> basin.
!todo - look into the logic of this and suggest how it could be changed
!-    shd%NAA = NA - shd%NAA

!> set initial values of ncount and nsum
! NCOUNT = which half-hour period the current time is:
! The first period (0:00-0:30) is #1, the last period (23:30-0:00) is #48
    NCOUNT = HOUR_NOW*2 + MINS_NOW/TIME_STEP_MINS + 1
    NSUM = 1
    NSUM_TOTAL = 1

!> **********************************************************************
!>  Start of section to only run on squares that make up the watersheds
!>  that are listed in the streamflow file (subbasin)
!> **********************************************************************

!+    if (SUBBASINFLAG > 0) then
!+        do i = 1, NA
!+            SUBBASIN(i) = 0
!+        end do

!> Set values at guages to 1
!+        do i = 1, WF_NO
!+            SUBBASIN(WF_S(i)) = 1
!+        end do

!> Set values of subbasin to 1 for all upstream grids
!+        SUBBASINCOUNT = 1
!+        do while (SUBBASINCOUNT > 0)
!+            SUBBASINCOUNT = 0
!+            do i = 1, NA - 1
!+                if (SUBBASIN(shd%NEXT(i)) == 1 .and. SUBBASIN(i) == 0) then
!+                    SUBBASIN(i) = 1
!+                    SUBBASINCOUNT = SUBBASINCOUNT + 1
!+                end if
!+            end do
!+        end do !while (SUBBASINCOUNT > 0)

!> Set values of frac to 0 for all grids non-upstream grids
!+        SUBBASINCOUNT = 0
!+        do i = 1, NA
!+            if (SUBBASIN(i) == 0) then
!+                shd%FRAC(i) = 0.0
!+            else
!+                SUBBASINCOUNT = SUBBASINCOUNT + 1
!+            end if
!+        end do

  !> MAM - Write grid number, grid fractional area and percentage of GRUs in each grid
!+        open(10, file = 'subbasin_info.txt')
!+        write(10, '(a7, 3x, a18, 3x, a58)') &
!+            'GRID NO', 'GRID AREA FRACTION', 'GRU FRACTIONS, GRU 1, GRU 2, GRU 3,... IN INCREASING ORDER'
!+        do i = 1, NA
!+            if (SUBBASIN(i) == 0) then
!+            else
!+                write(10, '(i5, 3x, f10.3, 8x, 50(f10.3, 3x))') i, shd%FRAC(i), (shd%lc%ACLASS(i, m), m = 1, NMTEST)
!+            end if
!+        end do
!+        close(10)

!+    end if !(SUBBASINFLAG > 0) then

!> **********************************************************************
!>  End of subbasin section
!> **********************************************************************

!> Initialize output variables.
    call init_water_balance(wb, shd)
    wb%grid_area = 0.0
    wb%basin_area = 0.0
    do i = 1, NA
        do m = 1, NTYPE
            wb%grid_area(i) = wb%grid_area(i) + cp%FAREROW(i, m)
        end do
        wb%basin_area = wb%basin_area + wb%grid_area(i)
    end do

    call climate_module_init(shd, ts, cm, NML, il1, il2, ENDDATA)
    if (ENDDATA) goto 999

!> *********************************************************************
!> Initialize water balance output fields
!> *********************************************************************

    if (ipid == 0) then
        call init_energy_balance(eb, shd)
        call init_soil_statevars(sp, shd)
        call init_met_data(md, shd)
        call init_water_balance(wb_h, shd)
        if (OUTFIELDSFLAG == 1) call init_out(shd, ts, ic, ifo, vr)
    end if !(ipid == 0) then

    DRIVERTIMESTEP = DELT    ! Be sure it's REAL*8

!* JAN: The first time throught he loop, jan = 1. Jan will equal 2 after that.
    JAN = 1

!todo - check that this is compatible with Saul's pre-distributed soil moisture and soil temp.
    do i = 1, NA
        do m = 1, NTYPE
            do j = 1, IGND
                cp%TBARROW(i, m, j) = cp%TBARROW(i, m, j) + TFREZ
            end do
            cp%TSNOROW(i, m) = cp%TSNOROW(i, m) + TFREZ
            cp%TCANROW(i, m) = cp%TCANROW(i, m) + TFREZ
            cp%TPNDROW(i, m) = cp%TPNDROW(i, m) + TFREZ
            TBASROW(i, m) = cp%TBARROW(i, m, IGND)
            CMAIROW(i, m) = 0.0
            WSNOROW(i, m) = 0.0
            TSFSROW(i, m, 1) = TFREZ
            TSFSROW(i, m, 2) = TFREZ
            TSFSROW(i, m, 3) = cp%TBARROW(i, m, 1)
            TSFSROW(i, m, 4) = cp%TBARROW(i, m, 1)
            TACROW(i, m) = cp%TCANROW(i, m)
            QACROW(i, m) = 0.5e-2
            if (IGND > 3) then ! should stay this way to work with class

                !todo - if we have time, change this so that soil.ini can take more than 3 layers.
                if (NRSOILAYEREADFLAG == 0) then
                    do j = 4, IGND
                        cp%THLQROW(i, m, j) = cp%THLQROW(i, m, 3)
                        cp%THICROW(i, m, j) = cp%THICROW(i, m, 3)
                        cp%TBARROW(i, m, j) = cp%TBARROW(i, m, 3)
                        if (cp%SDEPROW(i, m) < (sl%ZBOT(j - 1) + 0.001) .and. cp%SANDROW(i, m, 3) > -2.5) then
                            cp%SANDROW(i, m, j) = -3.0
                            cp%CLAYROW(i, m, j) = -3.0
                            cp%ORGMROW(i, m, j) = -3.0
                        else
                            cp%SANDROW(i, m, j) = cp%SANDROW(i, m, 3)
                            cp%CLAYROW(i, m, j) = cp%CLAYROW(i, m, 3)
                            cp%ORGMROW(i, m, j) = cp%ORGMROW(i, m, 3)
                        end if
                    end do
                else
                    do j = 4, IGND
                        if (cp%SDEPROW(i, m) < (sl%ZBOT(j - 1) + 0.001) .and. cp%SANDROW(i, m, 3) > -2.5) then
                            cp%SANDROW(i, m, j) = -3.0
                            cp%CLAYROW(i, m, j) = -3.0
                            cp%ORGMROW(i, m, j) = -3.0
                        end if
                    end do
                end if !if (NRSOILAYEREADFLAG == 0) then
            end if !(IGND > 3) then
            do k = 1, 6
                do l = 1, 50
                    ITCTROW(i, m, k, l) = 0
                end do
            end do
        end do !m = 1, NTYPE
    end do !i = 1, NA

!> clear accumulating variables
    TOTAL_ROF = 0.0
    TOTAL_ROFO = 0.0
    TOTAL_ROFS = 0.0
    TOTAL_ROFB = 0.0
    TOTAL_EVAP = 0.0
    TOTAL_PRE = 0.0
    TOTAL_ROFACC = 0.0
    TOTAL_ROFOACC = 0.0
    TOTAL_ROFSACC = 0.0
    TOTAL_ROFBACC = 0.0
    TOTAL_EVAPACC = 0.0
    TOTAL_PREACC = 0.0
    TOTAL_HFSACC = 0.0
    TOTAL_QEVPACC = 0.0

    ! For monthly totals.
    TOTAL_ROF_M = 0.0
    TOTAL_ROFO_M = 0.0
    TOTAL_ROFS_M = 0.0
    TOTAL_ROFB_M = 0.0
    TOTAL_EVAP_M = 0.0
    TOTAL_PRE_M = 0.0
    TOTAL_ROF_ACC_M = 0.0
    TOTAL_ROFO_ACC_M = 0.0
    TOTAL_ROFS_ACC_M = 0.0
    TOTAL_ROFB_ACC_M = 0.0
    TOTAL_EVAP_ACC_M = 0.0
    TOTAL_PRE_ACC_M = 0.0

!> *********************************************************************
!> Set accumulation variables to zero.
!> *********************************************************************

  !> Grid Variables
    PREACC = 0.0
    GTACC = 0.0
    QEVPACC = 0.0
    EVAPACC = 0.0
    HFSACC = 0.0
    HMFNACC = 0.0
    ROFACC = 0.0
    ROFOACC = 0.0
    ROFSACC = 0.0
    ROFBACC = 0.0
    WTBLACC = 0.0
    ALVSACC = 0.0
    ALIRACC = 0.0
    RHOSACC = 0.0
    SNOACC = 0.0
    WSNOACC = 0.0
    CANARE = 0.0
    SNOARE = 0.0
    TSNOACC = 0.0
    TCANACC = 0.0
    RCANACC = 0.0
    SCANACC = 0.0
    GROACC = 0.0
    FSINACC = 0.0
    FLINACC = 0.0
    FLUTACC = 0.0
    TAACC = 0.0
    UVACC = 0.0
    PRESACC = 0.0
    QAACC = 0.0
    wb%pre = 0.0
    wb%evap = 0.0
    wb%rof = 0.0
    wb%rofo = 0.0
    wb%rofs = 0.0
    wb%rofb = 0.0
    wb%rcan = 0.0
    wb%sncan = 0.0
    wb%sno = 0.0
    wb%wsno = 0.0
    wb%pndw = 0.0
    wb%lqws = 0.0
    wb%frws = 0.0
    if (ipid == 0) then
        eb%hfs = 0.0
        eb%qevp = 0.0
    end if

    !> Soil variables
    TBARACC = 0.0
    THLQACC = 0.0
    THICACC = 0.0
    THALACC = 0.0
    GFLXACC = 0.0
    if (ipid == 0) then
        sp%tbar = 0.0
        sp%thlq = 0.0
        sp%thic = 0.0
        eb%gflx = 0.0
    end if

    STG_I = 0.0
    DSTG = 0.0
    THLQ_FLD = 0.0
    THIC_FLD = 0.0
    wb%stg = 0.0
    wb%dstg = 0.0

    FRAME_NO_NEW = 1

    !> Determine what output will print to the console.
    printoutwb = (allocated(wb%pre) .and. allocated(wb%evap) .and. allocated(wb%rof))
    printoutstfl = allocated(stfl%qsyn)
    printoutqhyd = (allocated(stfl%qhyd) .and. allocated(stfl%qsyn))

    if (ipid == 0) then

!> ******************************************************
!> echo print information to MESH_output_echo_print.txt
!> ******************************************************

        if (MODELINFOOUTFLAG > 0) then
            open(58, file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/MESH_output_echo_print.txt')
            write(58, "('Number of Soil Layers (IGND) = ', i5)") IGND
            write(58, *)
            write(58, "('MESH_input_run_options.ini')")
            write(58, *)
            write(58, "('Configuration flags - specified by user or default values')")

        !todo: this list should be updated (dgp: 2015-01-09)
            write(58, *) 'BASINSHORTWAVEFLAG   = ', cm%clin(cfk%FB)%filefmt
            write(58, *) 'BASINLONGWAVEFLAG    = ', cm%clin(cfk%FI)%filefmt
            write(58, *) 'BASINRAINFLAG        = ', cm%clin(cfk%PR)%filefmt
            write(58, *) 'BASINTEMPERATUREFLAG = ', cm%clin(cfk%TT)%filefmt
            write(58, *) 'BASINWINDFLAG        = ', cm%clin(cfk%UV)%filefmt
            write(58, *) 'BASINPRESFLAG        = ', cm%clin(cfk%P0)%filefmt
            write(58, *) 'BASINHUMIDITYFLAG    = ', cm%clin(cfk%HU)%filefmt
            write(58, *) 'HOURLYFLAG           = ', HOURLYFLAG
            write(58, *) 'RESUMEFLAG           = ', RESUMEFLAG
            write(58, *) 'SAVERESUMEFLAG       = ', SAVERESUMEFLAG
            write(58, *) 'SHDFILEFLAG          = ', SHDFILEFLAG
            write(58, *) 'SOILINIFLAG          = ', SOILINIFLAG
            write(58, *) 'STREAMFLOWFLAG       = ', STREAMFLOWFLAG
            write(58, *) 'CONFLAGS             = ', CONFLAGS
            write(58, *) 'RELFLG               = ', RELFLG
            write(58, *) 'OPTFLAGS             = ', OPTFLAGS
            write(58, *) 'PREEMPTIONFLAG       = ', mtsflg%PREEMPTIONFLAG
            write(58, *) 'INTERPOLATIONFLAG    = ', INTERPOLATIONFLAG
            write(58, *) 'SUBBASINFLAG         = ', SUBBASINFLAG
            write(58, *) 'TESTCSVFLAG          = ', 'NOTSUPPORTED'
            write(58, *) 'R2COUTPUTFLAG        = ', R2COUTPUTFLAG
            write(58, *) 'OBJFNFLAG            = ', OBJFNFLAG
            write(58, *) 'AUTOCALIBRATIONFLAG  = ', mtsflg%AUTOCALIBRATIONFLAG
            write(58, *) 'WINDOWSIZEFLAG       = ', WINDOWSIZEFLAG
            write(58, *) 'WINDOWSPACINGFLAG    = ', WINDOWSPACINGFLAG
            write(58, *) 'FROZENSOILINFILFLAG  = ', FROZENSOILINFILFLAG
            write(58, *) 'LOCATIONFLAG         = ', LOCATIONFLAG

        !> MAM - ALLOCATE AND INITIALIZE INTERPOLATION VARIABLES:
        !> For 30 minute forcing data there is no need for interpolation and
        !> hence no need to assign PRE and PST variables
            if (INTERPOLATIONFLAG > 1 .or. (INTERPOLATIONFLAG == 1 .and. sum(cm%clin(:)%hf) == 210)) then
                print 9000
                write(58, 9000)
                INTERPOLATIONFLAG = 0
            end if !(INTERPOLATIONFLAG > 1 .or. (INTERPOLATIONFLAG == 1 .and. sum(cm%clin(:)%hf) == 210)) then
!todo: restore this.
!            write(58, "('WF_NUM_POINTS: ', i5)") WF_NUM_POINTS
!            write(58, "('Out directory:', 5a10)") (op%DIR_OUT(i), i = 1, WF_NUM_POINTS)
!            write(58, "('Grid number:  ', 5i10)") (op%N_OUT(i), i = 1, WF_NUM_POINTS)
!            write(58, "('Land class:   ', 5i10)") (op%II_OUT(i), i = 1, WF_NUM_POINTS)
            write(58, *)
            write(58, "('MESH_parameters_hydrology.ini')")
            write(58, *)
            write(58, "('Option flags:')")
            if (OPTFLAGS > 0) then
                do i = 1, OPTFLAGS
                    write(58, '(a11, i2, a19)') 'PARAMETER ', i, ' NOT CURRENTLY USED'
                end do
            end if
            write(58, "('River roughnesses:')")
!todo: change this to use NRVR
            write(58, '(5f6.3)') (WF_R2(i), i = 1, 5)
            write(58, "('Land class independent hydrologic parameters:')")
            if (FROZENSOILINFILFLAG == 1) then
                write(58, *) 'SOIL_POR_MAX = ', SOIL_POR_MAX
                write(58, *) 'SOIL_DEPTH   = ', SOIL_DEPTH
                write(58, *) 'S0           = ', S0
                write(58, *) 'T_ICE_LENS   = ', T_ICE_LENS
                do i = 5, INDEPPAR
                    j = i - 4
                    write(58, '(a38, i2, a3, f6.2)') 'OPPORTUNITY TIME FOR SIMULATION YEAR ', j, ' = ', t0_ACC(j)
                end do
            else
                do i = 1, INDEPPAR
                    write(58, '(a36, i2, a19)') 'FROZEN SOIL INFILTRATION PARAMETER ', i, ' READ BUT NOT USED'
                end do
            end if !(FROZENSOILINFILFLAG == 1) then
            write(58, "('Land class dependent hydrologic parameters:')")
            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZSNLROW'", NTYPE
            write(58, NMTESTFORMAT) (hp%ZSNLROW(1, m), m = 1, NTYPE)
            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLSROW'", NTYPE
            write(58, NMTESTFORMAT) (hp%ZPLSROW(1, m), m = 1, NTYPE)
            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLGROW'", NTYPE
            write(58, NMTESTFORMAT) (hp%ZPLGROW(1, m), m = 1, NTYPE)
            if (DEPPAR >= 4) then
                write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('FRZCROW'", NTYPE
                write(58, NMTESTFORMAT) (hp%FRZCROW(1, m), m = 1, NTYPE)
            end if
            write(58, *)
            write(58, "('MESH_parameters_CLASS.ini')")
            write(58, *)
            write(58, '(2x, 6a4)') TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6
            write(58, '(2x, 6a4)') NAME1, NAME2, NAME3, NAME4, NAME5, NAME6
            write(58, '(2x, 6a4)') PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6
            i = 1
            write(58, '(5f10.2, f7.1, 3i5)') &
                DEGLAT, DEGLON, cp%ZRFMGRD(i), cp%ZRFHGRD(i), cp%ZBLDGRD(i), cp%GCGRD(i), shd%wc%ILG, NA, NTYPE
            do m = 1, NTYPE
                write(58, '(9f8.3)') (cp%FCANROW(i, m, j), j = 1, ICAN + 1), (cp%PAMXROW(i, m, j), j = 1, ICAN)
                write(58, '(9f8.3)') (cp%LNZ0ROW(i, m, j), j = 1, ICAN + 1), (cp%PAMNROW(i, m, j), j = 1, ICAN)
                write(58, '(9f8.3)') (cp%ALVCROW(i, m, j), j = 1, ICAN + 1), (cp%CMASROW(i, m, j), j = 1, ICAN)
                write(58, '(9f8.3)') (cp%ALICROW(i, m, j), j = 1, ICAN + 1), (cp%ROOTROW(i, m, j), j = 1, ICAN)
                write(58, '(4f8.3, 8x, 4f8.3)') (cp%RSMNROW(i, m, j), j = 1, ICAN), (cp%QA50ROW(i, m, j), j = 1, ICAN)
                write(58, '(4f8.3, 8x, 4f8.3)') (cp%VPDAROW(i, m, j), j = 1, ICAN), (cp%VPDBROW(i, m, j), j = 1, ICAN)
                write(58, '(4f8.3, 8x, 4f8.3)') (cp%PSGAROW(i, m, j), j = 1, ICAN), (cp%PSGBROW(i, m, j), j = 1, ICAN)
                write(58, '(3f8.3, f8.4)') cp%DRNROW(i, m), cp%SDEPROW(i, m), cp%FAREROW(i, m), cp%DDROW(i, m)
                write(58, '(4e8.1, i8)') cp%XSLPROW(i, m), cp%XDROW(i, m), cp%MANNROW(i, m), cp%KSROW(i, m), cp%MIDROW(i, m)
                write(58, '(6f10.1)') (cp%SANDROW(i, m, j), j = 1, IGND)
                write(58, '(6f10.1)') (cp%CLAYROW(i, m, j), j = 1, IGND)
                write(58, '(6f10.1)') (cp%ORGMROW(i, m, j), j = 1, IGND)
                write(58, '(9f10.2)') (cp%TBARROW(i, m, j), j = 1, IGND), cp%TCANROW(i, m), cp%TSNOROW(i, m), cp%TPNDROW(i, m)
                write(58, '(10f10.3)') &
                    (cp%THLQROW(i, m, j), j = 1, IGND), (cp%THICROW(i, m, j), j = 1, IGND), cp%ZPNDROW(i, m)
                write(58, '(2f10.4, f10.2, f10.3, f10.4, f10.3, f10.3)') &
                    cp%RCANROW(i, m), cp%SCANROW(i, m), cp%SNOROW(i, m), cp%ALBSROW(i, m), cp%RHOSROW(i, m), cp%GROROW(i, m)
                write(58, *)
            end do !m = 1, NTYPE
        end if !(MODELINFOOUTFLAG > 0) then
    end if !(ipid == 0) then

    allocate(INFILTYPE(NML), SI(NML), TSI(NML), &
             SNOWMELTD(NML), SNOWMELTD_LAST(NML), SNOWINFIL(NML), &
             CUMSNOWINFILCS(NML), MELTRUNOFF(NML), CUMSNOWINFILGS(NML))
             
    NMELT = 1
    INFILTYPE = 2 !> INITIALIZED WITH UNLIMITED INFILTRATION
    SNOWMELTD = 0.0
    SNOWINFIL = 0.0
    CUMSNOWINFILCS = 0.0
    CUMSNOWINFILGS = 0.0
    MELTRUNOFF = 0.0
    SI = 0.20
    TSI = -0.10

!* PDMROF
    allocate(CMINPDM(NML), CMAXPDM(NML), BPDM(NML), K1PDM(NML), &
             K2PDM(NML), ZPNDPRECS(NML), ZPONDPREC(NML), ZPONDPREG(NML), &
             ZPNDPREGS(NML), &
             UM1CS(NML), UM1C(NML), UM1G(NML), UM1GS(NML), &
             QM1CS(NML), QM1C(NML), QM1G(NML), QM1GS(NML), &
             QM2CS(NML), QM2C(NML), QM2G(NML), QM2GS(NML), &
             UMQ(NML), &
             FSTRCS(NML), FSTRC(NML), FSTRG(NML), FSTRGS(NML))

!* PDMROF: INITIALIZE VARIABLES
    ZPNDPRECS = 0.0
    ZPONDPREC = 0.0
    ZPONDPREG = 0.0
    ZPNDPREGS = 0.0
    ZPND = 0.0
    UM1CS = 0.0
    UM1C = 0.0
    UM1G = 0.0
    UM1GS = 0.0
    QM1CS = 0.0
    QM1C = 0.0
    QM1G = 0.0
    QM1GS = 0.0
    QM2CS = 0.0
    QM2C = 0.0
    QM2G = 0.0
    QM2GS = 0.0
    UMQ = 0.0
    FSTRCS = 0.0
    FSTRC = 0.0
    FSTRG = 0.0
    FSTRGS = 0.0
    FSTR = 0.0

!>
!>****************CHECK RESUME FILE***************************************************
!>
!+    if (RESUMEFLAG == 1) then
!todo: can do this using inquire statement
!=        open(88, file = 'class_resume.txt', status = 'old', action = 'read', iostat = IOS)
!+        if (IOS /= 0) then
!+            if (ipid == 0 .and. MODELINFOOUTFLAG > 0) then
!+                write(58, *) "WARNING: You've specified a start time", ' without having a resume file. Now ending run.'
!+            end if
!+            print *, 'No class_resume.txt found.'
!+            print *, 'The RESUMEFLAG in MESH_input_run_options.ini is', &
!+                ' set to 1, which means that class_resume.txt should be here,', &
!+                ' but it is not here.'
!+            print *, 'Ending Run'
!+            stop
!+        end if
!+        close(88)
!+    end if

!> *********************************************************************
!> Open and print header information to the output files
!> *********************************************************************

    if (ipid == 0) then

!> *********************************************************************
!> Open and read in values from r2c_output.txt file
!> *********************************************************************

        NR2CFILES = 0
        if (R2COUTPUTFLAG >= 1) then
            inquire(file = 'r2c_output.txt', exist = R2COUTPUT)
            if (R2COUTPUT) then
                open(56, file = 'r2c_output.txt', action = 'read')
                read(56, *, iostat = IOS) NR2C, DELTR2C
                if (IOS == 0) then
                    allocate(GRD(NR2C), GAT(NR2C), GRDGAT(NR2C), R2C_ATTRIBUTES(NR2C, 3), stat = PAS)
                    if (PAS /= 0) then
                        print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                            'RECORD AT THE FIRST LINE IN THE r2c_output.txt FILE. ', &
                            'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
                        stop
                    end if
                end if
                if (IOS /= 0 .or. mod(DELTR2C, 30) /= 0) then
                    print 9002
                    stop
                end if
                print *
                print *, 'THE FOLLOWING R2C OUTPUT FILES WILL BE WRITTEN:'
                do i = 1, NR2C
                    read(56, *, iostat = IOS) GRD(i), GAT(i), GRDGAT(i), (R2C_ATTRIBUTES(i, j), j = 1, 3)
                    if (IOS /= 0) then
                        print *, 'ERROR READING r2c_output.txt FILE AT LINE ', i + 1
                        stop
                    else
                        if (GRD(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GRD)    : ', R2C_ATTRIBUTES(i, 3)
                        end if
                        if (GAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GAT)    : ', R2C_ATTRIBUTES(i, 3)
                        end if
                        if (GRDGAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GRDGAT) : ', R2C_ATTRIBUTES(i, 3)
                        end if
                    end if
                end do
                close(56)
            else
                print *
                print *, "r2c_output.txt FILE DOESN'T EXIST. ", &
                    'R2COUTPUTFLAG SHOULD BE SET TO ZERO IF R2C OUTPUTS ARE NOT NEEDED.'
                print *
                stop
            end if
        end if

!> WRITE THE HEADER FOR R2C FILES:
        if (NR2CFILES > 0) then
            call WRITE_R2C_HEADER(NTYPE, NR2C, NR2CFILES, GRD, GAT, GRDGAT, R2C_ATTRIBUTES, &
                                  R2CFILEUNITSTART, NR2CSTATES, shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
                                  shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta, shd%xCount, shd%yCount)
        end if

!> For the ENSIM timestamp
        wfo_seq = 0

    end if !(ipid == 0) then

!> End of ENSIM Changes

!> *********************************************************************
!> Output information to screen
!> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *, 'NUMBER OF GRID SQUARES: ', NA
        print *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NTYPE
        print *, 'NUMBER OF RIVER CLASSES: ', shd%NRVR
        print *, 'MINIMUM NUMBER FOR ILG: ', shd%lc%ILG
        print *, 'NUMBER OF GRID SQUARES IN West-East DIRECTION: ', shd%xCount
        print *, 'NUMBER OF GRID SQUARES IN South-North DIRECTION: ', shd%yCount
        print *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', shd%AL
        print *, 'NUMBER OF DRAINAGE OUTLETS: ', (NA - shd%NAA)
        print *
        print *
        print *
    end if !(ro%VERBOSEMODE > 0) then

    if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_init(ts, stfl%ns)

!>
!>*******************************************************************
!>
!> Check if we are reading in a resume file
!    if (RESUMEFLAG == 1) then
!        print *, 'Reading saved state variables'
!        call resume_state(HOURLYFLAG, MINS_NOW, TIME_STEP_NOW, &
!                          cm%clin(cfk%FB)%filefmt, cm%clin(cfk%FI)%filefmt, &
!                          cm%clin(cfk%PR)%filefmt, cm%clin(cfk%TT)%filefmt, &
!                          cm%clin(cfk%UV)%filefmt, cm%clin(cfk%P0)%filefmt, cm%clin(cfk%HU)%filefmt, &
!                          cm%clin(cfk%FB)%GRD, FSVHGRD, FSIHGRD, cm%clin(cfk%FI)%GRD, &
!                          i, j, shd%xCount, shd%yCount, jan, &
!                          VPDGRD, TADPGRD, PADRGRD, RHOAGRD, RHSIGRD, &
!                          RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, cm%clin(cfk%TT)%GRD, &
!                          cm%clin(cfk%HU)%GRD, cm%clin(cfk%PR)%GRD, RPREGRD, SPREGRD, cm%clin(cfk%P0)%GRD, &
!
!> MAM - FOR FORCING DATA INTERPOLATION
!                          FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
!                          TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &
!                          IPCP, NA, NA, shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
!                          shd%lc%NML, shd%wc%NML, &
!                          cp%GCGRD, cp%FAREROW, cp%MIDROW, NTYPE, NML, NMTEST, &
!                          cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                          cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                          cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
!                          FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
!                          PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
!                          VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
!                          HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
!                          THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
!                          GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
!                          PSIWGAT, cpv%DELZW, ZBTWGAT, ZSNLGAT, ZPLGGAT, &
!                          ZPLSGAT, cpv%TAC, cpv%QAC, DRNGAT, XSLPGAT, &
!                          XDGAT, WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, &
!                          ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ISNDGAT, &
!                          RADJGAT, cf%ZBLD, Z0ORGAT, cf%ZRFM, cf%ZRFH, &
!                          ZDMGAT, ZDHGAT, cf%FSVH, cf%FSIH, CSZGAT, &
!                          cf%FDL, cf%UL, cf%VL, cf%TA, cf%QA, cf%PRES, &
!                          cf%PRE, PADRGAT, VPDGAT, TADPGAT, RHOAGAT, &
!                          RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
!                          cf%FCLO, DLONGAT, GGEOGAT, cdv%CDH, cdv%CDM, &
!                          cdv%HFS, cdv%TFX, cdv%QEVP, cdv%QFS, cdv%QFX, &
!                          cdv%PET, cdv%GA, cdv%EF, cdv%GTE, cdv%QG, &
!                          cdv%ALVS, cdv%ALIR, cdv%SFCT, cdv%SFCU, cdv%SFCV, &
!                          cdv%SFCQ, cdv%FSNO, cdv%FSGV, cdv%FSGS, cdv%FSGG, &
!                          cdv%FLGV, cdv%FLGS, cdv%FLGG, cdv%HFSC, cdv%HFSS, &
!                          cdv%HFSG, cdv%HEVC, cdv%HEVS, cdv%HEVG, cdv%HMFC, &
!                          cdv%HMFN, cdv%HTCC, cdv%HTCS, cdv%PCFC, cdv%PCLC, &
!                          cdv%PCPN, cdv%PCPG, cdv%QFG, cdv%QFN, cdv%QFCL, &
!                          cdv%QFCF, cdv%ROF, cdv%ROFO, cdv%ROFS, cdv%ROFB, &
!                          cdv%TROF, cdv%TROO, cdv%TROS, cdv%TROB, cdv%ROFC, &
!                          cdv%ROFN, cdv%ROVG, cdv%WTRC, cdv%WTRS, cdv%WTRG, &
!                          cdv%DR, cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!                          IGND, ICAN, ICP1, &
!                          cp%TBARROW, cp%THLQROW, cp%THICROW, cp%TPNDROW, cp%ZPNDROW, &
!                          TBASROW, cp%ALBSROW, cp%TSNOROW, cp%RHOSROW, cp%SNOROW, &
!                          cp%TCANROW, cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, &
!                          cp%FCANROW, cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
!                          cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, cp%QA50ROW, &
!                          cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, cp%PSGBROW, PAIDROW, &
!                          HGTDROW, ACVDROW, ACIDROW, TSFSROW, WSNOROW, &
!                          THPROW, THRROW, THMROW, BIROW, PSISROW, &
!                          GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
!                          PSIWROW, DLZWROW, ZBTWROW, hp%ZSNLROW, hp%ZPLGROW, &
!                          hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, cp%DRNROW, cp%XSLPROW, &
!                          cp%XDROW, WFSFROW, cp%KSROW, ALGWROW, ALGDROW, &
!                          ASVDROW, ASIDROW, AGVDROW, AGIDROW, &
!                          ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
!                          cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, CSZGRD, &
!                          cm%clin(cfk%UV)%GRD, VLGRD, FCLOGRD, DLONGRD, GGEOGRD, &
!                          cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                          IGDRROW, IGDRGAT, VMODGRD, cf%VMOD, QLWOGAT, &
!                          CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
!                          WTVSTP, WTSSTP, WTGSTP, &
!                          sl%DELZ, cdv%FCS, cdv%FGS, cdv%FC, cdv%FG, N, &
!                          ALVSCN, ALIRCN, ALVSG, ALIRG, ALVSCS, &
!                          ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, &
!                          ALVSSC, ALIRSC, TRVSCN, TRIRCN, TRVSCS, &
!                          TRIRCS, FSVF, FSVFS, &
!                          RAICAN, RAICNS, SNOCAN, SNOCNS, &
!                          FRAINC, FSNOWC, FRAICS, FSNOCS, &
!                          DISP, DISPS, ZOMLNC, ZOMLCS, ZOELNC, ZOELCS, &
!                          ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
!                          CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, &
!                          CWFCAP, CWLCPS, CWFCPS, RC, RCS, RBCOEF, &
!                          FROOT, ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, &
!                          TRSNOW, ZSNOW, JDAY_NOW, JLAT, IDISP, &
!                          IZREF, IWF, IPAI, IHGT, IALC, IALS, IALG, &
!                          TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
!                          THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, &
!                          TCTOPG, TCBOTG, &
!                          GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
!                          G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
!                          QFREZC, QFREZG, QMELTC, QMELTG, &
!                          EVAPC, EVAPCG, EVAPG, EVAPCS, EVPCSG, EVAPGS, &
!                          TCANO, TCANS, TPONDC, TPONDG, TPNDCS, TPNDGS, &
!                          TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
!                          cdv%WTAB, &
!                          cdv%ILMO, cdv%UE, cdv%HBL, &
!                          shd%wc%ILG, ITC, ITCG, ITG, ISLFD, &
!                          NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
!                          cdv%GFLX, CDHROW, CDMROW, HFSROW, TFXROW, &
!                          QEVPROW, QFSROW, QFXROW, PETROW, GAROW, &
!                          EFROW, GTROW, QGROW, TSFROW, ALVSROW, &
!                          ALIRROW, SFCTROW, SFCUROW, SFCVROW, SFCQROW, &
!                          FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
!                          FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, &
!                          HEVSROW, HEVGROW, HMFCROW, HMFNROW, HTCCROW, &
!                          HTCSROW, PCFCROW, PCLCROW, PCPNROW, PCPGROW, &
!                          QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, &
!                          ROFOROW, ROFSROW, ROFBROW, TROFROW, TROOROW, &
!                          TROSROW, TROBROW, ROFCROW, ROFNROW, ROVGROW, &
!                          WTRCROW, WTRSROW, WTRGROW, DRROW, WTABROW, &
!                          ILMOROW, UEROW, HBLROW, HMFGROW, HTCROW, &
!                          QFCROW, FSNOROW, ITCTROW, NCOUNT, ireport, &
!                          wfo_seq, YEAR_NOW, ensim_MONTH, ensim_DAY, &
!                          HOUR_NOW, shd%xxx, shd%yyy, NA, &
!                          NTYPE, DELT, TFREZ, UVGRD, SBC, RHOW, CURREC, &
!                          M_C, M_S, M_R, &
!                          WF_ROUTETIMESTEP, WF_R1, WF_R2, shd%NAA, shd%iyMin, &
!                          shd%iyMax, shd%jxMin, shd%jxMax, shd%IAK, shd%IROUGH, &
!                          shd%ICHNL, shd%NEXT, shd%IREACH, shd%AL, shd%GRDN, shd%GRDE, &
!                          shd%DA, shd%BNKFLL, shd%SLOPE_CHNL, shd%ELEV, shd%FRAC, &
!                          WF_NO, WF_NL, WF_MHRD, WF_KT, WF_IY, WF_JX, &
!                          WF_QHYD, WF_RES, WF_RESSTORE, WF_NORESV_CTRL, WF_R, &
!                          WF_NORESV, WF_NREL, WF_KTR, WF_IRES, WF_JRES, WF_RESNAME, &
!                          WF_B1, WF_B2, WF_QREL, WF_QR, &
!                          WF_TIMECOUNT, WF_NHYD, WF_QBASE, WF_QI1, WF_QI2, WF_QO1, WF_QO2, &
!                          WF_STORE1, WF_STORE2, &
!                          DRIVERTIMESTEP, ROFGRD, &
!                          WF_S, &
!                          TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
!                          TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
!                          FINAL_STORE, TOTAL_AREA, TOTAL_HFSACC, TOTAL_QEVPACC, &
!                          SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS, NMELT, t0_ACC, &
!                          CO2CONC, COSZS, XDIFFUSC, CFLUXCG, CFLUXCS, &
!                          AILCG, AILCGS, FCANC, FCANCS, CO2I1CG, CO2I1CS, CO2I2CG, CO2I2CS, &
!                          SLAI, FCANCMX, ANCSVEG, ANCGVEG, RMLCSVEG, RMLCGVEG, &
!                          AILC, PAIC, FIELDSM, WILTSM, &
!                          RMATCTEM, RMATC, NOL2PFTS, ICTEMMOD, L2MAX, ICTEM, &
!                          hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
!                          fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT)
!    end if !(RESUMEFLAG == 1) then

!>
!>*******************************************************************
!>
!> Check if we are reading in a resume_state.r2c file
    if (RESUMEFLAG == 2) then
        print *, 'Reading saved state variables'

! Allocate arrays for resume_state_r2c
        open(54, file = 'resume_state_r2c.txt', action = 'read')
        read(54, *, iostat = IOS) NR2C_R, DELTR2C_R
        if (IOS == 0) then
            allocate(GRD_R(NR2C_R), GAT_R(NR2C_R), GRDGAT_R(NR2C_R), R2C_ATTRIBUTES_R(NR2C_R, 3), stat = PAS)
            if (PAS /= 0) then
                print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                    'RECORD AT THE FIRST LINE IN THE resume_state_r2c.txt FILE. ', &
                    'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
                stop
            end if
        end if
        close(54)

! start by gathering from ROW to GAT so as not to mess-up with CLASSS after call to save_state_r2c
        call CLASSG (cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
                     cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
                     cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
                     FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
                     PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
                     VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
                     HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
                     THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
                     GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, IGDRGAT, &
                     THFCGAT, PSIWGAT, cpv%DELZW, ZBTWGAT, cf%VMOD, &
                     ZSNLGAT, ZPLGGAT, ZPLSGAT, cpv%TAC, cpv%QAC, &
                     DRNGAT, XSLPGAT, XDGAT, WFSFGAT, KSGAT, &
                     ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
                     AGIDGAT, ISNDGAT, RADJGAT, cf%ZBLD, Z0ORGAT, &
                     cf%ZRFM, cf%ZRFH, ZDMGAT, ZDHGAT, cf%FSVH, &
                     cf%FSIH, CSZGAT, cf%FDL, cf%UL, cf%VL, &
                     cf%TA, cf%QA, cf%PRES, cf%PRE, PADRGAT, &
                     VPDGAT, TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, &
                     SPCPGAT, TSPCGAT, RHSIGAT, cf%FCLO, DLONGAT, &
                     GGEOGAT, &
                     cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
                     cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
                     cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
                     cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
                     cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
                     cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
                     cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
                     cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
                     cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
                     cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
                     cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                     cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
                     cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!BEGIN: PDMROF
                     CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM, &
!END: PDMROF
                     shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, NA, NTYPE, &
                     NML, il1, il2, IGND, ICAN, ICP1, cp%TBARROW, cp%THLQROW, &
                     cp%THICROW, cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, &
                     cp%TSNOROW, cp%RHOSROW, cp%SNOROW, cp%TCANROW, &
                     cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, cp%FCANROW, &
                     cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
                     cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, &
                     cp%QA50ROW, cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, &
                     cp%PSGBROW, PAIDROW, HGTDROW, ACVDROW, ACIDROW, TSFSROW, &
                     WSNOROW, THPROW, THRROW, THMROW, BIROW, PSISROW, &
                     GRKSROW, THRAROW, HCPSROW, TCSROW, IGDRROW, &
                     THFCROW, PSIWROW, DLZWROW, ZBTWROW, VMODGRD, &
                     hp%ZSNLROW, hp%ZPLGROW, hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, &
                     cp%DRNROW, cp%XSLPROW, cp%XDROW, WFSFROW, cp%KSROW, &
                     ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
                     AGIDROW, ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
                     cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, FSVHGRD, &
                     FSIHGRD, CSZGRD, cm%clin(cfk%FI)%GRD, cm%clin(cfk%UV)%GRD, VLGRD, &
                     cm%clin(cfk%TT)%GRD, cm%clin(cfk%HU)%GRD, cm%clin(cfk%P0)%GRD, &
                     cm%clin(cfk%PR)%GRD, PADRGRD, &
                     VPDGRD, TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, &
                     SPCPGRD, TSPCGRD, RHSIGRD, FCLOGRD, DLONGRD, &
                     GGEOGRD, cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
                     cp%SANDROW, SANDGAT, cp%CLAYROW, CLAYGAT, &
!BEGIN: PDMROF
                     hp%CMINROW, hp%CMAXROW, hp%BROW, hp%K1ROW, hp%K2ROW, &
!END: PDMROF
                     cp%FAREROW, FAREGAT, &
                     hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
                     fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT, &
                     DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
                     TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
                     DriftROW, SublROW, DepositionROW, &
                     DriftGAT, SublGAT, DepositionGAT)
!>
!>   * INITIALIZATION OF DIAGNOSTIC VARIABLES SPLIT OUT OF CLASSG
!>   * FOR CONSISTENCY WITH GCM APPLICATIONS.
!>

!> *********************************************************************
!> Set variables arrays to zero.
!> *********************************************************************

        cdv%CDH = 0.0
        cdv%CDM = 0.0
        cdv%HFS = 0.0
        cdv%TFX = 0.0
        cdv%QEVP = 0.0
        cdv%QFS = 0.0
        cdv%QFX = 0.0
        cdv%PET = 0.0
        cdv%GA = 0.0
        cdv%EF = 0.0
        cdv%GTE = 0.0
        cdv%QG = 0.0
        cdv%ALVS = 0.0
        cdv%ALIR = 0.0
        cdv%SFCT = 0.0
        cdv%SFCU = 0.0
        cdv%SFCV = 0.0
        cdv%SFCQ = 0.0
        cdv%FSNO = 0.0
        cdv%FSGV = 0.0
        cdv%FSGS = 0.0
        cdv%FSGG = 0.0
        cdv%FLGV = 0.0
        cdv%FLGS = 0.0
        cdv%FLGG = 0.0
        cdv%HFSC = 0.0
        cdv%HFSS = 0.0
        cdv%HFSG = 0.0
        cdv%HEVC = 0.0
        cdv%HEVS = 0.0
        cdv%HEVG = 0.0
        cdv%HMFC = 0.0
        cdv%HMFN = 0.0
        cdv%HTCC = 0.0
        cdv%HTCS = 0.0
        cdv%PCFC = 0.0
        cdv%PCLC = 0.0
        cdv%PCPN = 0.0
        cdv%PCPG = 0.0
        cdv%QFG = 0.0
        cdv%QFN = 0.0
        cdv%QFCF = 0.0
        cdv%QFCL = 0.0
        cdv%ROF = 0.0
        cdv%ROFO = 0.0
        cdv%ROFS = 0.0
        cdv%ROFB = 0.0
        cdv%TROF = 0.0
        cdv%TROO = 0.0
        cdv%TROS = 0.0
        cdv%TROB = 0.0
        cdv%ROFC = 0.0
        cdv%ROFN = 0.0
        cdv%ROVG = 0.0
        cdv%WTRC = 0.0
        cdv%WTRS = 0.0
        cdv%WTRG = 0.0
        cdv%DR = 0.0
        cdv%HMFG = 0.0
        cdv%HTC = 0.0
        cdv%QFC = 0.0
        cdv%GFLX = 0.0
        ITCTGAT = 0

        call resume_state_r2c(shd%lc%NML, NA, NTYPE, NCOUNT, &
                              MINS_NOW, shd%lc%ACLASS, NR2C_R, GRD_R, GAT_R, GRDGAT_R, R2C_ATTRIBUTES_R, &
                              NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, ICAN, ICP1, IGND, &
                              cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
                              cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
                              cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
                              FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
                              PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
                              VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
                              HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
                              THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
                              GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, &
                              THFCGAT, PSIWGAT, cpv%DELZW, ZBTWGAT, &
                              ZSNLGAT, ZPLGGAT, ZPLSGAT, cpv%TAC, cpv%QAC, &
                              DRNGAT, XSLPGAT, XDGAT, WFSFGAT, KSGAT, &
                              ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
                              AGIDGAT, ISNDGAT, RADJGAT, cf%ZBLD, Z0ORGAT, &
                              cf%ZRFM, cf%ZRFH, ZDMGAT, ZDHGAT, cf%FSVH, &
                              cf%FSIH, CSZGAT, cf%FDL, cf%UL, cf%VL, &
                              cf%TA, cf%QA, cf%PRES, cf%PRE, PADRGAT, &
                              VPDGAT, TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, &
                              SPCPGAT, TSPCGAT, RHSIGAT, cf%FCLO, DLONGAT, &
                              GGEOGAT, &
                              cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
                              cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
                              cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
                              cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
                              cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
                              cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
                              cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
                              cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
                              cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
                              cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
                              cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                              cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
                              cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
                              SANDGAT, CLAYGAT, IGDRGAT, cf%VMOD, QLWOGAT, &
                              shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
                              shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)
!>
! now scatter the variables so that the GATs don't get overwritten incorrectly
        call CLASSS(cp%TBARROW, cp%THLQROW, cp%THICROW, GFLXROW, TSFSROW, &
                    cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, cp%TSNOROW, &
                    cp%RHOSROW, cp%SNOROW, cp%TCANROW, cp%RCANROW, cp%SCANROW, &
                    cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
                    shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
                    NA, NTYPE, NML, il1, il2, IGND, ICAN, ICAN + 1, &
                    cpv%TBAR, cpv%THLQ, cpv%THIC, cdv%GFLX, cpv%TSFS, &
                    cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%ALBS, cpv%TSNO, &
                    cpv%RHOS, cpv%SNO, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
                    cpv%GRO, cpv%CMAI, cpv%TAC, cpv%QAC, cpv%WSNO, &
                    cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
                    cp%SANDROW, SANDGAT, cp%CLAYROW, CLAYGAT, cp%XSLPROW, XSLPGAT, &
                    DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
                    TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
                    DriftROW, SublROW, DepositionROW, &
                    DriftGAT, SublGAT, DepositionGAT)
!>
!>   * SCATTER OPERATION ON DIAGNOSTIC VARIABLES SPLIT OUT OF
!>   * CLASSS FOR CONSISTENCY WITH GCM APPLICATIONS.
!>
        do 180 k = il1, il2
            ik = shd%lc%ILMOS(k)
            jk = shd%lc%JLMOS(k)
            CDHROW(ik, jk) = cdv%CDH(k)
            CDMROW(ik, jk) = cdv%CDM(k)
            HFSROW(ik, jk) = cdv%HFS(k)
            TFXROW(ik, jk) = cdv%TFX(k)
            QEVPROW(ik, jk) = cdv%QEVP(k)
            QFSROW(ik, jk) = cdv%QFS(k)
            QFXROW(ik, jk) = cdv%QFX(k)
            PETROW(ik, jk) = cdv%PET(k)
            GAROW(ik, jk) = cdv%GA(k)
            EFROW(ik, jk) = cdv%EF(k)
            GTROW(ik, jk) = cdv%GTE(k)
            QGROW(ik, jk) = cdv%QG(k)
            ALVSROW(ik, jk) = cdv%ALVS(k)
            ALIRROW(ik, jk) = cdv%ALIR(k)
            SFCTROW(ik, jk) = cdv%SFCT(k)
            SFCUROW(ik, jk) = cdv%SFCU(k)
            SFCVROW(ik, jk) = cdv%SFCV(k)
            SFCQROW(ik, jk) = cdv%SFCQ(k)
            FSNOROW(ik, jk) = cdv%FSNO(k)
            FSGVROW(ik, jk) = cdv%FSGV(k)
            FSGSROW(ik, jk) = cdv%FSGS(k)
            FSGGROW(ik, jk) = cdv%FSGG(k)
            FLGVROW(ik, jk) = cdv%FLGV(k)
            FLGSROW(ik, jk) = cdv%FLGS(k)
            FLGGROW(ik, jk) = cdv%FLGG(k)
            HFSCROW(ik, jk) = cdv%HFSC(k)
            HFSSROW(ik, jk) = cdv%HFSS(k)
            HFSGROW(ik, jk) = cdv%HFSG(k)
            HEVCROW(ik, jk) = cdv%HEVC(k)
            HEVSROW(ik, jk) = cdv%HEVS(k)
            HEVGROW(ik, jk) = cdv%HEVG(k)
            HMFCROW(ik, jk) = cdv%HMFC(k)
            HMFNROW(ik, jk) = cdv%HMFN(k)
            HTCCROW(ik, jk) = cdv%HTCC(k)
            HTCSROW(ik, jk) = cdv%HTCS(k)
            PCFCROW(ik, jk) = cdv%PCFC(k)
            PCLCROW(ik, jk) = cdv%PCLC(k)
            PCPNROW(ik, jk) = cdv%PCPN(k)
            PCPGROW(ik, jk) = cdv%PCPG(k)
            QFGROW(ik, jk) = cdv%QFG(k)
            QFNROW(ik, jk) = cdv%QFN(k)
            QFCLROW(ik, jk) = cdv%QFCL(k)
            QFCFROW(ik, jk) = cdv%QFCF(k)
            ROFROW(ik, jk) = cdv%ROF(k)
            ROFOROW(ik, jk) = cdv%ROFO(k)
            ROFSROW(ik, jk) = cdv%ROFS(k)
            ROFBROW(ik, jk) = cdv%ROFB(k)
            TROFROW(ik, jk) = cdv%TROF(k)
            TROOROW(ik, jk) = cdv%TROO(k)
            TROSROW(ik, jk) = cdv%TROS(k)
            TROBROW(ik, jk) = cdv%TROB(k)
            ROFCROW(ik, jk) = cdv%ROFC(k)
            ROFNROW(ik, jk) = cdv%ROFN(k)
            ROVGROW(ik, jk) = cdv%ROVG(k)
            WTRCROW(ik, jk) = cdv%WTRC(k)
            WTRSROW(ik, jk) = cdv%WTRS(k)
            WTRGROW(ik, jk) = cdv%WTRG(k)
            DRROW(ik, jk) = cdv%DR(k)
            WTABROW(ik, jk) = cdv%WTAB(k)
            ILMOROW(ik, jk) = cdv%ILMO(k)
            UEROW(ik, jk) = cdv%UE(k)
            HBLROW(ik, jk) = cdv%HBL(k)
180     continue
!>
        do 190 l = 1, IGND
            do 190 k = il1, il2
                ik = shd%lc%ILMOS(k)
                jk = shd%lc%JLMOS(k)
                HMFGROW(ik, jk, l) = cdv%HMFG(k, l)
                HTCROW(ik, jk, l) = cdv%HTC(k, l)
                QFCROW(ik, jk, l) = cdv%QFC(k, l)
190     continue
!>
        do 230 m = 1, 50
            do 220 l = 1, 6
                do 210 k = il1, il2
                    ITCTROW(shd%lc%ILMOS(k), shd%lc%JLMOS(k), l, m) = ITCTGAT(k, l, m)
210     continue
220     continue
230     continue
    end if !(RESUMEFLAG == 2) then

!> *********************************************************************
!> Call read_init_prog_variables.f90 for initi prognostic variables by
!> by fields needd by classas as initial conditions
!> *********************************************************************
!> bjd - July 14, 2014: Gonzalo Sapriza
    if (RESUMEFLAG == 3) then
        call read_init_prog_variables_class(CMAIROW, QACROW, TACROW, &
                                            TBASROW, TSFSROW, WSNOROW, &
!                                            cp, &
                                            NA, NTYPE, &
                                            IGND, fls)
    end if !(RESUMEFLAG == 3) then

!> *********************************************************************
!> Call CLASSB to set more CLASS variables
!> *********************************************************************
!> bjd - July 25, 2005: For inputting field measured soil properties.

    call CLASSB(THPROW, THRROW, THMROW, BIROW, PSISROW, &
                GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
                PSIWROW, DLZWROW, ZBTWROW, ALGWROW, ALGDROW, &
                cp%SANDROW, cp%CLAYROW , cp%ORGMROW, sl%DELZ, sl%ZBOT, &
                cp%SDEPROW, ISNDROW, IGDRROW, NA, NTYPE, &
                1, NA, NTYPE, IGND, ICTEMMOD, &
                SV%WC_THPOR, SV%WC_THLRET, SV%WC_THLMIN, SV%WC_BI, SV%WC_PSISAT, &
                SV%WC_GRKSAT, SV%WC_HCPS, SV%WC_TCS)

!> Allocate variables for WATDRN3
!> ******************************************************************
!> DGP - June 3, 2011: Now that variables are shared, moved from WD3
!> flag to ensure allocation.
    allocate(BTC(NTYPE, IGND), BCAP(NTYPE, IGND), DCOEFF(NTYPE, IGND), &
             BFCAP(NTYPE, IGND), BFCOEFF(NTYPE, IGND), BFMIN(NTYPE, IGND), &
             BQMAX(NTYPE, IGND), stat = PAS)

!> Call WATDRN3B to set WATDRN (Ric) variables
!> ******************************************************************
!> DGP - May 5, 2011: Added.
    if (PAS /= 0) print *, 'Error allocating on WD3 for new WATDRN.'
    call WATDRN3B(PSISROW, THPROW, GRKSROW, BIROW, cp%XSLPROW, cp%DDROW, &
                  NA, NTYPE, IGND, &
                  BTC, BCAP, DCOEFF, BFCAP, BFCOEFF, BFMIN, BQMAX, &
                  cp%SANDROW, cp%CLAYROW)

!> *********************************************************************
!> MAM - Initialize ENDDATE and ENDDATA
!> *********************************************************************
    ENDDATE = .false.
    ENDDATA = .false.

    call climate_module_loaddata(shd, .true., cm, NML, il1, il2, ENDDATA)

    if (ipid == 0) then
        TOTAL_STORE = 0.0
        TOTAL_STORE_2 = 0.0
        TOTAL_RCAN = 0.0
        TOTAL_SCAN = 0.0
        TOTAL_SNO = 0.0
        TOTAL_WSNO = 0.0
        TOTAL_ZPND = 0.0
        TOTAL_THLQ = 0.0
        TOTAL_THIC = 0.0
        TOTAL_STORE_M = 0.0
        TOTAL_STORE_2_M = 0.0
        TOTAL_STORE_ACC_M = 0.0
        TOTAL_RCAN_M = 0.0
        TOTAL_SCAN_M = 0.0
        TOTAL_SNO_M = 0.0
        TOTAL_WSNO_M = 0.0
        TOTAL_ZPND_M = 0.0
        TOTAL_THLQ_M = 0.0
        TOTAL_THIC_M = 0.0

    !> Open CSV output files.
        if (BASINBALANCEOUTFLAG > 0) then

        !> Water balance.
            open(fls%fl(mfk%f900)%iun, &
!todo: This creates a bug if a space doesn't exist in the name of the folder!
                 file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/' // trim(adjustl(fls%fl(mfk%f900)%fn)), &
                 iostat = ios)
!todo: Create this only by flag.
            open(902, file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/Basin_average_water_balance_Monthly.csv')

            wrt_900_1 = 'DAY,YEAR,PREACC' // ',EVAPACC,ROFACC,ROFOACC,' // &
                'ROFSACC,ROFBACC,PRE,EVAP,ROF,ROFO,ROFS,ROFB,SCAN,RCAN,SNO,WSNO,ZPND,'

            wrt_900_2 = 'THLQ'
            wrt_900_3 = 'THIC'
            wrt_900_4 = 'THLQIC'

            do i = 1, IGND
                write(strInt, '(i1)') i
                if (i < IGND) then
                    wrt_900_2 = trim(adjustl(wrt_900_2)) // trim(adjustl(strInt)) // ',THLQ'
                    wrt_900_3 = trim(adjustl(wrt_900_3)) // trim(adjustl(strInt)) // ',THIC'
                    wrt_900_4 = trim(adjustl(wrt_900_4)) // trim(adjustl(strInt)) // ',THLQIC'
                else
                    wrt_900_2 = trim(adjustl(wrt_900_2)) // trim(adjustl(strInt)) // ','
                    wrt_900_3 = trim(adjustl(wrt_900_3)) // trim(adjustl(strInt)) // ','
                    wrt_900_4 = trim(adjustl(wrt_900_4)) // trim(adjustl(strInt)) // ','
                end if
            end do !> i = 1, IGND

            wrt_900_f = trim(adjustl(wrt_900_1)) // &
                trim(adjustl(wrt_900_2)) // &
                trim(adjustl(wrt_900_3)) // &
                trim(adjustl(wrt_900_4)) // &
                'THLQ,THLIC,THLQIC,STORAGE,DELTA_STORAGE,DSTOR_ACC'

            write(fls%fl(mfk%f900)%iun, '(a)') trim(adjustl(wrt_900_f))
            write(902, '(a)') trim(adjustl(wrt_900_f))

        !> Energy balance.
            open(901, file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/Basin_average_energy_balance.csv')

            write(901, '(a)') 'DAY,YEAR,HFSACC,QEVPACC'

        end if !(BASINBALANCEOUTFLAG > 0) then

!>**********************************************************************
!> Set initial SnowAge & DrySnow values for PBSM calculations
!> (MK MacDonald, Sept 2010)
!>**********************************************************************
        if (PBSMFLAG == 1) then
            do i = 1, NA  !i = 2, NA
                do m = 1, NTYPE
                    if (cp%SNOROW(i, m) <= 0.0) then
                        DrySnowROW(i, m) = 0.0 !1 = snowpack is dry (i.e. cold)
                        SnowAgeROW(i, m) = 0.0 !hours since last snowfall
       !todo: this can use the TFREZ parameter instead of a hard-coded value. (dgp: 2015-01-09)
                        if (cm%clin(cfk%TT)%GRD(i) >= 273.16) then
                            DrySnowROW(i, m) = 0.0
                            SnowAgeROW(i, m) = 48.0 !assume 48 hours since last snowfall
                        else
                            DrySnowROW(i, m) = 1.0
                            SnowAgeROW(i, m) = 48.0
                        end if
                    end if
                end do
            end do
        end if !PBSMFLAG == 1

    end if !(ipid == 0) then

    call CLASSG(cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
                cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
                cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
                FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
                PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
                VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
                HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
                THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
                GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, IGDRGAT, &
                THFCGAT, PSIWGAT, cpv%DELZW, ZBTWGAT, cf%VMOD, &
                ZSNLGAT, ZPLGGAT, ZPLSGAT, cpv%TAC, cpv%QAC, &
                DRNGAT, XSLPGAT, XDGAT, WFSFGAT, KSGAT, &
                ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
                AGIDGAT, ISNDGAT, RADJGAT, cf%ZBLD, Z0ORGAT, &
                cf%ZRFM, cf%ZRFH, ZDMGAT, ZDHGAT, cf%FSVH, &
                cf%FSIH, CSZGAT, cf%FDL, cf%UL, cf%VL, &
                cf%TA, cf%QA, cf%PRES, cf%PRE, PADRGAT, &
                VPDGAT, TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, &
                SPCPGAT, TSPCGAT, RHSIGAT, cf%FCLO, DLONGAT, &
                GGEOGAT, &
                cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
                cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
                cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
                cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
                cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
                cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
                cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
                cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
                cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
                cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
                cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
                cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!BEGIN: PDMROF
                CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM,  &
!END: PDMROF
                shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, NA, NTYPE, &
                NML, il1, il2, IGND, ICAN, ICP1, cp%TBARROW, cp%THLQROW, &
                cp%THICROW, cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, &
                cp%TSNOROW, cp%RHOSROW, cp%SNOROW, cp%TCANROW, &
                cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, cp%FCANROW, &
                cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
                cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, &
                cp%QA50ROW, cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, &
                cp%PSGBROW, PAIDROW, HGTDROW, ACVDROW, ACIDROW, TSFSROW, &
                WSNOROW, THPROW, THRROW, THMROW, BIROW, PSISROW, &
                GRKSROW, THRAROW, HCPSROW, TCSROW, IGDRROW, &
                THFCROW, PSIWROW, DLZWROW, ZBTWROW, VMODGRD, &
                hp%ZSNLROW, hp%ZPLGROW, hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, &
                cp%DRNROW, cp%XSLPROW, cp%XDROW, WFSFROW, cp%KSROW, &
                ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
                AGIDROW, ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
                cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, FSVHGRD, &
                FSIHGRD, CSZGRD, cm%clin(cfk%FI)%GRD, cm%clin(cfk%UV)%GRD, VLGRD, &
                cm%clin(cfk%TT)%GRD, cm%clin(cfk%HU)%GRD, cm%clin(cfk%P0)%GRD, cm%clin(cfk%PR)%GRD, PADRGRD, &
                VPDGRD, TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, &
                SPCPGRD, TSPCGRD, RHSIGRD, FCLOGRD, DLONGRD, &
                GGEOGRD, cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
                cp%SANDROW, SANDGAT, cp%CLAYROW, CLAYGAT, &
!BEGIN: PDMROF
                hp%CMINROW, hp%CMAXROW, hp%BROW, hp%K1ROW, hp%K2ROW, &
!END: PDMROF
                cp%FAREROW, FAREGAT, &
                hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
                fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT, &
                DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
                TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
                DriftROW, SublROW, DepositionROW, &
                DriftGAT, SublGAT, DepositionGAT)

!> *********************************************************************
!> End of Initialization
!> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *
        print 2836
        print 2835
    end if !(ro%VERBOSEMODE > 0) then

2836    format(/1x, 'DONE INTITIALIZATION')
2835    format(/1x, 'STARTING MESH')

!> *********************************************************************
!> Start of main loop that is run each half hour
!> *********************************************************************
    do while (.not. ENDDATE .and. .not. ENDDATA)

!* N: is only used for debugging purposes.
!> N is incremented at the beginning of each loop. so you can tell which
!> iteration of the loop you are on by what the value of N is.
!> N is printed out with each of the error messages in CLASSZ.
        N = N + 1

    !> MAM - Linearly interpolate forcing data for intermediate time steps
        if (INTERPOLATIONFLAG == 1) then
            call climate_module_interpolatedata(shd, FAREGAT, cm, NML, il1, il2)
        end if

        cf%FSVH(il1:il2) = FSVHGAT(il1:il2)
        cf%FSIH(il1:il2) = FSIHGAT(il1:il2)
        cf%FDL(il1:il2) = cm%clin(cfk%FI)%GAT(il1:il2)
        cf%PRE(il1:il2) = cm%clin(cfk%PR)%GAT(il1:il2)
        cf%TA(il1:il2) = cm%clin(cfk%TT)%GAT(il1:il2)
        cf%UL(il1:il2) = cm%clin(cfk%UV)%GAT(il1:il2)
        cf%PRES(il1:il2) = cm%clin(cfk%P0)%GAT(il1:il2)
        cf%QA(il1:il2) = cm%clin(cfk%HU)%GAT(il1:il2)

        UVGRD = max(VMIN, cm%clin(cfk%UV)%GRD)
        VMODGRD = UVGRD
        cf%VMOD = max(VMIN, cf%UL)

!> *********************************************************************
!> Set some more CLASS parameters
!> *********************************************************************

!> This estimates the fractional cloud cover (FCLOGRD) by the basis
!>  of the solar zenith angle and the occurrence of precipitation.
!>  Assumed to be 1 (100%) when precipitation occurs and somewhere
!>  in the range of [0.1, 1] based on the location of the sun in the
!>  sky when precipitation is not occuring. (0.1 when the sun is at
!>  the zenith, 1 when the sun is at the horizon).
        RDAY = real(JDAY_NOW) + (real(HOUR_NOW) + real(MINS_NOW)/60.0)/24.0
        DECL = sin(2.0*PI*(284.0 + RDAY)/365.0)*23.45*PI/180.0
        HOUR = (real(HOUR_NOW) + real(MINS_NOW)/60.0)*PI/12.0 - PI

        do k = il1, il2
            ik = shd%lc%ILMOS(k)
            COSZ = sin(RADJGAT(k))*sin(DECL) + cos(RADJGAT(k))*cos(DECL)*cos(HOUR)
            CSZGAT(k) = sign(max(abs(COSZ), 1.0e-3), COSZ)
            CSZGRD(ik) = CSZGAT(k)
            if (cf%PRE(k) > 0.0) then
    !todo: there isn't a GAT variable for this (although, there might be for the canopy)?
                XDIFFUS(ik) = 1.0
            else
                XDIFFUS(ik) = max(0.0, min(1.0 - 0.9*COSZ, 1.0))
            end if
            cf%FCLO(k) = XDIFFUS(ik)
            FCLOGRD(ik) = cf%FCLO(k)
        end do

!> *********************************************************************
!> Start of calls to CLASS subroutines
!> *********************************************************************

        !> Were initialized in CLASSG and so have been extracted.
        DriftGAT = 0.0 !DriftROW (ILMOS(k), JLMOS(k))
        SublGAT = 0.0 !SublROW (ILMOS(k), JLMOS(k))
        DepositionGAT = 0.0

!>
!>   * INITIALIZATION OF DIAGNOSTIC VARIABLES SPLIT OUT OF CLASSG
!>   * FOR CONSISTENCY WITH GCM APPLICATIONS.
!>

        cdv%CDH = 0.0
        cdv%CDM = 0.0
        cdv%HFS = 0.0
        cdv%TFX = 0.0
        cdv%QEVP = 0.0
        cdv%QFS = 0.0
        cdv%QFX = 0.0
        cdv%PET = 0.0
        cdv%GA = 0.0
        cdv%EF = 0.0
        cdv%GTE = 0.0
        cdv%QG = 0.0
        cdv%ALVS = 0.0
        cdv%ALIR = 0.0
        cdv%SFCT = 0.0
        cdv%SFCU = 0.0
        cdv%SFCV = 0.0
        cdv%SFCQ = 0.0
        cdv%FSNO = 0.0
        cdv%FSGV = 0.0
        cdv%FSGS = 0.0
        cdv%FSGG = 0.0
        cdv%FLGV = 0.0
        cdv%FLGS = 0.0
        cdv%FLGG = 0.0
        cdv%HFSC = 0.0
        cdv%HFSS = 0.0
        cdv%HFSG = 0.0
        cdv%HEVC = 0.0
        cdv%HEVS = 0.0
        cdv%HEVG = 0.0
        cdv%HMFC = 0.0
        cdv%HMFN = 0.0
        cdv%HTCC = 0.0
        cdv%HTCS = 0.0
        cdv%PCFC = 0.0
        cdv%PCLC = 0.0
        cdv%PCPN = 0.0
        cdv%PCPG = 0.0
        cdv%QFG = 0.0
        cdv%QFN = 0.0
        cdv%QFCF = 0.0
        cdv%QFCL = 0.0
        cdv%ROF = 0.0
        cdv%ROFO = 0.0
        cdv%ROFS = 0.0
        cdv%ROFB = 0.0
        cdv%TROF = 0.0
        cdv%TROO = 0.0
        cdv%TROS = 0.0
        cdv%TROB = 0.0
        cdv%ROFC = 0.0
        cdv%ROFN = 0.0
        cdv%ROVG = 0.0
        cdv%WTRC = 0.0
        cdv%WTRS = 0.0
        cdv%WTRG = 0.0
        cdv%DR = 0.0
        cdv%HMFG = 0.0
        cdv%HTC = 0.0
        cdv%QFC = 0.0
        cdv%GFLX = 0.0
        ITCTGAT = 0

        call CLASSI(VPDGAT, TADPGAT, PADRGAT, RHOAGAT, RHSIGAT, &
                    RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, cf%TA, cf%QA, &
                    cf%PRE, RPREGAT, SPREGAT, cf%PRES, &
                    IPCP, NML, il1, il2)

        if (ipid == 0) then

!> Calculate initial storage (after reading in resume.txt file if applicable)
            if (JAN == 1) then
                INIT_STORE = 0.0
                do i = 1, NA
                    if (shd%FRAC(i) >= 0.0) then
                        do m = 1, NTYPE
                            INIT_STORE = INIT_STORE + cp%FAREROW(i, m)* &
                                (cp%RCANROW(i, m) + cp%SCANROW(i, m) + cp%SNOROW(i, m) + WSNOROW(i, m) + cp%ZPNDROW(i, m)*RHOW)
                            wb%stg(i) = cp%FAREROW(i, m)* &
                                (cp%RCANROW(i, m) + cp%SCANROW(i, m) + cp%SNOROW(i, m) + WSNOROW(i, m) + cp%ZPNDROW(i, m)*RHOW)
                            do j = 1, IGND
                                INIT_STORE = INIT_STORE + cp%FAREROW(i, m)* &
                                    (cp%THLQROW(i, m, j)*RHOW + cp%THICROW(i, m, j)*RHOICE)*DLZWROW(i, m, j)
                                wb%stg(i) = cp%FAREROW(i, m)* &
                                    (cp%THLQROW(i, m, j)*RHOW + cp%THICROW(i, m, j)*RHOICE)*DLZWROW(i, m, j)
                            end do
                        end do
                        wb%dstg(i) = wb%stg(i)
                    end if
                end do
                TOTAL_STORE_2 = INIT_STORE

    ! For monthly totals.
                call FIND_MONTH(JDAY_NOW, YEAR_NOW, imonth_old)
                TOTAL_STORE_2_M = INIT_STORE
            end if

!> Initialization of the Storage field
            if (JAN == 1) then
                do m = 1, NTYPE
                    STG_I(:) = STG_I(:) + cp%FAREROW(:, m)*(cp%RCANROW(:, m) + &
                                                            cp%SCANROW(:, m) + &
                                                            cp%SNOROW(:, m)  + &
                                                            cp%ZPNDROW(:, m)*RHOW)
                    do j = 1, IGND
                        STG_I(:) = STG_I(:) + cp%FAREROW(:, m)*(cp%THLQROW(:, m, j)*RHOW + &
                                                                cp%THICROW(:, m, j)*RHOICE)*DLZWROW(:, m, j)
                    end do
                end do
            end if

        end if !(ipid == 0) then

!> *********************************************************************
!> Start of the NML-based LSS loop.
!> *********************************************************************

        if (ipid /= 0 .or. izero == 0) then

            call CLASSZ(0, CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
                        WTVSTP, WTSSTP, WTGSTP, &
                        cdv%FSGV, cdv%FLGV, cdv%HFSC, cdv%HEVC, cdv%HMFC, cdv%HTCC, &
                        cdv%FSGS, cdv%FLGS, cdv%HFSS, cdv%HEVS, cdv%HMFN, cdv%HTCS, &
                        cdv%FSGG, cdv%FLGG, cdv%HFSG, cdv%HEVG, cdv%HMFG, cdv%HTC, &
                        cdv%PCFC, cdv%PCLC, cdv%QFCF, cdv%QFCL, cdv%ROFC, cdv%WTRC, &
                        cdv%PCPN, cdv%QFN, cdv%ROFN, cdv%WTRS, cdv%PCPG, cdv%QFG, &
                        cdv%QFC, cdv%ROF, cdv%WTRG, cpv%CMAI, cpv%RCAN, cpv%SNCAN, &
                        cpv%TCAN, cpv%SNO, cpv%WSNO, cpv%TSNO, cpv%THLQ, cpv%THIC, &
                        HCPSGAT, THPGAT, cpv%DELZW, cpv%TBAR, cpv%ZPND, cpv%TPND, &
                        sl%DELZ, cdv%FCS, cdv%FGS, cdv%FC, cdv%FG, &
                        il1, il2, NML, IGND, N, &
                        DriftGAT, SublGAT)

!> ALBEDO AND TRANSMISSIVITY CALCULATIONS; GENERAL VEGETATION
!> CHARACTERISTICS.
            call CLASSA(cdv%FC, cdv%FG, cdv%FCS, cdv%FGS, ALVSCN, ALIRCN, &
                        ALVSG, ALIRG, ALVSCS, ALIRCS, ALVSSN, ALIRSN, &
                        ALVSGC, ALIRGC, ALVSSC, ALIRSC, TRVSCN, TRIRCN, &
                        TRVSCS, TRIRCS, FSVF, FSVFS, &
                        RAICAN, RAICNS, SNOCAN, SNOCNS, FRAINC, FSNOWC, &
                        FRAICS, FSNOCS, &
                        DISP, DISPS, ZOMLNC, ZOMLCS, &
                        ZOELNC, ZOELCS, ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
                        CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, CWFCAP, &
                        CWLCPS, CWFCPS, RC, RCS, RBCOEF, FROOT, &
                        ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TRSNOW, ZSNOW, &
                        cpv%WSNO, cdv%ALVS, cdv%ALIR, cdv%HTCC, cdv%HTCS, cdv%HTC, &
                        cdv%WTRC, cdv%WTRS, cdv%WTRG, cpv%CMAI, cdv%FSNO, &
                        FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, PAMNGAT, &
                        CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, VPDAGAT, VPDBGAT, &
                        PSGAGAT, PSGBGAT, PAIDGAT, HGTDGAT, ACVDGAT, ACIDGAT, &
                        ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ALGWGAT, ALGDGAT, &
                        cpv%THLQ, cpv%THIC, cpv%TBAR, cpv%RCAN, cpv%SNCAN, cpv%TCAN, &
                        cpv%GRO, cpv%SNO, cpv%TSNO, cpv%RHOS, cpv%ALBS, cf%ZBLD, &
                        Z0ORGAT, ZSNLGAT, ZPLGGAT, ZPLSGAT, &
                        cf%FCLO, cf%TA, VPDGAT, RHOAGAT, CSZGAT, &
                        cf%FSVH, RADJGAT, DLONGAT, RHSIGAT, sl%DELZ, cpv%DELZW, &
                        ZBTWGAT, THPGAT, THMGAT, PSISGAT, BIGAT, PSIWGAT, &
                        HCPSGAT, ISNDGAT, &
                        FCANCMX, ICTEM, ICTEMMOD, RMATC, &
                        AILC, PAIC, L2MAX, NOL2PFTS, &
                        AILCG, AILCGS, FCANC, FCANCS, &
                        JDAY_NOW, NML, il1, il2, &
                        JLAT, N, ICAN, ICAN + 1, IGND, IDISP, IZREF, &
                        IWF, IPAI, IHGT, IALC, IALS, IALG)

!          * SURFACE TEMPERATURE AND FLUX CALCULATIONS.
            call CLASST(TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
                        THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, TCTOPG, TCBOTG, &
                        GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, G12CS, G12GS, &
                        G23C, G23G, G23CS, G23GS, QFREZC, QFREZG, QMELTC, QMELTG, &
                        EVAPC, EVAPCG, EVAPG, EVAPCS, EVPCSG, EVAPGS, TCANO, TCANS, &
                        RAICAN, SNOCAN, RAICNS, SNOCNS, CHCAP, CHCAPS, TPONDC, TPONDG, &
                        TPNDCS, TPNDGS, TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
                        ITCTGAT, cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, cdv%QFS, cdv%QFX, &
                        cdv%PET, cdv%GA, cdv%EF, cdv%GTE, cdv%QG, cdv%SFCT, cdv%SFCU, cdv%SFCV, &
                        cdv%SFCQ, SFRHGAT, cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, cdv%FLGG, &
                        cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, &
                        cdv%HTCC, cdv%HTCS, cdv%HTC, cdv%QFCF, cdv%QFCL, cdv%DR, cdv%WTAB, cdv%ILMO, &
                        cdv%UE, cdv%HBL, cpv%TAC, cpv%QAC, cf%ZRFM, cf%ZRFH, ZDMGAT, ZDHGAT, &
                        VPDGAT, TADPGAT, RHOAGAT, cf%FSVH, cf%FSIH, cf%FDL, cf%UL, cf%VL, &
                        cf%TA, cf%QA, PADRGAT, cdv%FC, cdv%FG, cdv%FCS, cdv%FGS, RBCOEF, &
                        FSVF, FSVFS, cf%PRES, cf%VMOD, ALVSCN, ALIRCN, ALVSG, ALIRG, &
                        ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, ALIRSC, &
                        TRVSCN, TRIRCN, TRVSCS, TRIRCS, RC, RCS, cdv%WTRG, QLWOGAT, &
                        FRAINC, FSNOWC, FRAICS, FSNOCS, CMASSC, CMASCS, DISP, DISPS, &
                        ZOMLNC, ZOELNC, ZOMLNG, ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS, &
                        cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%TCAN, cpv%TSNO, &
                        ZSNOW, TRSNOW, cpv%RHOS, cpv%WSNO, THPGAT, THRGAT, THMGAT, THFCGAT, &
                        RADJGAT, cf%PRE, HCPSGAT, TCSGAT, cpv%TSFS, sl%DELZ, cpv%DELZW, ZBTWGAT, &
                        FTEMP, FVAP, RIB, ISNDGAT, &
                        AILCG, AILCGS, FCANC, FCANCS, CO2CONC, CO2I1CG, CO2I1CS, CO2I2CG, &
                        CO2I2CS, COSZS, XDIFFUSC, SLAI, ICTEM, ICTEMMOD, RMATCTEM, &
                        FCANCMX, L2MAX, NOL2PFTS, CFLUXCG, CFLUXCS, ANCSVEG, ANCGVEG, &
                        RMLCSVEG, RMLCGVEG, FIELDSM, WILTSM, &
                        ITC, ITCG, ITG, NML, il1, il2, JLAT, N, ICAN, &
                        IGND, IZREF, ISLFD, NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI)

!          * WATER BUDGET CALCULATIONS.
            if (JDAY_NOW == 1 .and. NCOUNT == 48) then
       ! bruce davison - only increase NMELT if we don't start the run on January 1st, otherwise t0_ACC allocation is too large
       ! and the model crashes if the compiler is checking for array bounds when t0_ACC is passed into CLASSW with size NMELT
                if (JDAY_START == 1 .and. NSUM_TOTAL < 49) then
                    continue ! NMELT should stay = 1
                else
                    NMELT = NMELT + 1
                end if
                CUMSNOWINFILCS = 0.0
                CUMSNOWINFILGS = 0.0
                INFILTYPE = 2
            end if

            call CLASSW(cpv%THLQ, cpv%THIC, cpv%TBAR, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
                        cdv%ROF, cdv%TROF, cpv%SNO, cpv%TSNO, cpv%RHOS, cpv%ALBS, &
                        cpv%WSNO, cpv%ZPND, cpv%TPND, cpv%GRO, FRZCGAT, cpv%TBAS, cdv%GFLX, &
                        cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, cdv%QFCF, cdv%QFCL, &
                        cdv%QFN, cdv%QFG, cdv%QFC, cdv%HMFC, cdv%HMFG, cdv%HMFN, &
                        cdv%HTCC, cdv%HTCS, cdv%HTC, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                        cdv%WTRS, cdv%WTRG, cdv%ROFO, cdv%ROFS, cdv%ROFB, &
                        cdv%TROO, cdv%TROS, cdv%TROB, cdv%QFS, &
                        TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
                        THICEC, THICEG, HCPC, HCPG, RPCPGAT, TRPCGAT, &
                        SPCPGAT, TSPCGAT, cf%PRE, cf%TA, RHSIGAT, GGEOGAT, &
                        cdv%FC, cdv%FG, cdv%FCS, cdv%FGS, TPONDC, TPONDG, &
                        TPNDCS, TPNDGS, EVAPC, EVAPCG, EVAPG, EVAPCS, &
                        EVPCSG, EVAPGS, QFREZC, QFREZG, QMELTC, QMELTG, &
                        RAICAN, SNOCAN, RAICNS, SNOCNS, FROOT, FSVF, &
                        FSVFS, CWLCAP, CWFCAP, CWLCPS, CWFCPS, TCANO, &
                        TCANS, CHCAP, CHCAPS, CMASSC, CMASCS, ZSNOW, &
                        GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
                        G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
                        TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
                        ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, cpv%TSFS, &
                        TCTOPC, TCBOTC, TCTOPG, TCBOTG, &
                        THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, GRKSGAT, &
                        THRAGAT, THFCGAT, DRNGAT, HCPSGAT, sl%DELZ, &
                        cpv%DELZW, ZBTWGAT, XSLPGAT, XDGAT, WFSFGAT, KSGAT, &
                        ISNDGAT, IGDRGAT, IWF, NML, il1, il2, N, &
                        JLAT, ICAN, IGND, IGND + 1, IGND + 2, &
                        NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
                        MANNGAT, DDGAT, NCOUNT, &
                        t0_ACC(NMELT), SI, TSI, INFILTYPE, SNOWMELTD, SNOWMELTD_LAST, &
                        MELTRUNOFF, SNOWINFIL, CUMSNOWINFILCS, CUMSNOWINFILGS, &
                        SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS, &
                        NA, NTYPE, shd%lc%ILMOS, shd%lc%JLMOS, &
                        BTC, BCAP, DCOEFF, BFCAP, BFCOEFF, BFMIN, BQMAX, &
!FOR PDMROF
                        CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM, &
                        ZPNDPRECS, ZPONDPREC, ZPONDPREG, ZPNDPREGS, &
                        UM1CS, UM1C, UM1G, UM1GS, &
                        QM1CS, QM1C, QM1G, QM1GS, &
                        QM2CS, QM2C, QM2G, QM2GS, UMQ, &
                        FSTRCS, FSTRC, FSTRG, FSTRGS, &
                        ZSNOCS, ZSNOGS, ZSNOWC, ZSNOWG, &
                        HCPSCS, HCPSGS, HCPSC, HCPSG, &
                        TSNOWC, TSNOWG, RHOSC, RHOSG, &
                        XSNOWC, XSNOWG, XSNOCS, XSNOGS)

!          * SINGLE COLUMN BLOWING SNOW CALCULATIONS.
            if (PBSMFLAG == 1) then
                call PBSMrun(ZSNOW, cpv%WSNO, cpv%SNO, cpv%RHOS, cpv%TSNO, cdv%HTCS, &
                             ZSNOCS, ZSNOGS, ZSNOWC, ZSNOWG, &
                             HCPSCS, HCPSGS, HCPSC, HCPSG, &
                             TSNOWC, TSNOWG, TSNOCS, TSNOGS, &
                             RHOSC, RHOSG, RHOSCS, RHOSGS,&
                             XSNOWC, XSNOWG, XSNOCS, XSNOGS, &
                             WSNOCS, WSNOGS, &
                             cdv%FC, cdv%FG, cdv%FCS, cdv%FGS, &
                             fetchGAT, N_SGAT, A_SGAT, HtGAT, &
                             cdv%SFCT, cdv%SFCU, cdv%SFCQ, cf%PRES, cf%PRE, &
                             DrySnowGAT, SnowAgeGAT, DriftGAT, SublGAT, &
                             TSNOdsGAT, &
                             NML, il1, il2, N, cf%ZRFM, ZOMLCS, ZOMLNS)
            end if

            call CLASSZ(1, CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
                        WTVSTP, WTSSTP, WTGSTP, &
                        cdv%FSGV, cdv%FLGV, cdv%HFSC, cdv%HEVC, cdv%HMFC, cdv%HTCC, &
                        cdv%FSGS, cdv%FLGS, cdv%HFSS, cdv%HEVS, cdv%HMFN, cdv%HTCS, &
                        cdv%FSGG, cdv%FLGG, cdv%HFSG, cdv%HEVG, cdv%HMFG, cdv%HTC, &
                        cdv%PCFC, cdv%PCLC, cdv%QFCF, cdv%QFCL, cdv%ROFC, cdv%WTRC, &
                        cdv%PCPN, cdv%QFN, cdv%ROFN, cdv%WTRS, cdv%PCPG, cdv%QFG, &
                        cdv%QFC, cdv%ROF, cdv%WTRG, cpv%CMAI, cpv%RCAN, cpv%SNCAN, &
                        cpv%TCAN, cpv%SNO, cpv%WSNO, cpv%TSNO, cpv%THLQ, cpv%THIC, &
                        HCPSGAT, THPGAT, cpv%DELZW, cpv%TBAR, cpv%ZPND, cpv%TPND, &
                        sl%DELZ, cdv%FCS, cdv%FGS, cdv%FC, cdv%FG, &
                        il1, il2, NML, IGND, N, &
                        DriftGAT, SublGAT)

!          *Redistribute blowing snow mass between GRUs
            call REDISTRIB_SNOW(NML, 1, NA, NTYPE, NML, cpv%TSNO, ZSNOW, &
                                cpv%RHOS, cpv%SNO, TSNOCS, ZSNOCS, HCPSCS, RHOSCS, TSNOGS, &
                                ZSNOGS, HCPSGS, RHOSGS, TSNOWC, ZSNOWC, HCPSC, RHOSC, TSNOWG, &
                                ZSNOWG, HCPSG, RHOSG, cp%GCGRD, shd%lc%ILMOS, DriftGAT, FAREGAT, &
                                TSNOdsGAT, DistribGAT, WSNOCS, WSNOGS, cdv%FCS, cdv%FGS, cdv%FC, cdv%FG, DepositionGAT, &
                                cdv%TROO, cdv%ROFO, cdv%TROF, cdv%ROF, cdv%ROFN, cdv%PCPG, cdv%HTCS, cpv%WSNO, N)
            cdv%ROF = cdv%ROF - UMQ

        end if !(ipid /= 0 .or. izero == 0) then

        call run_within_tile(shd, fls, ts, ic, cm, wb, eb, sp, stfl, rrls)

!> *********************************************************************
!> End of the NML-based LSS loop.
!> *********************************************************************

! *********************************************************************
! Calculate values for output files and print them out
! *********************************************************************

    !> Send/receive process.
        itag = NSUM_TOTAL*1000
        invars = 14 + 4*IGND

    !> Update the variable count per the active control flags.
        if (SAVERESUMEFLAG == 3) invars = invars + 10 + 4

        if (inp > 1 .and. ipid /= 0) then

        !> Send data back to head-node.

            if (allocated(irqst)) deallocate(irqst)
            if (allocated(imstat)) deallocate(imstat)
            allocate(irqst(invars), imstat(mpi_status_size, invars))
            irqst = mpi_request_null

            i = 1
            call mpi_isend(cf%PRE(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%QFS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROF(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROFO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROFS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROFB(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%SNCAN(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%RCAN(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%ZPND(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%SNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%FSNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%WSNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%HFS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%QEVP(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            do j = 1, IGND
                call mpi_isend(cpv%THLQ(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%THIC(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cdv%GFLX(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TBAR(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            end do

        !> Send optional variables per the active control flags.
            if (SAVERESUMEFLAG == 3) then
                call mpi_isend(cpv%ALBS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%CMAI(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%GRO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%QAC(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%RHOS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TAC(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TBAS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TCAN(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TPND(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TSNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                do j = 1, 4
                    call mpi_isend(cpv%TSFS(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                end do
            end if !(SAVERESUMEFLAG == 3) then

            lstat = .false.
            do while (.not. lstat)
                call mpi_testall(invars, irqst, lstat, imstat, ierr)
            end do

!            print *, ipid, ' done sending'

        else if (inp > 1) then

        !> Receive data from worker nodes.
            if (allocated(irqst)) deallocate(irqst)
            if (allocated(imstat)) deallocate(imstat)
            allocate(irqst(invars), imstat(mpi_status_size, invars))

        !> Receive and assign variables.
            do u = 1, (inp - 1)

!                print *, 'initiating irecv for:', u, ' with ', itag

                irqst = mpi_request_null
                imstat = 0

                call GetIndices(inp, izero, u, shd%lc%NML, shd%lc%ILMOS, ii1, ii2, iilen)

                i = 1
                call mpi_irecv(cf%PRE(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%QFS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROF(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROFO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROFS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROFB(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%SNCAN(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%RCAN(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%ZPND(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%SNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%FSNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%WSNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%HFS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%QEVP(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                do j = 1, IGND
                    call mpi_irecv(cpv%THLQ(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%THIC(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cdv%GFLX(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TBAR(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                end do

            !> Send optional variables per the active control flags.
                if (SAVERESUMEFLAG == 3) then
                    call mpi_irecv(cpv%ALBS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%CMAI(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%GRO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%QAC(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%RHOS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TAC(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TBAS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TCAN(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TPND(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TSNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    do j = 1, 4
                        call mpi_irecv(cpv%TSFS(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr)
                        i = i + 1
                    end do
                end if !(SAVERESUMEFLAG == 3) then

                lstat = .false.
                do while (.not. lstat)
                    call mpi_testall(invars, irqst, lstat, imstat, ierr)
                end do

            end do !u = 1, (inp - 1)
!            print *, 'done receiving'

        end if !(inp > 1 .and. ipid /= 0) then

        if (inp > 1 .and. NCOUNT == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

!> *********************************************************************
!> Start of book-keeping and grid accumulation.
!> *********************************************************************

        if (ipid == 0) then

!> Write ENSIM output
!> -----------------------------------------------------c
!>
            if (NR2CFILES > 0 .and. mod(NCOUNT*30, DELTR2C) == 0) then
                call FIND_MONTH (JDAY_NOW, YEAR_NOW, ensim_month)
                call FIND_DAY (JDAY_NOW, YEAR_NOW, ensim_day)
                call WRITE_R2C_DATA(shd%lc%NML, NA, NTYPE, NCOUNT, MINS_NOW, shd%lc%ACLASS, &
                                    NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, &
                                    NR2C, NR2CFILES, R2CFILEUNITSTART, GRD, GAT, &
                                    GRDGAT, NR2CSTATES, R2C_ATTRIBUTES, FRAME_NO_NEW, YEAR_NOW, &
                                    ensim_MONTH, ensim_DAY, HOUR_NOW, MINS_NOW, ICAN, &
                                    ICAN + 1, IGND, &
                                    cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
                                    cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
                                    cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
                                    FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
                                    PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
                                    VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
                                    HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
                                    THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
                                    GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, &
                                    THFCGAT, PSIWGAT, cpv%DELZW, ZBTWGAT, &
                                    ZSNLGAT, ZPLGGAT, ZPLSGAT, cpv%TAC, cpv%QAC, &
                                    DRNGAT, XSLPGAT, XDGAT, WFSFGAT, KSGAT, &
                                    ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
                                    AGIDGAT, ISNDGAT, RADJGAT, cf%ZBLD, Z0ORGAT, &
                                    cf%ZRFM, cf%ZRFH, ZDMGAT, ZDHGAT, cf%FSVH, &
                                    cf%FSIH, CSZGAT, cf%FDL, cf%UL, cf%VL, &
                                    cf%TA, cf%QA, cf%PRES, cf%PRE, PADRGAT, &
                                    VPDGAT, TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, &
                                    SPCPGAT, TSPCGAT, RHSIGAT, cf%FCLO, DLONGAT, &
                                    GGEOGAT, &
                                    cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
                                    cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
                                    cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
                                    cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
                                    cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
                                    cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
                                    cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
                                    cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
                                    cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
                                    cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
                                    cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                                    cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
                                    cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
                                    IGDRGAT, cf%VMOD, QLWOGAT)
                FRAME_NO_NEW = FRAME_NO_NEW + 1 !UPDATE COUNTERS
            end if

!> =======================================================================
!>     * CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.

!> many of these varibles are currently not being used for anything,
!> but we want to keep them because they may be useful in the future.
!> these variables hold the grid cell averages. 
!> In the future, someone will need to use them.

            CDHGRD = 0.0
            CDMGRD = 0.0
            HFSGRD = 0.0
            TFXGRD = 0.0
            QEVPGRD = 0.0
            QFSGRD = 0.0
            QFXGRD = 0.0
            PETGRD = 0.0
            GAGRD = 0.0
            EFGRD = 0.0
            GTGRD = 0.0
            QGGRD = 0.0
            TSFGRD = 0.0
            ALVSGRD = 0.0
            ALIRGRD = 0.0
            SFCTGRD = 0.0
            SFCUGRD = 0.0
            SFCVGRD = 0.0
            SFCQGRD = 0.0
            FSNOGRD = 0.0
            FSGVGRD = 0.0
            FSGSGRD = 0.0
            FSGGGRD = 0.0
            SNOGRD = 0.0
            FLGVGRD = 0.0
            FLGSGRD = 0.0
            FLGGGRD = 0.0
            HFSCGRD = 0.0
            HFSSGRD = 0.0
            HFSGGRD = 0.0
            HEVCGRD = 0.0
            HEVSGRD = 0.0
            HEVGGRD = 0.0
            HMFCGRD = 0.0
            HMFNGRD = 0.0
            HTCCGRD = 0.0
            HTCSGRD = 0.0
            PCFCGRD = 0.0
            PCLCGRD = 0.0
            PCPNGRD = 0.0
            PCPGGRD = 0.0
            QFGGRD = 0.0
            QFNGRD = 0.0
            QFCLGRD = 0.0
            QFCFGRD = 0.0
            ROFGRD = 0.0
            ROFOGRD = 0.0
            ROFSGRD = 0.0
            ROFBGRD = 0.0
            ROFCGRD = 0.0
            ROFNGRD = 0.0
            ROVGGRD = 0.0
            WTRCGRD = 0.0
            WTRSGRD = 0.0
            WTRGGRD = 0.0
            DRGRD = 0.0
            WTABGRD = 0.0
            ILMOGRD = 0.0
            UEGRD = 0.0
            HBLGRD = 0.0
            HMFGGRD = 0.0
            HTCGRD = 0.0
            QFCGRD = 0.0
            GFLXGRD = 0.0

    !> Grid data for output.
            md%fsdown = cm%clin(cfk%FB)%GRD
            md%fsvh = fsvhgrd
            md%fsih = fsihgrd
            md%fdl = cm%clin(cfk%FI)%GRD
            md%ul = cm%clin(cfk%UV)%GRD
            md%ta = cm%clin(cfk%TT)%GRD
            md%qa = cm%clin(cfk%HU)%GRD
            md%pres = cm%clin(cfk%P0)%GRD
            md%pre = cm%clin(cfk%PR)%GRD

!> GRU-distributed data for output.
            wb_h%pre = 0.0
            wb_h%evap = 0.0
            wb_h%rof = 0.0
            wb_h%rofo = 0.0
            wb_h%rofs = 0.0
            wb_h%rofb = 0.0
            wb_h%rcan = 0.0
            wb_h%sncan = 0.0
            wb_h%pndw = 0.0
            wb_h%sno = 0.0
            wb_h%wsno = 0.0
            wb_h%lqws = 0.0
            wb_h%frws = 0.0

            !$omp parallel do
            do k = il1, il2
                ik = shd%lc%ILMOS(k)
                CDHGRD(ik) = CDHGRD(ik) + cdv%CDH(k)*FAREGAT(k)
                CDMGRD(ik) = CDMGRD(ik) + cdv%CDM(k)*FAREGAT(k)
                HFSGRD(ik) = HFSGRD(ik) + cdv%HFS(k)*FAREGAT(k)
                TFXGRD(ik) = TFXGRD(ik) + cdv%TFX(k)*FAREGAT(k)
                QEVPGRD(ik) = QEVPGRD(ik) + cdv%QEVP(k)*FAREGAT(k)
                QFSGRD(ik) = QFSGRD(ik) + cdv%QFS(k)*FAREGAT(k)
                QFXGRD(ik) = QFXGRD(ik) + cdv%QFX(k)*FAREGAT(k)
                PETGRD(ik) = PETGRD(ik) + cdv%PET(k)*FAREGAT(k)
                GAGRD(ik) = GAGRD(ik) + cdv%GA(k)*FAREGAT(k)
                EFGRD(ik) = EFGRD(ik) + cdv%EF(k)*FAREGAT(k)
                GTGRD(ik) = GTGRD(ik) + cdv%GTE(k)*FAREGAT(k)
                QGGRD(ik) = QGGRD(ik) + cdv%QG(k)*FAREGAT(k)
!                TSFGRD(ik) = TSFGRD(ik) + cdv%TSF(k)*FAREGAT(k)
                ALVSGRD(ik) = ALVSGRD(ik) + cdv%ALVS(k)*FAREGAT(k)
                ALIRGRD(ik) = ALIRGRD(ik) + cdv%ALIR(k)*FAREGAT(k)
                SFCTGRD(ik) = SFCTGRD(ik) + cdv%SFCT(k)*FAREGAT(k)
                SFCUGRD(ik) = SFCUGRD(ik) + cdv%SFCU(k)*FAREGAT(k)
                SFCVGRD(ik) = SFCVGRD(ik) + cdv%SFCV(k)*FAREGAT(k)
                SFCQGRD(ik) = SFCQGRD(ik) + cdv%SFCQ(k)*FAREGAT(k)
                FSNOGRD(ik) = FSNOGRD(ik) + cdv%FSNO(k)*FAREGAT(k)
                FSGVGRD(ik) = FSGVGRD(ik) + cdv%FSGV(k)*FAREGAT(k)
                FSGSGRD(ik) = FSGSGRD(ik) + cdv%FSGS(k)*FAREGAT(k)
                FSGGGRD(ik) = FSGGGRD(ik) + cdv%FSGG(k)*FAREGAT(k)
                SNOGRD(ik) = SNOGRD(ik) + cpv%SNO(k)*FAREGAT(k)
                FLGVGRD(ik) = FLGVGRD(ik) + cdv%FLGV(k)*FAREGAT(k)
                FLGSGRD(ik) = FLGSGRD(ik) + cdv%FLGS(k)*FAREGAT(k)
                FLGGGRD(ik) = FLGGGRD(ik) + cdv%FLGG(k)*FAREGAT(k)
                HFSCGRD(ik) = HFSCGRD(ik) + cdv%HFSC(k)*FAREGAT(k)
                HFSSGRD(ik) = HFSSGRD(ik) + cdv%HFSS(k)*FAREGAT(k)
                HFSGGRD(ik) = HFSGGRD(ik) + cdv%HFSG(k)*FAREGAT(k)
                HEVCGRD(ik) = HEVCGRD(ik) + cdv%HEVC(k)*FAREGAT(k)
                HEVSGRD(ik) = HEVSGRD(ik) + cdv%HEVS(k)*FAREGAT(k)
                HEVGGRD(ik) = HEVGGRD(ik) + cdv%HEVG(k)*FAREGAT(k)
                HMFCGRD(ik) = HMFCGRD(ik) + cdv%HMFC(k)*FAREGAT(k)
                HMFNGRD(ik) = HMFNGRD(ik) + cdv%HMFN(k)*FAREGAT(k)
                HTCCGRD(ik) = HTCCGRD(ik) + cdv%HTCC(k)*FAREGAT(k)
                HTCSGRD(ik) = HTCSGRD(ik) + cdv%HTCS(k)*FAREGAT(k)
                PCFCGRD(ik) = PCFCGRD(ik) + cdv%PCFC(k)*FAREGAT(k)
                PCLCGRD(ik) = PCLCGRD(ik) + cdv%PCLC(k)*FAREGAT(k)
                PCPNGRD(ik) = PCPNGRD(ik) + cdv%PCPN(k)*FAREGAT(k)
                PCPGGRD(ik) = PCPGGRD(ik) + cdv%PCPG(k)*FAREGAT(k)
                QFGGRD(ik) = QFGGRD(ik) + cdv%QFG(k)*FAREGAT(k)
                QFNGRD(ik) = QFNGRD(ik) + cdv%QFN(k)*FAREGAT(k)
                QFCLGRD(ik) = QFCLGRD(ik) + cdv%QFCL(k)*FAREGAT(k)
                QFCFGRD(ik) = QFCFGRD(ik) + cdv%QFCF(k)*FAREGAT(k)
                ROFGRD(ik) = ROFGRD(ik) + cdv%ROF(k)*FAREGAT(k)
                ROFOGRD(ik) = ROFOGRD(ik) + cdv%ROFO(k)*FAREGAT(k)
                ROFSGRD(ik) = ROFSGRD(ik) + cdv%ROFS(k)*FAREGAT(k)
                ROFBGRD(ik) = ROFBGRD(ik) + cdv%ROFB(k)*FAREGAT(k)
                ROFCGRD(ik) = ROFCGRD(ik) + cdv%ROFC(k)*FAREGAT(k)
                ROFNGRD(ik) = ROFNGRD(ik) + cdv%ROFN(k)*FAREGAT(k)
                ROVGGRD(ik) = ROVGGRD(ik) + cdv%ROVG(k)*FAREGAT(k)
                WTRCGRD(ik) = WTRCGRD(ik) + cdv%WTRC(k)*FAREGAT(k)
                WTRSGRD(ik) = WTRSGRD(ik) + cdv%WTRS(k)*FAREGAT(k)
                WTRGGRD(ik) = WTRGGRD(ik) + cdv%WTRG(k)*FAREGAT(k)
                DRGRD(ik) = DRGRD(ik) + cdv%DR(k)*FAREGAT(k)
                WTABGRD(ik) = WTABGRD(ik) + cdv%WTAB(k)*FAREGAT(k)
                ILMOGRD(ik) = ILMOGRD(ik) + cdv%ILMO(k)*FAREGAT(k)
                UEGRD(ik) = UEGRD(ik) + cdv%UE(k)*FAREGAT(k)
                HBLGRD(ik) = HBLGRD(ik) + cdv%HBL(k)*FAREGAT(k)
                wb_h%pre(ik) = wb_h%pre(ik) + FAREGAT(k)*cf%PRE(k)*DELT
                wb_h%evap(ik) = wb_h%evap(ik) + FAREGAT(k)*cdv%QFS(k)*DELT
                wb_h%rof(ik) = wb_h%rof(ik) + FAREGAT(k)*cdv%ROF(k)*DELT
                wb_h%rofo(ik) = wb_h%rofo(ik) + FAREGAT(k)*cdv%ROFO(k)*DELT
                wb_h%rofs(ik) = wb_h%rofs(ik) + FAREGAT(k)*cdv%ROFS(k)*DELT
                wb_h%rofb(ik) = wb_h%rofb(ik) + FAREGAT(k)*cdv%ROFB(k)*DELT
                wb_h%rcan(ik) = wb_h%rcan(ik) + FAREGAT(k)*cpv%RCAN(k)
                wb_h%sncan(ik) = wb_h%sncan(ik) + FAREGAT(k)*cpv%SNCAN(k)
                wb_h%pndw(ik) = wb_h%pndw(ik) + FAREGAT(k)*cpv%ZPND(k)*RHOW
                wb_h%sno(ik) = wb_h%sno(ik) + FAREGAT(k)*cpv%SNO(k)
                wb_h%wsno(ik) = wb_h%wsno(ik) + FAREGAT(k)*cpv%WSNO(k)
                do j = 1, IGND
                    HMFGGRD(ik, j) = HMFGGRD(ik, j) + cdv%HMFG(k, j)*FAREGAT(k)
                    HTCGRD(ik, j) = HTCGRD(ik, j) + cdv%HTC(k, j)*FAREGAT(k)
                    QFCGRD(ik, j) = QFCGRD(ik, j) + cdv%QFC(k, j)*FAREGAT(k)
                    GFLXGRD(ik, j) = GFLXGRD(ik, j) + cdv%GFLX(k, j)*FAREGAT(k)
                    wb_h%lqws(ik, j) = wb_h%lqws(ik, j) + FAREGAT(k)*cpv%THLQ(k, j)*cpv%DELZW(k, j)*RHOW
                    wb_h%frws(ik, j) = wb_h%frws(ik, j) + FAREGAT(k)*cpv%THIC(k, j)*cpv%DELZW(k, j)*RHOICE
                end do
                wb_h%stg(ik) = wb%rcan(ik) + wb%sncan(ik) + wb%pndw(ik) + &
                    wb%sno(ik) + wb%wsno(ik) + &
                    sum(wb%lqws(ik, :)) + sum(wb%frws(ik, :))
            end do !k = il1, il2

!> calculate and write the basin avg SCA similar to watclass3.0f5
!> Same code than in wf_ensim.f subrutine of watclass3.0f8
!> Especially for version MESH_Prototype 3.3.1.7b (not to be incorporated in future versions)
!> calculate and write the basin avg SWE using the similar fudge factor!!!

!            if (BASIN_FRACTION(1) == -1) then
!                do i = 1, NA ! NA = number of grid squares
!>         BASIN_FRACTION is the basin snow cover
!>         (portions of the grids outside the basin are not included)
!>         for a given day - JDAY_NOW in the if statement
!                    BASIN_FRACTION(i) = shd%FRAC(i)
    !TODO: FRAC is not actually the fraction of the grid square
    !within the basin, we should be using some other value, but I'm
    !not sure what.
    !todo: calculate frac and write document to send to someone else.
!                end do
!            end if

            if (HOUR_NOW == 12 .and. MINS_NOW == 0) then
                basin_SCA = 0.0
                basin_SWE = 0.0
!                do i = 1, NA
!                    if (BASIN_FRACTION(i) /= 0.0) then
!                        basin_SCA = basin_SCA + FSNOGRD(i)/BASIN_FRACTION(i)
!                        basin_SWE = basin_SWE + SNOGRD(i)/BASIN_FRACTION(i)
!                    end if
!                end do
!                basin_SCA = basin_SCA/NA
!                basin_SWE = basin_SWE/NA

! BRUCE DAVISON - AUG 17, 2009 (see notes in my notebook for this day)
! Fixed calculation of basin averages. Needs documenting and testing.
                do k = il1, il2
                    basin_SCA = basin_SCA + cdv%FSNO(k)*FAREGAT(k)
                    basin_SWE = basin_SWE + cpv%SNO(k)*FAREGAT(k)
                end do
                basin_SCA = basin_SCA/TOTAL_AREA
                basin_SWE = basin_SWE/TOTAL_AREA
                if (BASINSWEOUTFLAG > 0) then
                    write(85, "(i5,',', f10.3)") JDAY_NOW, basin_SCA
                    write(86, "(i5,',', f10.3)") JDAY_NOW, basin_SWE
                end if
            end if

!> =======================================================================
!> ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.

            !$omp parallel do
            do k = il1, il2
                ik = shd%lc%ILMOS(k)
                if (shd%FRAC(ik) /= 0.0) then
                    PREACC(ik) = PREACC(ik) + cf%PRE(k)*FAREGAT(k)*DELT
                    QEVPACC(ik) = QEVPACC(ik) + cdv%QEVP(k)*FAREGAT(k)
                    EVAPACC(ik) = EVAPACC(ik) + cdv%QFS(k)*FAREGAT(k)*DELT
                    HFSACC(ik)  = HFSACC(ik) + cdv%HFS(k)*FAREGAT(k)
                    ROFACC(ik) = ROFACC(ik) + cdv%ROF(k)*FAREGAT(k)*DELT
                    ROFOACC(ik) = ROFOACC(ik) + cdv%ROFO(k)*FAREGAT(k)*DELT
                    ROFSACC(ik) = ROFSACC(ik) + cdv%ROFS(k)*FAREGAT(k)*DELT
                    ROFBACC(ik) = ROFBACC(ik) + cdv%ROFB(k)*FAREGAT(k)*DELT
                    do j = 1, IGND
                        THLQACC(ik, j) = THLQACC(ik, j) + cpv%THLQ(k, j)*FAREGAT(k)
                        THICACC(ik, j) = THICACC(ik, j) + cpv%THIC(k, j)*FAREGAT(k)
                        THALACC(ik, j) = THALACC(ik, j) + (cpv%THLQ(k, j) + cpv%THIC(k, j))*FAREGAT(k)
            !Added by GSA compute daily heat conduction flux between layers
                        GFLXACC(ik, j) = GFLXACC(ik, j) + cdv%GFLX(k, j)*FAREGAT(k)
                    end do
                    if (cpv%SNO(k) > 0.0) then
                        WSNOACC(ik) = WSNOACC(ik) + cpv%WSNO(k)*FAREGAT(k)
                        SNOARE(ik) = SNOARE(ik) + FAREGAT(k)
                    end if
                    SNOACC(ik) = SNOACC(ik) + cpv%SNO(k)*FAREGAT(k)
                    RCANACC(ik) = RCANACC(ik) + cpv%RCAN(k)*FAREGAT(k)
                    SCANACC(ik) = SCANACC(ik) + cpv%SNCAN(k)*FAREGAT(k)
                end if
            end do !k = il1, il2

    !> Update output data.
            call updatefieldsout_temp(shd, ts, ic, ifo, &
                                      md, wb_h, &
                                      vr)

!> CALCULATE AND PRINT DAILY AVERAGES.

!todo: use delta t here
            if (NCOUNT == 48) then !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

    !no omp b/c of file IO
                do i = 1, NA
                    if (shd%FRAC(i) /= 0.0) then
                        PREACC(i) = PREACC(i)
                        QEVPACC(i) = QEVPACC(i)/real(NSUM)
                        EVAPACC(i) = EVAPACC(i)
                        HFSACC(i) = HFSACC(i)/real(NSUM)
                        ROFACC(i) = ROFACC(i)
                        ROFOACC(i) = ROFOACC(i)
                        ROFSACC(i) = ROFSACC(i)
                        ROFBACC(i) = ROFBACC(i)
                        do j = 1, IGND
                            THLQACC(i, j) = THLQACC(i, j)/real(NSUM)
                            THICACC(i, j) = THICACC(i, j)/real(NSUM)
                            THALACC(i, j) = THALACC(i, j)/real(NSUM)
                        end do
                        if (SNOARE(i) > 0.0) then
                            WSNOACC(i) = WSNOACC(i)/SNOARE(i)
                        end if
                        SNOACC(i) = SNOACC(i)/real(NSUM)
                        RCANACC(i) = RCANACC(i)/real(NSUM)
                        SCANACC(i) = SCANACC(i)/real(NSUM)

!> update components for final water balance tally
                        TOTAL_PRE = TOTAL_PRE + PREACC(i)
                        TOTAL_EVAP = TOTAL_EVAP + EVAPACC(i)
                        TOTAL_ROF = TOTAL_ROF + ROFACC(i)
                        TOTAL_ROFO = TOTAL_ROFO + ROFOACC(i)
                        TOTAL_ROFS = TOTAL_ROFS + ROFSACC(i)
                        TOTAL_ROFB = TOTAL_ROFB + ROFBACC(i)
                        TOTAL_PREACC = TOTAL_PREACC + PREACC(i)
                        TOTAL_EVAPACC = TOTAL_EVAPACC + EVAPACC(i)
                        TOTAL_ROFACC = TOTAL_ROFACC + ROFACC(i)
                        TOTAL_ROFOACC = TOTAL_ROFOACC + ROFOACC(i)
                        TOTAL_ROFSACC = TOTAL_ROFSACC + ROFSACC(i)
                        TOTAL_ROFBACC = TOTAL_ROFBACC + ROFBACC(i)
                        wb%pre(i) = wb%pre(i) + PREACC(i)
                        wb%evap(i) = wb%evap(i) + EVAPACC(i)
                        wb%rof(i) = wb%rof(i) + ROFACC(i)
                        wb%rofo(i) = wb%rofo(i) + ROFOACC(i)
                        wb%rofs(i) =  wb%rofs(i) + ROFSACC(i)
                        wb%rofb(i) = wb%rofb(i) + ROFBACC(i)

!> update components for final energy balance tally
                        TOTAL_HFSACC  = TOTAL_HFSACC  + HFSACC(i)
                        TOTAL_QEVPACC = TOTAL_QEVPACC + QEVPACC(i)
                        eb%hfs(i) = eb%hfs(i) + HFSACC(i)
                        eb%qevp(i) = eb%qevp(i) + QEVPACC(i)
                        do j = 1, IGND
                            eb%gflx(i, j) = eb%gflx(i, j) + GFLXACC(i, j)
                        end do
                    end if
                end do

    !> update components for final water balance tally

                do k = il1, il2
                    ik = shd%lc%ILMOS(k)
                    if (shd%FRAC(ik) >= 0.0) then
                        TOTAL_SCAN = TOTAL_SCAN + FAREGAT(k)*cpv%SNCAN(k)
                        TOTAL_RCAN = TOTAL_RCAN + FAREGAT(k)*cpv%RCAN(k)
                        TOTAL_SNO = TOTAL_SNO + FAREGAT(k)*cpv%SNO(k)
                        TOTAL_WSNO = TOTAL_WSNO + FAREGAT(k)*cpv%WSNO(k)
                        TOTAL_ZPND = TOTAL_ZPND + FAREGAT(k)*cpv%ZPND(k)*RHOW
                        wb%rcan(ik) = wb%rcan(ik) + FAREGAT(k)*cpv%RCAN(k)
                        wb%sncan(ik) = wb%sncan(ik) + FAREGAT(k)*cpv%SNCAN(k)
                        wb%pndw(ik) = wb%pndw(ik) + FAREGAT(k)*cpv%ZPND(k)*RHOW
                        wb%sno(ik) = wb%sno(ik) + FAREGAT(k)*cpv%SNO(k)
                        wb%wsno(ik) = wb%wsno(ik) + FAREGAT(k)*cpv%WSNO(k)
                        do j = 1, IGND
                            TOTAL_THLQ(j) = TOTAL_THLQ(j) + FAREGAT(k)*cpv%THLQ(k, j)*RHOW*cpv%DELZW(k, j)
                            TOTAL_THIC(j) = TOTAL_THIC(j) + FAREGAT(k)*cpv%THIC(k, j)*RHOICE*cpv%DELZW(k, j)
                            wb%lqws(ik, j) = wb%lqws(ik, j) + FAREGAT(k)*cpv%THLQ(k, j)*RHOW*cpv%DELZW(k, j)
                            wb%frws(ik, j) = wb%frws(ik, j) + FAREGAT(k)*cpv%THIC(k, j)*RHOICE*cpv%DELZW(k, j)
                            sp%tbar(ik, j) = sp%tbar(ik, j) + cpv%TBAR(k, j)*shd%lc%ACLASS(ik, shd%lc%JLMOS(k))
                            sp%thlq(ik, j) = sp%thlq(ik, j) + FAREGAT(k)*cpv%THLQ(k, j)
                            sp%thic(ik, j) = sp%thic(ik, j) + FAREGAT(k)*cpv%THIC(k, j)
                        end do
                    end if !(shd%FRAC(ik) >= 0.0) then
                end do !k = il1, il2

    !> Calculate storage
                wb%stg = wb%rcan + wb%sncan + wb%pndw + wb%sno + wb%wsno + sum(wb%lqws, 2) + sum(wb%frws, 2)
                wb%dstg = wb%stg - wb%dstg
                TOTAL_STORE = TOTAL_SCAN + TOTAL_RCAN + TOTAL_SNO + TOTAL_WSNO + TOTAL_ZPND + sum(TOTAL_THLQ) + sum(TOTAL_THIC)

    !> Write output CSV files.
                if (BASINBALANCEOUTFLAG > 0) then

        !> Water balance.
                    write(fls%fl(mfk%f900)%iun, "(i4,',', i5,',', 999(e14.6,','))") &
                          JDAY_NOW, YEAR_NOW, &
                          TOTAL_PREACC/TOTAL_AREA, &
                          TOTAL_EVAPACC/TOTAL_AREA, &
                          TOTAL_ROFACC/TOTAL_AREA, &
                          TOTAL_ROFOACC/TOTAL_AREA, &
                          TOTAL_ROFSACC/TOTAL_AREA, &
                          TOTAL_ROFBACC/TOTAL_AREA, &
                          TOTAL_PRE/TOTAL_AREA, &
                          TOTAL_EVAP/TOTAL_AREA, &
                          TOTAL_ROF/TOTAL_AREA, &
                          TOTAL_ROFO/TOTAL_AREA, &
                          TOTAL_ROFS/TOTAL_AREA, &
                          TOTAL_ROFB/TOTAL_AREA, &
                          TOTAL_SCAN/TOTAL_AREA, &
                          TOTAL_RCAN/TOTAL_AREA, &
                          TOTAL_SNO/TOTAL_AREA, &
                          TOTAL_WSNO/TOTAL_AREA, &
                          TOTAL_ZPND/TOTAL_AREA, &
                          (TOTAL_THLQ(j)/TOTAL_AREA, j = 1, IGND), &
                          (TOTAL_THIC(j)/TOTAL_AREA, j = 1, IGND), &
                          ((TOTAL_THLQ(j) + TOTAL_THIC(j))/TOTAL_AREA, j = 1, IGND), &
                          SUM(TOTAL_THLQ(1:IGND))/TOTAL_AREA, &
                          SUM(TOTAL_THIC(1:IGND))/TOTAL_AREA, &
                          (SUM(TOTAL_THLQ(1:IGND)) + SUM(TOTAL_THIC(1:IGND)))/TOTAL_AREA, &
                          TOTAL_STORE/TOTAL_AREA, &
                          (TOTAL_STORE - TOTAL_STORE_2)/TOTAL_AREA, &
                          (TOTAL_STORE - INIT_STORE)/TOTAL_AREA

        !> Energy balance.
                    write(901, "(i4,',', i5,',', 999(e12.5,','))") &
                          JDAY_NOW, YEAR_NOW, &
                          TOTAL_HFSACC/TOTAL_AREA, &
                          TOTAL_QEVPACC/TOTAL_AREA

        ! Monthly totals.
                    TOTAL_PRE_ACC_M = TOTAL_PRE_ACC_M + TOTAL_PRE
                    TOTAL_EVAP_ACC_M = TOTAL_EVAP_ACC_M + TOTAL_EVAP
                    TOTAL_ROF_ACC_M = TOTAL_ROF_ACC_M + TOTAL_ROF
                    TOTAL_ROFO_ACC_M = TOTAL_ROFO_ACC_M + TOTAL_ROFO
                    TOTAL_ROFS_ACC_M = TOTAL_ROFS_ACC_M + TOTAL_ROFS
                    TOTAL_ROFB_ACC_M = TOTAL_ROFB_ACC_M + TOTAL_ROFB
                    TOTAL_PRE_M = TOTAL_PRE_M + TOTAL_PRE
                    TOTAL_EVAP_M = TOTAL_EVAP_M + TOTAL_EVAP
                    TOTAL_ROF_M = TOTAL_ROF_M + TOTAL_ROF
                    TOTAL_ROFO_M = TOTAL_ROFO_M + TOTAL_ROFO
                    TOTAL_ROFS_M = TOTAL_ROFS_M + TOTAL_ROFS
                    TOTAL_ROFB_M = TOTAL_ROFB_M + TOTAL_ROFB
                    TOTAL_SCAN_M = TOTAL_SCAN_M + TOTAL_SCAN
                    TOTAL_RCAN_M = TOTAL_RCAN_M + TOTAL_RCAN
                    TOTAL_SNO_M = TOTAL_SNO_M + TOTAL_SNO
                    TOTAL_WSNO_M = TOTAL_WSNO_M + TOTAL_WSNO
                    TOTAL_ZPND_M = TOTAL_ZPND_M + TOTAL_ZPND
                    TOTAL_THLQ_M = TOTAL_THLQ_M + TOTAL_THLQ
                    TOTAL_THIC_M = TOTAL_THIC_M + TOTAL_THIC
                    TOTAL_STORE_M = TOTAL_STORE
                    TOTAL_STORE_ACC_M = TOTAL_STORE

        ! Write out monthly totals.
                    call FIND_MONTH(JDAY_NOW, YEAR_NOW, imonth_now)
                    if (imonth_now /= imonth_old) then
                        write(902, "(i4,',', i5,',', 999(e14.6,','))") &
                              JDAY_NOW, YEAR_NOW, &
                              TOTAL_PRE_ACC_M/TOTAL_AREA, &
                              TOTAL_EVAP_ACC_M/TOTAL_AREA, &
                              TOTAL_ROF_ACC_M/TOTAL_AREA, &
                              TOTAL_ROFO_ACC_M/TOTAL_AREA, &
                              TOTAL_ROFS_ACC_M/TOTAL_AREA, &
                              TOTAL_ROFB_ACC_M/TOTAL_AREA, &
                              TOTAL_PRE_M/TOTAL_AREA, &
                              TOTAL_EVAP_M/TOTAL_AREA, &
                              TOTAL_ROF_M/TOTAL_AREA, &
                              TOTAL_ROFO_M/TOTAL_AREA, &
                              TOTAL_ROFS_M/TOTAL_AREA, &
                              TOTAL_ROFB_M/TOTAL_AREA, &
                              TOTAL_SCAN_M/TOTAL_AREA, &
                              TOTAL_RCAN_M/TOTAL_AREA, &
                              TOTAL_SNO_M/TOTAL_AREA, &
                              TOTAL_WSNO_M/TOTAL_AREA, &
                              TOTAL_ZPND_M/TOTAL_AREA, &
                              (TOTAL_THLQ_M(j)/TOTAL_AREA, j = 1, IGND), &
                              (TOTAL_THIC_M(j)/TOTAL_AREA, j = 1, IGND), &
                              ((TOTAL_THLQ_M(j) + TOTAL_THIC_M(j))/TOTAL_AREA, j = 1, IGND), &
                              sum(TOTAL_THLQ_M(1:IGND))/TOTAL_AREA, &
                              sum(TOTAL_THIC_M(1:IGND))/TOTAL_AREA, &
                              (sum(TOTAL_THLQ_M(1:IGND)) + sum(TOTAL_THIC_M(1:IGND)))/TOTAL_AREA, &
                              TOTAL_STORE_M/TOTAL_AREA, &
                              (TOTAL_STORE_M - TOTAL_STORE_2_M)/TOTAL_AREA, &
                              (TOTAL_STORE_ACC_M - INIT_STORE)/TOTAL_AREA
                        TOTAL_PRE_M = 0.0
                        TOTAL_EVAP_M = 0.0
                        TOTAL_ROF_M = 0.0
                        TOTAL_ROFO_M = 0.0
                        TOTAL_ROFS_M = 0.0
                        TOTAL_ROFB_M = 0.0
                        TOTAL_SCAN_M = 0.0
                        TOTAL_RCAN_M = 0.0
                        TOTAL_SNO_M = 0.0
                        TOTAL_WSNO_M = 0.0
                        TOTAL_ZPND_M = 0.0
                        TOTAL_THLQ_M = 0.0
                        TOTAL_THIC_M = 0.0
                        TOTAL_STORE_2_M = TOTAL_STORE_M
                        TOTAL_STORE_M = 0.0
                        imonth_old = imonth_now
                    end if
                end if !(BASINBALANCEOUTFLAG > 0) then

!>  Added by Gonzalo Sapriza
    !DELTA STORAGE
                do i = 1, IGND
                    DSTG = DSTG + THLQ_FLD(:, i) + THIC_FLD(:, i)
                end do
                DSTG = DSTG + RCANACC + SCANACC + SNOACC - STG_I

                if (OUTFIELDSFLAG == 1) then
                    call UpdateFIELDSOUT(vr, ts, ifo, &
                                         wb%pre, wb%evap, wb%rof, wb%dstg, &
                                         sp%tbar, wb%lqws, wb%frws, &
                                         wb%rcan, wb%sncan, &
                                         wb%pndw, wb%sno, wb%wsno, &
                                         eb%gflx, eb%hfs, eb%qevp, &
                                         sp%thlq, sp%thic, &
                                         IGND, &
                                         JDAY_NOW, YEAR_NOW)
                end if
                STG_I = DSTG + STG_I

!RESET ACCUMULATION VARIABLES TO ZERO
!> RESET ACCUMULATOR ARRAYS.
                PREACC = 0.0
                GTACC = 0.0
                QEVPACC = 0.0
                HFSACC = 0.0
                HMFNACC = 0.0
                ROFACC = 0.0
                SNOACC = 0.0
                CANARE = 0.0
                SNOARE = 0.0
                ROFOACC = 0.0
                ROFSACC = 0.0
                ROFBACC = 0.0
                WTBLACC = 0.0
                TBARACC = 0.0
                THLQACC = 0.0
                THICACC = 0.0
                THALACC = 0.0
                GFLXACC = 0.0
                ALVSACC = 0.0
                ALIRACC = 0.0
                RHOSACC = 0.0
                TSNOACC = 0.0
                WSNOACC = 0.0
                TCANACC = 0.0
                RCANACC = 0.0
                SCANACC = 0.0
                GROACC = 0.0
                FSINACC = 0.0
                FLINACC = 0.0
                TAACC = 0.0
                UVACC = 0.0
                PRESACC = 0.0
                QAACC = 0.0
                EVAPACC = 0.0
                FLUTACC = 0.0
                TOTAL_STORE_2 = TOTAL_STORE
                TOTAL_STORE = 0.0
                TOTAL_RCAN = 0.0
                TOTAL_SCAN = 0.0
                TOTAL_SNO = 0.0
                TOTAL_WSNO = 0.0
                TOTAL_ZPND = 0.0
                TOTAL_THLQ = 0.0
                TOTAL_THIC = 0.0
                TOTAL_PRE = 0.0
                TOTAL_EVAP = 0.0
                TOTAL_ROF = 0.0
                TOTAL_ROFO = 0.0
                TOTAL_ROFS = 0.0
                TOTAL_ROFB = 0.0
                TOTAL_HFSACC = 0.0
                TOTAL_QEVPACC = 0.0
                THIC_FLD = 0.0
                THLQ_FLD = 0.0
                DSTG = 0.0
            end if !(NCOUNT == 48) then
        end if !(ipid == 0) then

        if (ipid == 0) call run_between_grid(shd, ts, ic, cm, wb_h, eb, sp, stfl, rrls, &
                                             WF_R1, WF_R2, M_C)

!> *********************************************************************
!> Call routing routine
!> *********************************************************************

        if (ipid == 0) then

            if (JAN == 1) then
!>     this is done so that INIT_STORE is not recalculated for
!>     each iteration when wf_route is not used
                JAN = 2
            end if

!> *********************************************************************
!> Write output to console.
!> *********************************************************************

            if (NCOUNT == 48) then !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

                if (ro%VERBOSEMODE > 0) then
                    write(6, '(2i5)', advance = 'no') YEAR_NOW, JDAY_NOW
                    if (printoutstfl) then
                        do j = 1, stfl%ns
                            if (printoutqhyd) write(6, '(f10.3)', advance = 'no') stfl%qhyd(j)
                            write(6, '(f10.3)', advance = 'no') stfl%qsyn(j)
                        end do
                    end if
!todo: restore this.
!                    j = ceiling(real(NA)/2); if (WF_NUM_POINTS > 0) j = op%N_OUT(1)
                    j = shd%NAA
                    if (printoutwb) write(6, '(3(f10.3))', advance = 'no') wb%pre(j), wb%evap(j), wb%rof(j)
                    write(6, *)
                end if !(ro%VERBOSEMODE > 0) then
                if (mtsflg%AUTOCALIBRATIONFLAG > 0) then
                    call stats_update_stfl_daily(stfl%qhyd, stfl%qsyn)
                    if (mtsflg%PREEMPTIONFLAG > 1) then
                        if (FTEST > FBEST) goto 199
                    end if
                end if

                wb%pre = 0.0
                wb%evap = 0.0
                wb%rof = 0.0
                wb%rofo = 0.0
                wb%rofs =  0.0
                wb%rofb = 0.0
                wb%rcan = 0.0
                wb%sncan = 0.0
                wb%pndw = 0.0
                wb%sno = 0.0
                wb%wsno = 0.0
                wb%lqws = 0.0
                wb%frws = 0.0
                eb%hfs = 0.0
                eb%qevp = 0.0
                sp%tbar = 0.0
                sp%thlq = 0.0
                sp%thic = 0.0
                eb%gflx = 0.0
                wb%stg = 0.0

            end if !(NCOUNT == 48) then
        end if !(ipid == 0) then

5176    format(2i5, 999(f10.3))

! *********************************************************************
! Update time counters and return to beginning of main loop
! *********************************************************************
        NCOUNT = NCOUNT + 1 !todo: does this work with hourly forcing data?
        NSUM = NSUM + 1
        NSUM_TOTAL = NSUM_TOTAL + 1
        if (NCOUNT > 48) then !48 is the last half-hour period of the day
                      ! when they're numbered 1-48
            NCOUNT = 1
            NSUM = 1
        end if

        MINS_NOW = MINS_NOW + TIME_STEP_MINS ! increment the current time by 30 minutes
        if (MINS_NOW == 60) then
            MINS_NOW = 0
            HOUR_NOW = HOUR_NOW + 1
            if (HOUR_NOW == 24) then
                HOUR_NOW = 0
                JDAY_NOW = JDAY_NOW + 1
                if (JDAY_NOW >= 366) then
                    if (mod(YEAR_NOW, 400) == 0) then !LEAP YEAR
                        if (JDAY_NOW == 367) then
                            JDAY_NOW = 1
                            YEAR_NOW = YEAR_NOW + 1
                        end if
                    else if (mod(YEAR_NOW, 100) == 0) then !NOT A LEAP YEAR
                        JDAY_NOW = 1
                        YEAR_NOW = YEAR_NOW + 1
                    else if (mod(YEAR_NOW, 4) == 0) then !LEAP YEAR
                        if (JDAY_NOW == 367) then
                            JDAY_NOW = 1
                            YEAR_NOW = YEAR_NOW + 1
                        end if
                    else !NOT A LEAP YEAR
                        JDAY_NOW = 1
                        YEAR_NOW = YEAR_NOW + 1
                    end if
                end if
            end if
        end if

!> check if we should terminate the run yet
        if (YEAR_NOW >= YEAR_STOP .and. YEAR_STOP > 0) then
            if (YEAR_NOW > YEAR_STOP) then
                ENDDATE = .true.
            else if (YEAR_NOW == YEAR_STOP .and. JDAY_NOW >= JDAY_STOP) then
                if (JDAY_NOW > JDAY_STOP) then
                    ENDDATE = .true.
                else if (JDAY_NOW == JDAY_STOP .and. HOUR_NOW >= HOUR_STOP) then
                    if (HOUR_NOW > HOUR_STOP) then
                        ENDDATE = .true.
                    else if (HOUR_NOW == HOUR_STOP .and. MINS_NOW >= MINS_STOP) then
                        ENDDATE = .true.
                    end if
                end if
            end if
        end if
        TIME_STEP_NOW = TIME_STEP_NOW + TIME_STEP_MINS
        if (TIME_STEP_NOW == HOURLYFLAG) TIME_STEP_NOW = 0

        call update_now_iter_counter(ic, YEAR_NOW, JDAY_NOW, HOUR_NOW, MINS_NOW)

    !> *********************************************************************
    !> Read in meteorological forcing data
    !> *********************************************************************
        call climate_module_loaddata(shd, .false., cm, NML, il1, il2, ENDDATA)

    end do !while (.not. ENDDATE .and. .not. ENDDATA)

    !> End program if not the head node.
    if (ipid /= 0) then
!        print 4696, ipid
        goto 999

!4696 format (1x, 'Node ', i4, ' is exiting...')

    end if !(ipid /= 0) then

    call CLASSS(cp%TBARROW, cp%THLQROW, cp%THICROW, GFLXROW, TSFSROW, &
                cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, cp%TSNOROW, &
                cp%RHOSROW, cp%SNOROW, cp%TCANROW, cp%RCANROW, cp%SCANROW, &
                cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
                shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
                NA, NTYPE, NML, il1, il2, IGND, ICAN, ICAN + 1, &
                cpv%TBAR, cpv%THLQ, cpv%THIC, cdv%GFLX, cpv%TSFS, &
                cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%ALBS, cpv%TSNO, &
                cpv%RHOS, cpv%SNO, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
                cpv%GRO, cpv%CMAI, cpv%TAC, cpv%QAC, cpv%WSNO, &
                cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
                cp%SANDROW, SANDGAT, cp%CLAYROW, CLAYGAT, cp%XSLPROW, XSLPGAT, &
                DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
                TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
                DriftROW, SublROW, DepositionROW, &
                DriftGAT, SublGAT, DepositionGAT)
!>
!>   * SCATTER OPERATION ON DIAGNOSTIC VARIABLES SPLIT OUT OF
!>   * CLASSS FOR CONSISTENCY WITH GCM APPLICATIONS.
!>
    do 380 k = il1, il2
        ik = shd%lc%ILMOS(k)
        jk = shd%lc%JLMOS(k)
        CDHROW(ik, jk) = cdv%CDH(k)
        CDMROW(ik, jk) = cdv%CDM(k)
        HFSROW(ik, jk) = cdv%HFS(k)
        TFXROW(ik, jk) = cdv%TFX(k)
        QEVPROW(ik, jk) = cdv%QEVP(k)
        QFSROW(ik, jk) = cdv%QFS(k)
        QFXROW(ik, jk) = cdv%QFX(k)
        PETROW(ik, jk) = cdv%PET(k)
        GAROW(ik, jk) = cdv%GA(k)
        EFROW(ik, jk) = cdv%EF(k)
        GTROW(ik, jk) = cdv%GTE(k)
        QGROW(ik, jk) = cdv%QG(k)
        ALVSROW(ik, jk) = cdv%ALVS(k)
        ALIRROW(ik, jk) = cdv%ALIR(k)
        SFCTROW(ik, jk) = cdv%SFCT(k)
        SFCUROW(ik, jk) = cdv%SFCU(k)
        SFCVROW(ik, jk) = cdv%SFCV(k)
        SFCQROW(ik, jk) = cdv%SFCQ(k)
        FSNOROW(ik, jk) = cdv%FSNO(k)
        FSGVROW(ik, jk) = cdv%FSGV(k)
        FSGSROW(ik, jk) = cdv%FSGS(k)
        FSGGROW(ik, jk) = cdv%FSGG(k)
        FLGVROW(ik, jk) = cdv%FLGV(k)
        FLGSROW(ik, jk) = cdv%FLGS(k)
        FLGGROW(ik, jk) = cdv%FLGG(k)
        HFSCROW(ik, jk) = cdv%HFSC(k)
        HFSSROW(ik, jk) = cdv%HFSS(k)
        HFSGROW(ik, jk) = cdv%HFSG(k)
        HEVCROW(ik, jk) = cdv%HEVC(k)
        HEVSROW(ik, jk) = cdv%HEVS(k)
        HEVGROW(ik, jk) = cdv%HEVG(k)
        HMFCROW(ik, jk) = cdv%HMFC(k)
        HMFNROW(ik, jk) = cdv%HMFN(k)
        HTCCROW(ik, jk) = cdv%HTCC(k)
        HTCSROW(ik, jk) = cdv%HTCS(k)
        PCFCROW(ik, jk) = cdv%PCFC(k)
        PCLCROW(ik, jk) = cdv%PCLC(k)
        PCPNROW(ik, jk) = cdv%PCPN(k)
        PCPGROW(ik, jk) = cdv%PCPG(k)
        QFGROW(ik, jk) = cdv%QFG(k)
        QFNROW(ik, jk) = cdv%QFN(k)
        QFCLROW(ik, jk) = cdv%QFCL(k)
        QFCFROW(ik, jk) = cdv%QFCF(k)
        ROFROW(ik, jk) = cdv%ROF(k)
        ROFOROW(ik, jk) = cdv%ROFO(k)
        ROFSROW(ik, jk) = cdv%ROFS(k)
        ROFBROW(ik, jk) = cdv%ROFB(k)
        TROFROW(ik, jk) = cdv%TROF(k)
        TROOROW(ik, jk) = cdv%TROO(k)
        TROSROW(ik, jk) = cdv%TROS(k)
        TROBROW(ik, jk) = cdv%TROB(k)
        ROFCROW(ik, jk) = cdv%ROFC(k)
        ROFNROW(ik, jk) = cdv%ROFN(k)
        ROVGROW(ik, jk) = cdv%ROVG(k)
        WTRCROW(ik, jk) = cdv%WTRC(k)
        WTRSROW(ik, jk) = cdv%WTRS(k)
        WTRGROW(ik, jk) = cdv%WTRG(k)
        DRROW(ik, jk) = cdv%DR(k)
        WTABROW(ik, jk) = cdv%WTAB(k)
        ILMOROW(ik, jk) = cdv%ILMO(k)
        UEROW(ik, jk) = cdv%UE(k)
        HBLROW(ik, jk) = cdv%HBL(k)
380     continue
!>
    do 390 l = 1, IGND
        do 390 k = il1, il2
            ik = shd%lc%ILMOS(k)
            jk = shd%lc%JLMOS(k)
            HMFGROW(ik, jk, l) = cdv%HMFG(k, l)
            HTCROW(ik, jk, l) = cdv%HTC(k, l)
            QFCROW(ik, jk, l) = cdv%QFC(k, l)
390     continue
!>
    do 430 m = 1, 50
        do 420 l = 1, 6
            do 410 k = il1, il2
                ITCTROW(shd%lc%ILMOS(k), shd%lc%JLMOS(k), l, m) = ITCTGAT(k, l, m)
410     continue
420     continue
430     continue

!> *********************************************************************
!> Run is now over, print final results to the screen and close files
!> *********************************************************************

!> *********************************************************************
!> Save the state of the basin in r2c file format
!> *********************************************************************

!> Write the resume file
    if (SAVERESUMEFLAG == 2) then !todo: done: use a flag
        print *, 'Saving state variables in r2c file format'

! Allocate arrays for save_state_r2c
        open(55, file = 'save_state_r2c.txt', action = 'read')
        read(55, *, iostat = IOS) NR2C_S, DELTR2C_S
        if (IOS == 0) then
            allocate(GRD_S(NR2C_S), GAT_S(NR2C_S), GRDGAT_S(NR2C_S), R2C_ATTRIBUTES_S(NR2C_S, 3), stat = PAS)
            if (PAS /= 0) then
                print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                    'RECORD AT THE FIRST LINE IN THE save_state_r2c.txt FILE. ', &
                    'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
                stop
            end if
        end if
        close(55)

        call SAVE_STATE_R2C(shd%lc%NML, NA, NTYPE, NCOUNT, &
                            MINS_NOW, shd%lc%ACLASS, NR2C_S, GRD_S, GAT_S, GRDGAT_S, R2C_ATTRIBUTES_S, &
                            NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, ICAN, ICP1, IGND, &
                            cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
                            cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
                            cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
                            FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
                            PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
                            VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
                            HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
                            THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
                            GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, &
                            THFCGAT, PSIWGAT, cpv%DELZW, ZBTWGAT, &
                            ZSNLGAT, ZPLGGAT, ZPLSGAT, cpv%TAC, cpv%QAC, &
                            DRNGAT, XSLPGAT, XDGAT, WFSFGAT, KSGAT, &
                            ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
                            AGIDGAT, ISNDGAT, RADJGAT, cf%ZBLD, Z0ORGAT, &
                            cf%ZRFM, cf%ZRFH, ZDMGAT, ZDHGAT, cf%FSVH, &
                            cf%FSIH, CSZGAT, cf%FDL, cf%UL, cf%VL, &
                            cf%TA, cf%QA, cf%PRES, cf%PRE, PADRGAT, &
                            VPDGAT, TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, &
                            SPCPGAT, TSPCGAT, RHSIGAT, cf%FCLO, DLONGAT, &
                            GGEOGAT, &
                            cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
                            cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
                            cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
                            cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
                            cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
                            cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
                            cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
                            cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
                            cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
                            cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
                            cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                            cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
                            cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
                            SANDGAT, CLAYGAT, IGDRGAT, cf%VMOD, QLWOGAT, &
                            shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
                            shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)
    end if !(SAVERESUMEFLAG == 2) then

!> Write the resume file
!    if (SAVERESUMEFLAG == 1) then !todo: done: use a flag
!        print *, 'Saving state variables'
!        call SAVE_STATE(HOURLYFLAG, MINS_NOW, TIME_STEP_NOW, &
!                        cm%clin(cfk%FB)%filefmt, cm%clin(cfk%FI)%filefmt, &
!                        cm%clin(cfk%PR)%filefmt, cm%clin(cfk%TT)%filefmt, &
!                        cm%clin(cfk%UV)%filefmt, cm%clin(cfk%P0)%filefmt, cm%clin(cfk%HU)%filefmt, &
!                        cm%clin(cfk%FB)%GRD, FSVHGRD, FSIHGRD, cm%clin(cfk%FI)%GRD, &
!                        i, j, shd%xCount, shd%yCount, jan, &
!                        VPDGRD, TADPGRD, PADRGRD, RHOAGRD, RHSIGRD, &
!                        RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, cm%clin(cfk%TT)%GRD, &
!                        cm%clin(cfk%HU)%GRD, cm%clin(cfk%PR)%GRD, RPREGRD, SPREGRD, cm%clin(cfk%P0)%GRD, &
!!MAM - FOR FORCING DATA INTERPOLATION
!                        FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
!                        TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &
!                        IPCP, NA, NA, shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
!                        shd%lc%NML, shd%wc%NML, &
!                        cp%GCGRD, cp%FAREROW, cp%MIDROW, NTYPE, NML, NMTEST, &
!                        cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                        cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                        cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
!                        FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
!                        PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
!                        VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
!                        HGTDGAT, ACVDGAT, ACIDGAT, cpv%TSFS, cpv%WSNO, &
!                        THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
!                        GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
!                        PSIWGAT, cpv%DELZW, ZBTWGAT, ZSNLGAT, ZPLGGAT, &
!                        ZPLSGAT, cpv%TAC, cpv%QAC, DRNGAT, XSLPGAT, &
!                        XDGAT, WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, &
!                        ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ISNDGAT, &
!                        RADJGAT, cf%ZBLD, Z0ORGAT, cf%ZRFM, cf%ZRFH, &
!                        ZDMGAT, ZDHGAT, cf%FSVH, cf%FSIH, CSZGAT, &
!                        cf%FDL, cf%UL, cf%VL, cf%TA, cf%QA, cf%PRES, &
!                        cf%PRE, PADRGAT, VPDGAT, TADPGAT, RHOAGAT, &
!                        RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
!                        cf%FCLO, DLONGAT, GGEOGAT, cdv%CDH, cdv%CDM, &
!                        cdv%HFS, cdv%TFX, cdv%QEVP, cdv%QFS, cdv%QFX, &
!                        cdv%PET, cdv%GA, cdv%EF, cdv%GTE, cdv%QG, &
!                        cdv%ALVS, cdv%ALIR, cdv%SFCT, cdv%SFCU, cdv%SFCV, &
!                        cdv%SFCQ, cdv%FSNO, cdv%FSGV, cdv%FSGS, cdv%FSGG, &
!                        cdv%FLGV, cdv%FLGS, cdv%FLGG, cdv%HFSC, cdv%HFSS, &
!                        cdv%HFSG, cdv%HEVC, cdv%HEVS, cdv%HEVG, cdv%HMFC, &
!                        cdv%HMFN, cdv%HTCC, cdv%HTCS, cdv%PCFC, cdv%PCLC, &
!                        cdv%PCPN, cdv%PCPG, cdv%QFG, cdv%QFN, cdv%QFCL, &
!                        cdv%QFCF, cdv%ROF, cdv%ROFO, cdv%ROFS, cdv%ROFB, &
!                        cdv%TROF, cdv%TROO, cdv%TROS, cdv%TROB, cdv%ROFC, &
!                        cdv%ROFN, cdv%ROVG, cdv%WTRC, cdv%WTRS, cdv%WTRG, &
!                        cdv%DR, cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!                        IGND, ICAN, ICP1, &
!                        cp%TBARROW, cp%THLQROW, cp%THICROW, cp%TPNDROW, cp%ZPNDROW, &
!                        TBASROW, cp%ALBSROW, cp%TSNOROW, cp%RHOSROW, cp%SNOROW, &
!                        cp%TCANROW, cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, &
!                        cp%FCANROW, cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
!                        cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, cp%QA50ROW, &
!                        cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, cp%PSGBROW, PAIDROW, &
!                        HGTDROW, ACVDROW, ACIDROW, TSFSROW, WSNOROW, &
!                        THPROW, THRROW, THMROW, BIROW, PSISROW, &
!                        GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
!                        PSIWROW, DLZWROW, ZBTWROW, hp%ZSNLROW, hp%ZPLGROW, &
!                        hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, cp%DRNROW, cp%XSLPROW, &
!                        cp%XDROW, WFSFROW, cp%KSROW, ALGWROW, ALGDROW, &
!                        ASVDROW, ASIDROW, AGVDROW, AGIDROW, &
!                        ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
!                        cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, CSZGRD, &
!                        cm%clin(cfk%UV)%GRD, VLGRD, FCLOGRD, DLONGRD, GGEOGRD, &
!                        cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                        IGDRROW, IGDRGAT, VMODGRD, cf%VMOD, QLWOGAT, &
!                        CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
!                        WTVSTP, WTSSTP, WTGSTP, &
!                        sl%DELZ, cdv%FCS, cdv%FGS, cdv%FC, cdv%FG, N, &
!                        ALVSCN, ALIRCN, ALVSG, ALIRG, ALVSCS, &
!                        ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, &
!                        ALVSSC, ALIRSC, TRVSCN, TRIRCN, TRVSCS, &
!                        TRIRCS, FSVF, FSVFS, &
!                        RAICAN, RAICNS, SNOCAN, SNOCNS, &
!                        FRAINC, FSNOWC, FRAICS, FSNOCS, &
!                        DISP, DISPS, ZOMLNC, ZOMLCS, ZOELNC, ZOELCS, &
!                        ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
!                        CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, &
!                        CWFCAP, CWLCPS, CWFCPS, RC, RCS, RBCOEF, &
!                        FROOT, ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, &
!                        TRSNOW, ZSNOW, JDAY_NOW, JLAT, IDISP, &
!                        IZREF, IWF, IPAI, IHGT, IALC, IALS, IALG, &
!                        TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
!                        THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, &
!                        TCTOPG, TCBOTG, &
!                        GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
!                        G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
!                        QFREZC, QFREZG, QMELTC, QMELTG, &
!                        EVAPC, EVAPCG,EVAPG, EVAPCS, EVPCSG, EVAPGS, &
!                        TCANO, TCANS, TPONDC, TPONDG, TPNDCS, TPNDGS, &
!                        TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
!                        cdv%WTAB, &
!                        cdv%ILMO, cdv%UE, cdv%HBL, &
!                        shd%wc%ILG, ITC, ITCG, ITG, ISLFD, &
!                        NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
!                        cdv%GFLX, CDHROW, CDMROW, HFSROW, TFXROW, &
!                        QEVPROW, QFSROW, QFXROW, PETROW, GAROW, &
!                        EFROW, GTROW, QGROW, TSFROW, ALVSROW, &
!                        ALIRROW, SFCTROW, SFCUROW, SFCVROW, SFCQROW, &
!                        FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
!                        FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, &
!                        HEVSROW, HEVGROW, HMFCROW, HMFNROW, HTCCROW, &
!                        HTCSROW, PCFCROW, PCLCROW, PCPNROW, PCPGROW, &
!                        QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, &
!                        ROFOROW, ROFSROW, ROFBROW, TROFROW, TROOROW, &
!                        TROSROW, TROBROW, ROFCROW, ROFNROW, ROVGROW, &
!                        WTRCROW, WTRSROW, WTRGROW, DRROW, WTABROW, &
!                        ILMOROW, UEROW, HBLROW, HMFGROW, HTCROW, &
!                        QFCROW, FSNOROW, ITCTROW, NCOUNT, ireport, &
!                        wfo_seq, YEAR_NOW, ensim_MONTH, ensim_DAY, &
!                        HOUR_NOW, shd%xxx, shd%yyy, NA, &
!                        NTYPE, DELT, TFREZ, UVGRD, SBC, RHOW, CURREC, &
!                        M_C, M_S, M_R, &
!                        WF_ROUTETIMESTEP, WF_R1, WF_R2, shd%NAA, shd%iyMin, &
!                        shd%iyMax, shd%jxMin, shd%jxMax, shd%IAK, shd%IROUGH, &
!                        shd%ICHNL, shd%NEXT, shd%IREACH, shd%AL, shd%GRDN, shd%GRDE, &
!                        shd%DA, shd%BNKFLL, shd%SLOPE_CHNL, shd%ELEV, shd%FRAC, &
!                        WF_NO, WF_NL, WF_MHRD, WF_KT, WF_IY, WF_JX, &
!                        WF_QHYD, WF_RES, WF_RESSTORE, WF_NORESV_CTRL, WF_R, &
!                        WF_NORESV, WF_NREL, WF_KTR, WF_IRES, WF_JRES, WF_RESNAME, &
!                        WF_B1, WF_B2, WF_QREL, WF_QR, &
!                        WF_TIMECOUNT, WF_NHYD, WF_QBASE, WF_QI1, WF_QI2, WF_QO1, WF_QO2, &
!                        WF_STORE1, WF_STORE2, &
!                        DRIVERTIMESTEP, ROFGRD, &
!                        WF_S, &
!                        TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
!                        TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
!                        FINAL_STORE, TOTAL_AREA, TOTAL_HFSACC, TOTAL_QEVPACC, &
!                        SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS, NMELT, t0_ACC, &
!                        CO2CONC, COSZS, XDIFFUSC, CFLUXCG, CFLUXCS, &
!                        AILCG, AILCGS, FCANC, FCANCS, CO2I1CG, CO2I1CS, CO2I2CG, CO2I2CS, &
!                        SLAI, FCANCMX, ANCSVEG, ANCGVEG, RMLCSVEG, RMLCGVEG, &
!                        AILC, PAIC, FIELDSM, WILTSM, &
!                        RMATCTEM, RMATC, NOL2PFTS, ICTEMMOD, L2MAX, ICTEM, &
!                        hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
!                        fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT)
!    end if !(SAVERESUMEFLAG == 1) then

!> *********************************************************************
!> Call save_init_prog_variables_class.f90 to save initi prognostic variables by
!> by fields needd by classas as initial conditions
!> *********************************************************************

!> bjd - July 14, 2014: Gonzalo Sapriza
    if (SAVERESUMEFLAG == 3) then
!> Save the last time step
        call save_init_prog_variables_class(CMAIROW, QACROW, TACROW, &
                                            TBASROW, TSFSROW, WSNOROW, &
                                            cp%ALBSROW, cp%GROROW, cp%RCANROW, &
                                            cp%RHOSROW, cp%SCANROW, cp%SNOROW, &
                                            cp%TBARROW, cp%TCANROW, cp%THICROW, &
                                            cp%THLQROW, cp%TPNDROW, cp%TSNOROW, &
                                            cp%ZPNDROW, &
                                            NA, NTYPE, IGND, &
                                            fls)
    end if !(SAVERESUMEFLAG == 3) then

    if (OUTFIELDSFLAG == 1) call write_outputs(shd, fls, ts, ic, ifo, vr)

    if (ENDDATA) print *, 'Reached end of forcing data'
    if (ENDDATE) print *, 'Reached end of simulation date'

!> Calculate final storage
    FINAL_STORE = 0.0
    do k = il1, il2
        if (shd%FRAC(shd%lc%ILMOS(k)) >= 0.0) then
            FINAL_STORE = FINAL_STORE + FAREGAT(k)*(cpv%RCAN(k) + cpv%SNCAN(k) + cpv%SNO(k) + cpv%WSNO(k) + cpv%ZPND(k)*RHOW)
            do j = 1, IGND
                FINAL_STORE = FINAL_STORE + FAREGAT(k)*(cpv%THLQ(k, j)*RHOW + cpv%THIC(k, j)*RHOICE)*cpv%DELZW(k, j)
            end do
        end if
    end do

    !> write out final totals to screen
    if (ro%VERBOSEMODE > 0) then

        print *
        print 5641, 'Total Precipitation         (mm) =', TOTAL_PREACC/TOTAL_AREA
        print 5641, 'Total Evaporation           (mm) =', TOTAL_EVAPACC/TOTAL_AREA
        print 5641, 'Total Runoff                (mm) =', TOTAL_ROFACC/TOTAL_AREA
        print 5641, 'Storage (Change/Init/Final) (mm) =', (FINAL_STORE - INIT_STORE)/TOTAL_AREA, INIT_STORE/TOTAL_AREA, &
            FINAL_STORE/TOTAL_AREA
        print *
        print 5641, 'Total Overland flow         (mm) =', TOTAL_ROFOACC/TOTAL_AREA
        print 5641, 'Total Interflow             (mm) =', TOTAL_ROFSACC/TOTAL_AREA
        print 5641, 'Total Baseflow              (mm) =', TOTAL_ROFBACC/TOTAL_AREA
        print *

5641    format(3x, a34, 999(f11.3))
5635    format(1x, 'Program has terminated normally.'/)

    end if !(ro%VERBOSEMODE > 0) then

    print 5635

    !> Write final totals to output file.
    if (MODELINFOOUTFLAG > 0) then

        write(58, *)
        write(58, '(a, f11.3)') '  Total Precipitation         (mm) = ', TOTAL_PREACC/TOTAL_AREA
        write(58, '(a, f11.3)') '  Total Evaporation           (mm) = ', TOTAL_EVAPACC/TOTAL_AREA
        write(58, '(a, f11.3)') '  Total Runoff                (mm) = ', TOTAL_ROFACC/TOTAL_AREA
        write(58, '(a, 3f11.3)') '  Storage(Change/Init/Final)  (mm) = ', &
            (FINAL_STORE - INIT_STORE)/TOTAL_AREA, &
            INIT_STORE/TOTAL_AREA, &
            FINAL_STORE/TOTAL_AREA
        write(58, '(a, f11.3)') '  Total Overland flow         (mm) = ', TOTAL_ROFOACC/TOTAL_AREA
        write(58, '(a, f11.3)') '  Total Interflow             (mm) = ', TOTAL_ROFSACC/TOTAL_AREA
        write(58, '(a, f11.3)') '  Total Baseflow              (mm) = ', TOTAL_ROFBACC/TOTAL_AREA
        write(58, *)
        write(58, *)
        write(58, '(a)') 'Program has terminated normally.'
        write(58, *)

        call cpu_time(endprog)
        write(58, "('Time = ', e14.6, ' seconds.')") (endprog - startprog)

    end if !(MODELINFOOUTFLAG > 0) then

199 continue

    if (mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_write()

999 continue

    !> Close model output file.
    close(58)

    !> Close the SWE CSV files.
    close(85)
    close(86)

    !> Close the CSV energy and water balance output files.
    close(fls%fl(mfk%f900)%iun)
    close(901)
    close(902)

9000    format(/1x, 'INTERPOLATIONFLAG IS NOT SPECIFIED CORRECTLY AND IS SET TO 0 BY THE MODEL.', &
               /1x, '0: NO INTERPOLATION OF FORCING DATA.', &
               /1x, '1: LINEARLY INTERPOLATES FORCING DATA FOR INTERMEDIATE TIME STEPS.', &
               /1x, 'NOTE: INTERPOLATIONFLAG SHOULD BE SET TO 0 FOR 30 MINUTE FORCING DATA.', /)

9002    format(/1x, 'ERROR IN READING r2c_output.txt FILE.', &
               /1x, 'THE FIRST RECORD AT THE FIRST LINE IS FOR THE NUMBER OF ALL THE', &
               /1x, 'VARIABLES LISTED IN THE r2c_output.txt FILE.',&
               /1x, 'THE SECOND RECORD AT THE FIRST LINE IS TIME STEP FOR R2C OUTPUT.', &
               /1x, 'IT SHOULD BE AN INTEGER MULTIPLE OF 30.',&
               /1x, 'THE REMAINING RECORDS SHOULD CONTAIN 3 COLUMNS FOR EACH VARIABLE WITH', &
               /1x, 'INTEGER VALUES OF EITHER 0 OR 1,', &
               /1x, 'AND 3 COLUMNS CONTAINING INFORMATION ABOUT THE VARIABLES.', /)

    call mpi_finalize(ierr)

    stop

end program
