PROGRAM RUNMESH

!>       MESH DRIVER
!>
!>       JAN 2013 - K.C.KORNELSEN
!>                - INCORPORATED LOCATION FLAG FOR INCREASING PRECISION
!>                - OF STREAMFLOW AND RESERVOIR INPUTS
!>                - INCLUDED NSE AND NEGATIVE NSE AS OBJFN'S
!>       JAN 2014 - M. MACDONALD.  INCORPORATED BLOWING SNOW ALGORITHMS
!>       AUG 2013 - M. MACDONALD
!>                - INCORPORATE OPTIONAL COUPLING OF CLASS WITH CTEM
!>                - MOVE SOME INITIALIZATION AND SCATTER OF CLASS
!>                  DIAGNOSTIC VARIABLES IN TO MESH_DRIVER
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.

USE AREA_WATFLOOD

    use sa_mesh_shared_variabletypes
    use sa_mesh_shared_variables

USE EF_MODULE
USE MESH_INPUT_MODULE
USE FLAGS

    use module_mpi_flags
    use module_mpi

USE MODEL_OUTPUT
USE climate_forcing
USE model_dates
    use SIMSTATS_config
    use SIMSTATS
use model_files_variables
use model_files
use strings

IMPLICIT NONE
INTRINSIC MAXLOC

    !> ierr: For status return from MPI
    !> istop: To stop all MPI process
    !* inp: Number of active tasks.
    !* ipid: Current process ID.
    integer :: ierr = 0, inp = 1, ipid = 0
    integer ipid_recv, itag, izero, ierrcode, istop
    logical lstat

    integer iun, u, invars

    !+ For split-vector approach
    integer il1, il2, ilen
    integer i1, i2

    integer, dimension(:), allocatable :: irqst
    integer, dimension(:, :), allocatable :: imstat

    type CLASSOUT_VARS
        real, dimension(:), allocatable :: &
            PREACC, GTACC, QEVPACC, EVAPACC, HFSACC, HMFNACC, &
            ROFACC, ROFOACC, ROFSACC, ROFBACC, WTBLACC, ALVSACC, ALIRACC, &
            RHOSACC, TSNOACC, WSNOACC, SNOARE, TCANACC, CANARE, SNOACC, &
            RCANACC, SCANACC, GROACC, FSINACC, FLINACC, FLUTACC, &
            TAACC, UVACC, PRESACC, QAACC
        real, dimension(:, :), allocatable :: &
            TBARACC, THLQACC, THICACC, THALACC, GFLXACC
    end type !CLASSOUT_VARS

!> DAN  USE RTE SUBROUTINES FOR READING EVENT FILE AND SHD FILE, AND
!> DAN  WRITING R2C-FORMAT OUTPUT FILES      
!>  INTEGER CONSTANTS.
INTEGER ILG
!INTEGER,PARAMETER :: ICAN=4, IGND=6, ICP1=ICAN+1
INTEGER,PARAMETER :: ICAN=4, ICP1=ICAN+1,ICTEM=1 !Number of CTEM vegetation categories (set to 1 if not using CTEM)
INTEGER :: M_S, M_R
INTEGER,PARAMETER :: M_C=5
!INTEGER,PARAMETER :: M_S=290, M_R=7, M_C=5
!M_S and M_R are now read in and used to allocate the appropriate arrays - Frank S Jul 2013
!todo it should be read in from the shd file
!todo M_S could be removed as it is now just a surrogate of WF_NO (KCK)

INTEGER IGND
REAL IGND_TEST, IGND_DEEP

!> WATERSHED RELATED VARIABLES
INTEGER LATDEGMIN,LATMINMIN,LATDEGMAX,LATMINMAX,LONDEGMIN, &
     LONMINMIN,LONDEGMAX,LONMINMAX
INTEGER WF_IYMAX,WF_JXMAX
!> note, there are more watershed related variables declared in mesh_input_module.f

REAL*8 :: LATLENGTH, LONGLENGTH
REAL*8 WF_AL
REAL WF_LAND_MAX, WF_LAND_SUM
INTEGER WF_LAND_COUNT

!> IOSTAT VARIABLE
INTEGER IOS, IOS_EVT

!> FOR OUTPUT
CHARACTER*450 GENDIR_OUT

    !> For R2C-format out
    integer EF_YEAR_NOW, EF_MONTH_NOW, EF_DAY_NOW, EF_HOUR_NOW

!todo clean up commets and arrange variables a bit better

!> SCA variables

!todo clean up comments and make sure the variables
!todo are in groups that make sense
REAL basin_SCA
REAL basin_SWE
!> STREAMFLOW VARIABLES
!* WF_GAGE: GAUGE IDENTIFIER (8 CHARACTER STRING)
!* WF_NO: NUMBER OF STREAMFLOW GAUGES
!* WF_NL: NUMBER OF DATA POINTS
!* WF_MHRD: NUMBER OF HOURS OF DATA PER MONTH
!* WF_KT: HOURLY INCREMENT FOR STREAMFLOW INPUT (24 = DAILY)
!* WF_IY: Y-DIRECTION GAUGE CO-ORDINATE (UTM OR LATLONG)
!* WF_JX: X-DIRECTION GAUGE CO-ORDINATE (UTM OR LATLONG)
!* WF_S: GAUGE'S PARENT GRID SQUARE
!* WF_QHYD: STREAMFLOW VALUE (_AVG = DAILY AVERAGE)
!* WF_QSYN: SIMULATED STREAFLOW VALUE (_AVG = DAILY AVERAGE)
!* WF_START_YEAR OBSERVED STREAMFLOW START YEAR
!* WF_START_DAY OBSERVED STREAMFLOW START DAY
!* WF_START_HOUR OBSERVED STREAMFLOW START HOUR
INTEGER WF_NO, WF_NL, WF_MHRD, WF_KT, WF_START_YEAR, &
        WF_START_DAY,WF_START_HOUR
INTEGER, ALLOCATABLE :: WF_IY(:),WF_JX(:), WF_S(:)
REAL, ALLOCATABLE :: WF_QHYD(:),WF_QHYD_AVG(:),WF_QHYD_CUM(:)
REAL, ALLOCATABLE :: WF_QSYN(:),WF_QSYN_AVG(:),WF_QSYN_CUM(:)
CHARACTER, ALLOCATABLE :: WF_GAGE(:)*8

!> RESERVOIR VARIABLES
    INTEGER, ALLOCATABLE ::  WF_IRES(:), WF_JRES(:), WF_RES(:), WF_R(:)
    REAL, ALLOCATABLE ::  WF_B1(:),WF_B2(:),WF_QREL(:), WF_RESSTORE(:)
    CHARACTER, ALLOCATABLE ::  WF_RESNAME(:)*8

!> FOR BASEFLOW INITIALIZATION
INTEGER JAN
    integer imonth_now, imonth_old

!>     FOR ROUTING
!* WF_R1: MANNING'S N FOR RIVER CHANNEL
!* WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
!* WF_QO2: SIMULATED STREAMFLOW VALUE
REAL WF_R1(M_C), WF_R2(M_C)
REAL, DIMENSION(:), ALLOCATABLE :: WF_NHYD, WF_QBASE, WF_QI2, &
  WF_QO1, WF_QO2, WF_QR, WF_STORE1, WF_STORE2, WF_QI1

! Saul=======
!* HOURLY_START_*: Start day/year for recording hourly averaged data
!* HOURLY_STOP_*: Stop day/year for recording hourly averaged data
!* DAILY_START_*: Start day/year for recording daily averaged data
!* DAILY_STOP_*: Stop day/year for recording daily averaged data
INTEGER HOURLY_START_DAY, HOURLY_STOP_DAY, DAILY_START_DAY, &
           DAILY_STOP_DAY
INTEGER HOURLY_START_YEAR, HOURLY_STOP_YEAR, DAILY_START_YEAR, &
           DAILY_STOP_YEAR
INTEGER JDAY_IND_STRM,JDAY_IND1,JDAY_IND2,JDAY_IND3
!*******************************************************************************


!> LAND SURFACE DIAGNOSTIC VARIABLES.

REAL, DIMENSION(:), ALLOCATABLE :: SNOGRD

!>==========
!>
!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
CHARACTER*10 wf_landclassname(10)
INTEGER*4 wfo_yy,wfo_mm,wfo_dd,wfo_hh,wfo_mi,wfo_ss, &
                   wfo_ms,nj, ensim_month, ensim_day
INTEGER*4 WFO_SEQ, ENSIM_IOS
INTEGER*4 CURREC
!> End of ENSIM Changes 
!>== ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

!>  CONSTANTS AND TEMPORARY VARIABLES.
REAL DEGLAT,DEGLON,FSDOWN1,FSDOWN2,FSDOWN3,RDAY, &
     DECL,HOUR,COSZ, &
     ALTOT,FSSTAR,FLSTAR,QH,QE,BEG,SNOMLT,ZSN,TCN,TSN,TPN,GTOUT
INTEGER JLAT

!> *************************************************************
!> For reading in options information from MESH_run_options.ini
!> *************************************************************
CHARACTER(20) :: IRONAME
INTEGER       :: IROVAL

!> *******************************************************************
!> For reading in the last information in mesh_paramters_hydrology.ini
!> *******************************************************************
CHARACTER(30) :: NMTESTFORMAT

!>=======================================================================
!>     * DIMENSION STATEMENTS

!> FIRST SET OF DEFINITIONS:

!> BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!> VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!> THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!> MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!> "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!> A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!> ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!> GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!> DIAGNOSTIC VARIABLES.

!> THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!> REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!> LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!> NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!> SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!> ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!> NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!> VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!> DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!> THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!> "ROW" VARIABLES.

!>     * CONSTANTS (PARAMETER DEFINITIONS):

!* NA: MAXIMUM ALLOWABLE NUMBER OF GRID SQUARES
!* NTYPE: MAXIMUM ALLOWABLE NUMBER OF GRUS
!* ILG: MAXIMUM ALLOWABLE SINGLE-DIMENSION ARRAY LENGTH
!* ICAN: MAXIMUM ALLOWABLE NUMBER OF LAND COVER TYPES
!* ICP1: MAXIMUM ALLOWABLE NUMBER OF LAND COVER TYPES INCLUDING
!*       URBAN AREAS
!* IGND: MAXIMUM ALLOWABLE NUMBER OF SOIL LAYERS
!* M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
!* M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
!* M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
!* M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
!* M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
!* M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS

!> DAN  * VERSION: MESH_DRIVER VERSION
!> DAN  * RELEASE: PROGRAM RELEASE VERSIONS
!> ANDY * VER_OK: IF INPUT FILES ARE CORRECT VERSION FOR PROGRAM
!> ANDY *    INTEGER, PARAMETER :: M_G = 5
CHARACTER :: VERSION*24 = "TRUNK (872)"
!+CHARACTER :: VERSION*24 = "TAG"
CHARACTER*8 :: RELEASE(10)
LOGICAL :: VER_OK
!>
!>*******************************************************************
!>
!> OPERATIONAL VARIABLES:

!* IOS: IOSTAT (ERROR) RETURN ON READ EXTERNAL FILE
!* IY: Y-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* JX: X-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* NN: GRID SQUARE, USED TO READ DRAINAGE DATABASE
!* II: GRU, USED TO READ DRAINAGE DATABASE
!* JAN: IS USED TO INITIALISE BASEFLOW (WHEN JAN = 1)
!* N: COUNTER USED BY CLASS
!* NCOUNT: HALF-HOURLY BASED TIME STEP (200 LOOP)
!* NSUM: NUMBER OF ITERATIONS, TIME STEPS PASSED (200 LOOP)
!* NSUM_TOTAL: total number of iterations
!* I: COUNTER
!* J: COUNTER
!* K: COUNTER
!* L: COUNTER
!* M: COUNTER
!* CONFLAGS: NUMBER OF CONTROL FLAGS
!* OPTFLAGS: NUMBER OF OPTFLAGS
!* INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
!* DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
!* PAS: STAT (ERROR) RETURN ON ALLOCATE VARIABLE
!* OPN: OPENED RETURN ON INQUIRE STATEMENT (USED TO CHECK IF AN
!*      EXTERNAL FILE HAS BEEN OPENED BY THE PROGRAM)
!* FILE_VER: FILE VERSION USED TO SEEK INPUT FILE COMPATIBILITY
!*           (COMPARED TO "RELEASE")
CHARACTER :: FILE_VER*8
INTEGER ::  N, NCOUNT, NSUM, I, J, K, L, M, &
            INDEPPAR, DEPPAR, PAS, NSUM_TOTAL
!  CONFLAGS, OPTFLAGS, INDEPPAR, DEPPAR, PAS
LOGICAL :: OPN
!>
!>*******************************************************************
!>
!>  BASIN INFORMATION AND COUNTS:
!* WF_NA: NUMBER OF GRID SQUARES
!* NAA: NUMBER OF GRID OUTLETS
!* WF_NTYPE: NUMBER OF GRUS
!* NRVR: NUMBER OF RIVER CLASSES
!* WF_IMAX: NUMBER OF GRID COLUMNS IN BASIN
!* WF_JMAX: NUMBER OF GRID ROWNS IN BASIN
!* AL: SINGLE-DIMENSION GRID SQUARE LENGTH
!* LAT/LONG, SITE LOCATION INFORMATION:
!* IYMIN: MINIMUM Y-DIRECTION GRID CO-ORDINATE (UTM)
!* WF_IYMAX: MAXIMUM Y-DIRECTION GRID CO-ORDINATE (UTM)
!* JXMIN: MINIMUM X-DIRECTION GRID CO-ORDINATE (UTM)
!* WF_JXMAX: MAXIMUM X-DIRECTION GRID CO-ORDINATE (UTM)
!* GRDN: GRID NORTHING
!* GRDE: GRID EASTING
!* LATLENGTH: SINGLE SIDE LENGTH OF GRID SQUARE IN DEGREES
!*            LATITUDE
!* LONGLENGTH: SINGLE SIDE LENGTH OF GRID SQUARE IN DEGREES
!*             LONGITUDE
!>************************************************************
!>
!> RESERVOIR MEASUREMENTS:
!* WF_RESNAME: RESERVOIR IDENTIFIER (8 CHARACTER STRING)
!* WF_NORESV: NUMBER OF RESERVOIRS
!* WR_NREL: NUMBER OF DATA POINTS
!* WF_KTR: HOURLY INCREMENT FOR RESERVOIR INPUR (24 = DAILY)
!* WF_IRES: Y-DIRECTION GAUGE CO-ORDINATE
!* WF_JRES: X-DIRECTION GAUGE CO-ORDINATE
!* WF_R: RESERVOIR'S PARENT GRID SQUARE
!* WF_QREL: RESERVOIR VALUE

INTEGER :: WF_NORESV, WF_NREL, WF_KTR, WF_NORESV_CTRL
INTEGER :: WF_ROUTETIMESTEP, WF_TIMECOUNT, DRIVERTIMESTEP
!>
REAL :: I_G, J_G
!* I_G: REAL TEMPORARY IY COORDINATE FOR STREAM AND RESERVOIR GAUGES
!* J_G: REAL TEMPORARY JX COORDINATE FOR STREAM AND RESERVOIR GAUGES
!>*******************************************************************
!>
!* FRAME_NO: FRAME NUMBER BEING WRITTEN TO R2C-FORMAT FILE
!* NO_FRAMES: TOTAL NUMBER OF FRAMES IN R2C-FORMAT FILE (TOTAL
!*            NUMBER OF FRAMES IS NEVER KNOWN, IS ALWAYS SET TO
!*            FRAME_NO + 1)
INTEGER :: FRAME_NO, NO_FRAMES, FRAME_NO_NEW
!* RUNOFF: HOURLY SIMULATED RUNOFF
!* RECHARGE: HOURLY SIMULATED RECHARGE
!* LEAKAGES: UNKNOWN, BUT MAY BE USED IN THE FUTURE 
REAL*4, DIMENSION(:, :), ALLOCATABLE :: RUNOFF, RECHARGE, LEAKAGES
!* LEAKAGE: UNKNOWN, BUT MAY BE USED IN THE FUTURE

!> GRID OUTPUT POINTS
!* BNAM: TEMPORARY HOLD FOR OUTPUT DIRECTORY (12 CHARACTER STRING)
CHARACTER :: BNAM*12
!* WF_NUM_POINTS: NUMBER OF GRID OUTPUTS
!* I_OUT: OUTPUT GRID SQUARE TEMPORARY STORE
INTEGER :: WF_NUM_POINTS, I_OUT
!>
!>*******************************************************************
!>
!>*******************************************************************
!>
!> LIMITING TIME STEPS (CLASS.INI):
!> DAN  NOT USED RIGHT NOW.  CONSIDER USING THEM TO LIMIT RUN INSTEAD
!> DAN  OF END OF FORCING.BIN FILE (IS ESPECIALLY USEFUL WHEN DEBUGGING).
!* JOUT1: DAILY-AVERAGED OUTPUT START DAY (JULIAN FROM YEAR START)
!* JOUT2: DAILY-AVERAGED OUTPUT STOP DAY (JULIAN FROM YEAR START)
!* JAV1: DAILY-AVERAGED OUTPUT START YEAR
!* JAV2: DAILY-AVERAGED OUTPUT STOP YEAR
!* KOUT1: YEARLY-AVERAGED OUTPUT START DAY (JULIAN FROM YEAR START)
!* KOUT2: YEARLY-AVERAGED OUTPUT STOP DAY (JULIAN FROM YEAR START)
!* KAV1: YEARLY-AVERAGED OUTPUT START YEAR
!* KAV2: YEARLY-AVERAGED OUTPUT STOP YEAR
INTEGER :: JOUT1, JOUT2, JAV1, JAV2, KOUT1, KOUT2, KAV1, KAV2
!>
!>*******************************************************************
!>
!> CLASS CONTROL FLAGS:
!> DAN  CONSIDER INCLUDING AS CONTROL FLAGS IN RUN_OPTIONS.INI FILE SO
!> DAN  THAT THEY ARE NO LONGER HARD-CODED.
!* ALL: DESCRIPTIONS ARE WRITTEN WHERE RUN_OPTIONS.INI IS READ
INTEGER :: IDISP, IZREF, ISLFD, IPCP, IWF, IPAI, IHGT, IALC, &
  IALS, IALG, ITG, ITC, ITCG

!> GRID SQUARE COUNTS:
!* NLTEST: NUMBER OF GRID SQUARES (CLASS.INI)
!* NMTEST: NUMBER OF GRUS (CLASS.INI)
!* IHOUR: CURRENT HOUR OF MET. FORCING DATA (0 TO 23) (CLASS.INI)
!* IMIN: CURRENT MINUTE OF MET. FORCING DATA (0 OR 30) (CLASS.INI)
!* IDAY: CURRENT DAY OF MET. FORCING DATA (JULIAN FROM YEAR START)
!*       (CLASS.INI)
!* IYEAR: CURRENT YEAR OF MET. FORCING DATA (CLASS.INI)
!* NML: NUMBER OF LAND-ORIENTED GRID SQUARES
!* NMW: NUMBER OF WATER-ORIENTED GRID SQUARES
INTEGER :: ILW, NLTEST, NMTEST, NML, &
  NMW, NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI

!> LAND SURFACE PROGNOSTIC VARIABLES (CLASS.INI):
!* TBAR: INITIAL SOIL LAYER TEMPERATURE
!* THLQ: INITIAL SOIL LAYER LIQUID WATER CONTENT
!* THIC: INITIAL SOIL LAYER ICE WATER CONTENT
REAL, DIMENSION(:, :), ALLOCATABLE :: TBARGAT, THLQGAT, THICGAT, &
                                      SANDGAT, CLAYGAT
REAL, DIMENSION(:, :), ALLOCATABLE ::  TBASROW, &
  CMAIROW, TACROW, QACROW, WSNOROW
     
!>PBSM VARIABLES (GRU)
!* DrySnow: 0=air temperature above 0 degC
!*          1=air temperature below 0 degC
!* SnowAge: hours since last snowfall
!* Drift: blowing snow transport (kg/m^2)
!* Subl: blowing snow sublimation (kg/m^2)
REAL, DIMENSION(:), ALLOCATABLE :: DrySnowGAT, SnowAgeGAT, &
  TSNOdsGAT, RHOSdsGAT, DriftGAT, SublGAT, DepositionGAT
REAL, DIMENSION(:, :), ALLOCATABLE :: DrySnowROW, SnowAgeROW, &
  TSNOdsROW, RHOSdsROW, DriftROW, SublROW, DepositionROW
!>CLASS SUBAREA VARIABLES NEEDED FOR PBSM
REAL, DIMENSION(:), ALLOCATABLE :: ZSNOCS,ZSNOGS,ZSNOWC,ZSNOWG, &
  HCPSCS,HCPSGS,HCPSC,HCPSG,TSNOWC,TSNOWG, &
  RHOSC,RHOSG,XSNOWC,XSNOWG,XSNOCS,XSNOGS
!* TPND: INITIAL PONDING TEMPERATURE (CLASS.INI)
!* ZPND: INITIAL PONDING DEPTH (CLASS.INI)
!* ALBS: ALBEDO OF SNOWPACK (CLASS.INI)
!* TSNO: INITIAL SNOWPACK TEMPERATURE (CLASS.INI)
!* RHOS: DENSITY OF SNOWPACK (CLASS.INI)
!* SNO: SNOWPACK ON CANOPY LAYER (CLASS.INI)
!* TCAN: INITIAL CANOPY TEMPERATURE (CLASS.INI)
!* GRO: VEGETATION GROWTH INDEX (CLASS.INI)
REAL, DIMENSION(:), ALLOCATABLE :: TPNDGAT, ZPNDGAT, TBASGAT, &
  ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, TCANGAT, RCANGAT, SCANGAT, &
  GROGAT, FRZCGAT, CMAIGAT, TACGAT, QACGAT, WSNOGAT
     
REAL, DIMENSION(:, :, :), ALLOCATABLE :: TSFSROW
REAL, DIMENSION(:, :), ALLOCATABLE :: TSFSGAT

!> GATHER-SCATTER COUNTS:
INTEGER, DIMENSION(:), ALLOCATABLE :: ILMOS, JLMOS, IWMOS, JWMOS
!>
!>*******************************************************************
!>
!> CANOPY AND SOIL INFORMATION (CLASS):
!> THE LENGTH OF THESE ARRAYS IS DETERMINED BY THE NUMBER
!> OF SOIL LAYERS (3) AND THE NUMBER OF BROAD VEGETATION
!> CATEGORIES (4, OR 5 INCLUDING URBAN AREAS).
!* ALL: DEFINITIONS IN CLASS DOCUMENTATION (CLASS.INI)
REAL, DIMENSION(:, :), ALLOCATABLE :: FCANGAT, LNZ0GAT, &
  ALVCGAT, ALICGAT
 REAL, DIMENSION(:, :, :), ALLOCATABLE :: &
 PAIDROW, HGTDROW, ACVDROW, ACIDROW
REAL, DIMENSION(:, :), ALLOCATABLE :: PAMXGAT, PAMNGAT, &
  CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, VPDAGAT, VPDBGAT, PSGAGAT, &
  PSGBGAT, PAIDGAT, HGTDGAT, ACVDGAT, ACIDGAT
REAL, DIMENSION(:, :, :), ALLOCATABLE :: THPROW, THRROW, THMROW, &
  BIROW, PSISROW, GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
  PSIWROW, DLZWROW, ZBTWROW
REAL, DIMENSION(:, :), ALLOCATABLE :: THPGAT, THRGAT, THMGAT, &
  BIGAT, PSISGAT, GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
  PSIWGAT, DLZWGAT, ZBTWGAT, GFLXGAT
REAL, DIMENSION(:, :), ALLOCATABLE :: &
  WFSFROW, ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
  AGIDROW
REAL, DIMENSION(:), ALLOCATABLE :: DRNGAT, XSLPGAT, XDGAT, &
  WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, ASVDGAT, ASIDGAT, AGVDGAT, &
  AGIDGAT, ZSNLGAT, ZPLGGAT, ZPLSGAT, SDEPGAT, FAREGAT
!* PBSM parameters
!  fetch: fetch distance (m)
!  Ht: vegetation height (m)
!  N_S:vegetation density (number/m^2)
!  A_S: vegetation width (m)
!  Distrib: Inter-GRU snow redistribution factor
REAL, DIMENSION(:), ALLOCATABLE :: &
  fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT

!* SAND: PERCENT-CONTENT OF SAND IN SOIL LAYER (CLASS.INI)
!* CLAY: PERCENT-CONTENT OF CLAY IN SOIL LAYER (CLASS.INI)
!* ORGM: PERCENT-CONTENT OF ORGANIC MATTER IN SOIL LAYER (CLASS.INI)

!* MIDROW: DEFINITION IN CLASS DOCUMENTATION (CLASS.INI)

INTEGER, DIMENSION(:, :, :), ALLOCATABLE :: ISNDROW, IORG
INTEGER, DIMENSION(:, :), ALLOCATABLE :: ISNDGAT
INTEGER, DIMENSION(:,:), ALLOCATABLE :: IGDRROW
INTEGER, DIMENSION(:), ALLOCATABLE :: IGDRGAT
!>
!>*******************************************************************
!>
!> WATROF FLAGS AND VARIABLES:
!* VICEFLG: VERTICAL ICE FLAG OR LIMIT
!* HICEFLG: HORIZONTAL ICE FLAG OR LIMIT
INTEGER :: LZFFLG, EXTFLG, IWFICE, ERRFLG, IWFOFLW
REAL :: VICEFLG, PSI_LIMIT, HICEFLG
!* DD (DDEN): DRAINAGE DENSITY (CLASS.INI)
!* MANN (WFSF): MANNING'S n (CLASS.INI)
REAL, DIMENSION(:), ALLOCATABLE :: DDGAT, MANNGAT
REAL, DIMENSION(:, :), ALLOCATABLE :: BTC, BCAP, DCOEFF, BFCAP, &
  BFCOEFF, BFMIN, BQMAX


!> CONTROL FLAGS
!* ALL: DEFINITIONS ARE WRITTEN JUST BEFORE RUN_OPTIONS.INI IS
!*      OPENED
!* RELFLG: RELEASE-MATCH STRICTNESS
!INTEGER :: RELFLG
!>
!>*******************************************************************
!>
!> ATMOSPHERIC AND GRID-CONSTANT INPUT VARIABLES:
REAL, DIMENSION(:), ALLOCATABLE :: ZDMGRD, &
  ZDHGRD, RADJGRD, CSZGRD, &
  PADRGRD, VPDGRD, &
  TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, RHSIGRD, &
  FCLOGRD, DLONGRD, Z0ORGRD, GGEOGRD, UVGRD, XDIFFUS, &
  RPREGRD, SPREGRD, VMODGRD

!> MAM - logical variables to control simulation runs:
LOGICAL ENDDATE, ENDDATA

REAL, DIMENSION(:), ALLOCATABLE :: ZRFMGAT, ZRFHGAT, ZDMGAT, &
  ZDHGAT, ZBLDGAT, RADJGAT, CSZGAT, &
  RPREGAT, SPREGAT, &
  PADRGAT, VPDGAT, TADPGAT, RHOAGAT, RPCPGAT, TRPCGAT, SPCPGAT, &
  TSPCGAT, RHSIGAT, FCLOGAT, DLONGAT, Z0ORGAT, GGEOGAT, VMODGAT
!>
!>*******************************************************************
!>
!> LAND SURFACE DIAGNOSTIC VARIABLES:
REAL, DIMENSION(:, :), ALLOCATABLE :: CDHROW, CDMROW, HFSROW, &
  TFXROW, QEVPROW, QFSROW, QFXROW, PETROW, GAROW, EFROW, GTROW, &
  QGROW, TSFROW, ALVSROW, ALIRROW, FSNOROW, SFCTROW, SFCUROW, &
  SFCVROW, SFCQROW, FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
  FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, HEVSROW, HEVGROW, &
  HMFCROW, HMFNROW, HTCCROW, HTCSROW, PCFCROW, PCLCROW, PCPNROW, &
  PCPGROW, QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, ROFOROW, &
  ROFSROW, ROFBROW, ROFCROW, ROFNROW, ROVGROW, WTRCROW, WTRSROW, &
  WTRGROW, DRROW, WTABROW, ILMOROW, UEROW, HBLROW, TROFROW, &
  TROOROW, TROSROW, TROBROW
REAL, DIMENSION(:), ALLOCATABLE :: CDHGAT, CDMGAT, HFSGAT, &
  TFXGAT, QEVPGAT, QFSGAT, QFXGAT, PETGAT, GAGAT, EFGAT, GTGAT, &
  QGGAT, ALVSGAT, ALIRGAT, FSNOGAT, SFRHGAT,SFCTGAT, SFCUGAT, &
  SFCVGAT, SFCQGAT, FSGVGAT, FSGSGAT, FSGGGAT, FLGVGAT, FLGSGAT, &
  FLGGGAT, HFSCGAT, HFSSGAT, HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, &
  HMFCGAT, HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, PCPNGAT, &
  PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, QFCFGAT, ROFGAT, ROFOGAT, &
  ROFSGAT, ROFBGAT, ROFCGAT, ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, &
  WTRGGAT, DRGAT, WTABGAT, ILMOGAT, UEGAT, HBLGAT,QLWOGAT,FTEMP, &
  FVAP,RIB,TROFGAT,TROOGAT, TROSGAT, TROBGAT
REAL, DIMENSION(:), ALLOCATABLE :: CDHGRD, CDMGRD, HFSGRD, &
  TFXGRD, QEVPGRD, QFSGRD, QFXGRD, PETGRD, GAGRD, EFGRD, GTGRD, &
  QGGRD, TSFGRD, ALVSGRD, ALIRGRD, FSNOGRD, SFCTGRD, SFCUGRD, &
  SFCVGRD, SFCQGRD, FSGVGRD, FSGSGRD, FSGGGRD, FLGVGRD, FLGSGRD, &
  FLGGGRD, HFSCGRD, HFSSGRD, HFSGGRD, HEVCGRD, HEVSGRD, HEVGGRD, &
  HMFCGRD, HMFNGRD, HTCCGRD, HTCSGRD, PCFCGRD, PCLCGRD, PCPNGRD, &
  PCPGGRD, QFGGRD, QFNGRD, QFCLGRD, QFCFGRD, ROFGRD, ROFOGRD, &
  ROFSGRD, ROFBGRD, ROFCGRD, ROFNGRD, ROVGGRD, WTRCGRD, WTRSGRD, &
  WTRGGRD, DRGRD, WTABGRD, ILMOGRD, UEGRD, HBLGRD

REAL, DIMENSION(:, :, :), ALLOCATABLE :: HMFGROW, HTCROW, QFCROW, &
  GFLXROW 
REAL, DIMENSION(:, :), ALLOCATABLE :: HMFGGAT, HTCGAT, QFCGAT
REAL, DIMENSION(:, :), ALLOCATABLE :: HMFGGRD, HTCGRD, QFCGRD, GFLXGRD
INTEGER, DIMENSION(:, :, :, :), ALLOCATABLE :: ITCTROW
INTEGER, DIMENSION(:, :, :), ALLOCATABLE :: ITCTGAT

!* TITLE: PROJECT DESCRIPTOR (6 COLUMNS: 4 CHARACTER STRINGS)
!* NAME: AUTHOR, RESEARCHER (6 COLUMNS: 4 CHARACTER STRINGS)
!* PLACE: SITE LOCATION, BASIN (6 COLUMNS: 4 CHARACTER STRINGS)
CHARACTER :: TITLE1*4, TITLE2*4, TITLE3*4, TITLE4*4, TITLE5*4, &
  TITLE6*4, NAME1*4, NAME2*4, NAME3*4, NAME4*4, NAME5*4, NAME6*4, &
  PLACE1*4, PLACE2*4, PLACE3*4, PLACE4*4, PLACE5*4, PLACE6*4
!>
!>*******************************************************************
!>*******************************************************************
!>
!> OUTPUT VARIABLES:
!> THE SUFFIX "ACC" REFERS TO THE ACCUMULATOR ARRAYS USED IN
!> CALCULATING TIME AVERAGES.
!* ALL: DEFINITIONS IN CLASS DOCUMENTATION
REAL, DIMENSION(:), ALLOCATABLE :: PREACC, GTACC, QEVPACC, &
  HFSACC, ROFACC, SNOACC, ALVSACC, ALIRACC, FSINACC, FLINACC, &
  TAACC, UVACC, PRESACC, QAACC, EVAPACC, FLUTACC, ROFOACC, &
  ROFSACC, ROFBACC, HMFNACC, WTBLACC, WSNOACC, RHOSACC, TSNOACC, &
  TCANACC, RCANACC, SCANACC, GROACC, CANARE, SNOARE, ZPNDACC

!> FIELD OF DELTA STORAGE AND INITIAL STORAGE
REAL, DIMENSION(:), ALLOCATABLE :: DSTG, STG_I

REAL, DIMENSION(:, :), ALLOCATABLE :: TBARACC, THLQACC, THICACC, &
  THALACC , THLQ_FLD, THIC_FLD, GFLXACC

!* TOTAL_ROFACC: TOTAL RUNOFF
!* TOTAL_EVAPACC: TOTAL EVAPORATION
!* TOTAL_PREACC: TOTAL PRECIPITATION
!* INIT_STORE: INITIAL STORAGE
!* FINAL_STORE: FINAL STORAGE
!* TOTAL_AREA: TOTAL FRACTIONED DRAINAGE AREA
REAL :: TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
  FINAL_STORE, TOTAL_AREA, &
    TOTAL_PRE_ACC_M, TOTAL_EVAP_ACC_M, TOTAL_ROF_ACC_M, &
    TOTAL_ROFO_ACC_M, TOTAL_ROFS_ACC_M, TOTAL_ROFB_ACC_M, &
    TOTAL_PRE_M, TOTAL_EVAP_M, TOTAL_ROF_M, &
    TOTAL_ROFO_M, TOTAL_ROFS_M, TOTAL_ROFB_M, &
    TOTAL_SCAN_M, TOTAL_RCAN_M, &
    TOTAL_SNO_M, TOTAL_WSNO_M, &
    TOTAL_ZPND_M, &
    TOTAL_STORE_M, TOTAL_STORE_2_M, &
    TOTAL_STORE_ACC_M
  
!* TOTAL_HFS = TOTAL SENSIBLE HEAT FLUX
!* TOTAL_QEVP = TOTAL LATENT HEAT FLUX
REAL :: TOTAL_HFSACC, TOTAL_QEVPACC

REAL :: TOTAL_STORE, TOTAL_STORE_2, TOTAL_RCAN, TOTAL_SCAN, TOTAL_SNO, TOTAL_WSNO, TOTAL_ZPND
REAL :: TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
REAL, DIMENSION(:), ALLOCATABLE :: TOTAL_THLQ, TOTAL_THIC, &
    TOTAL_THLQ_M, TOTAL_THIC_M

!> CROSS-CLASS VARIABLES (CLASS):
!> ARRAYS DEFINED TO PASS INFORMATION BETWEEN THE THREE MAJOR
!> SUBSECTIONS OF CLASS ("CLASSA", "CLASST" AND "CLASSW").
REAL, DIMENSION(:, :), ALLOCATABLE :: TBARC, TBARG, TBARCS, &
  TBARGS, THLIQC, THLIQG, THICEC, THICEG, FROOT, HCPC, HCPG, &
  TCTOPC, TCBOTC, TCTOPG, TCBOTG

REAL, DIMENSION(:), ALLOCATABLE :: FC, FG, FCS, FGS, RBCOEF, &
  ZSNOW, FSVF, FSVFS, ALVSCN, ALIRCN, ALVSG, &
  ALIRG, ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, &
  ALIRSC, TRVSCN, TRIRCN, TRVSCS, TRIRCS, RC, RCS, FRAINC, &
  FSNOWC, FRAICS, FSNOCS,CMASSC, CMASCS, DISP, DISPS, ZOMLNC, &
  ZOELNC, ZOMLNG, &
  ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS, TRSNOW, CHCAP, CHCAPS, &
  GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, G12CS, G12GS, G23C, &
  G23G, G23CS, G23GS, QFREZC, QFREZG, QMELTC, QMELTG, EVAPC, &
  EVAPCG, EVAPG, EVAPCS, EVPCSG, EVAPGS, TCANO, TCANS, RAICAN, &
  SNOCAN, RAICNS, SNOCNS, CWLCAP, CWFCAP, CWLCPS, CWFCPS, TSNOCS, &
  TSNOGS, RHOSCS, RHOSGS, WSNOCS, WSNOGS, TPONDC, TPONDG, TPNDCS, &
  TPNDGS, ZPLMCS, ZPLMGS, ZPLIMC, ZPLIMG

!> BALANCE ERRORS (CLASS):
!> DIAGNOSTIC ARRAYS USED FOR CHECKING ENERGY AND WATER
!> BALANCES.
REAL, DIMENSION(:), ALLOCATABLE :: CTVSTP, CTSSTP, CT1STP, &
  CT2STP, CT3STP, WTVSTP, WTSSTP, WTGSTP

!> CTEM-RELATED FIELDS (NOT USED IN STANDARD OFFLINE CLASS RUNS).
REAL, DIMENSION(:), ALLOCATABLE :: &
 CO2CONC, COSZS, XDIFFUSC, CFLUXCG, CFLUXCS
REAL, DIMENSION(:, :), ALLOCATABLE :: &
 AILCG, AILCGS, FCANC, FCANCS, CO2I1CG, CO2I1CS, CO2I2CG, CO2I2CS, &
 SLAI, FCANCMX, ANCSVEG, ANCGVEG, RMLCSVEG, RMLCGVEG, &
 AILC, PAIC, &
 FIELDSM,  WILTSM
REAL, DIMENSION(:, :, :), ALLOCATABLE :: &
 RMATCTEM, RMATC
INTEGER, DIMENSION (:), ALLOCATABLE :: NOL2PFTS
INTEGER ICTEMMOD, L2MAX

!> COMMON BLOCK PARAMETERS (CLASS):
INTEGER :: K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11
REAL :: X1, X2, X3, X4, G, GAS, X5, X6, CPRES, GASV, X7, CPI, X8, &
        CELZRO, X9, X10, X11, X12, X13, X14, X15, SIGMA, X16, DELTIM, &
        DELT, TFREZ, RGAS, RGASV, GRAV, SBC, VKC, CT, VMIN, TCW, TCICE, &
        TCSAND, TCCLAY, TCOM, TCDRYS, RHOSOL, RHOOM, HCPW, HCPICE, &
        HCPSOL, HCPOM, HCPSND, HCPCLY, SPHW, SPHICE, SPHVEG, SPHAIR, &
        RHOW, RHOICE, TCGLAC, CLHMLT, CLHVAP, PI, ZOLNG, ZOLNS, ZOLNI, &
        ZORATG, ALVSI, ALIRI, ALVSO, ALIRO, ALBRCK, DELTA, CGRAV, &
        CKARM, CPD, AS, ASX, CI, BS, BETA, FACTN, HMIN, ANGMAX


!> DAN * CONFLICTS WITH COMMON BLOCK DEFINITIONS (APR 20/08)
REAL, DIMENSION(ICAN) :: CANEXT, XLEAF, ZORAT

REAL, DIMENSION(3) :: THPORG, THRORG, THMORG, BORG, PSISORG, &
  GRKSORG
REAL, DIMENSION(18, 4, 2) :: GROWYR

INTEGER found

CHARACTER(10) :: time
CHARACTER(8)  :: cday

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

INTEGER SUBBASINCOUNT
INTEGER, DIMENSION(:), ALLOCATABLE :: SUBBASIN

!>=======================================================================
!> DAN * GLOBAL SUBROUTINES AND VARIABLES

!> SOME SUBROUTINES AND VARIABLES HAVE BEEN TAKEN FROM RTE.EXE TO
!> READ THE BASIN SHD FILE AND WRITE THE RTE.EXE INPUT FILES
!> (RUNOFF, RECHARGE, AND LEAKAGES VALUES).  TO FOLLOW THE
!> PROGRAMMING METHODS USED BY RTE.EXE, THESE SUBROUTINES AND
!> VARIABLES HAVE REMAINED GLOBAL AND ARE ACCESSIBLE BY CALLING
!> AREA_WATFLOOD AND EF_MODULE USING THE "USE" COMMAND.  THE
!> GLOBAL SUBROUTINES AND VARIABLES THAT ARE USED BY MESH_DRIVER
!> ARE LISTED BELOW.
!
!> DAN * SUBROUTINES AND MODULES:
!
!> RDEVT: SUBROUTINE USED TO READ THE EVENT FILE (EVENT/EVENT.EVT)
!> READ_SHED_EF: SUBROUTINE USED TO READ THE BASIN SHD FILE
!> WRITE_R2C: SUBROUTINE USED TO WRITE R2C-FORMAT RTE.EXE INPUT
!>            FILES (RUNOFF, RECHARGE, AND LEAKAGES VALUES)
!> AREA_WATFLOOD: MODULE CONTAINING VARIABLE DEFINITIONS
!> EF_MODULE: MODULE CONTAINING FORMATTING FUNCTIONS AND
!>            SUBROUTINES
!> EF_PARSEUTILITIES: MODULE CONTAINING FORMATTING FUNCTIONS AND
!>                    SUBROUTINES CALLED BY EF_MODULE
!> FIND_MONTH: SUBROUTINE USED TO CONVERT JULIAN DAY FROM YEAR
!>             START INTO MONTH FROM YEAR START (1 TO 12)
!> FIND_DAY: SUBROUTINE USED TO CONVERT JULIAN DAY FROM YEAR START
!>           INTO DAY FROM MONTH START (1 TO 31)

!> DAN * VARIABLES:

!* FLN: CONTAINS BASIN SHD AND RTE.EXE INPUT FILES' FILE NAMES
!* XCOUNT_TEMP, XCOUNT: NUMBER OF GRID SQUARES IN X-DIRECTION OF
!*                      BASIN (COLUMNS) (JMAX)
!* YCOUNT_TEMP, YCOUNT: NUMBER OF GRID SQUARES IN Y-DIRECTION OF
!*                      BASIN (ROWS) (IMAX)
!* AL: SINGLE GRID SIDE LENGTH IN METRES (AL)
!* NA: NUMBER OF GRID SQUARES IN BASIN (WF_NA)
!* NAA: NUMBER OF GRID SQUARE OUTLETS IN BASIN (NAA)
!* NTYPE: NUMBER OF GRUS (WF_NTYPE)
!* FRAC: GRID FRACTION (previously WF_FRAC)
!* ACLASS: PERCENT-GRU FRACTION FOR EACH GRID SQUARE
!* OUTARRAY: USED TO PASS DATA TO WRITE_R2C
!* AUTHOR: PROGRAM NAME = 'MESH_DRIVER' (PASSED TO WRITE_R2C)
!* MODELFLG: WATROUTE CONFIGURATION (FROM EVENT FILE)
!* COORDSYS_TEMP, COORDSYS1: CO-ORDINATE SYSTEM (FROM BASIN SHD
!*                           FILE) (PASSED TO WRITE_R2C)
!* ZONE_TEMP, ZONE1: CO-ORDINATE SYSTEM (FROM BASIN SHD FILE)
!*                   (PASSED TO WRITE_R2C)
!* DATUM_TEMP, DATUM1: CO-ORDINATE SYSTEM (FROM BASIN SHD FILE)
!*                     (PASSED TO WRITE_R2C)
!* XORIGIN_TEMP, XORIGIN: X-DIRECTION CO-ORDINATE OF BASIN GRID
!*                        (FROM BASIN SHD FILE) (PASSED TO
!*                        WRITE_R2C)
!* YORIGIN_TEMP, YORIGIN: Y-DIRECTION CO-ORDINATE OF BASIN GRID
!*                        (FROM BASIN SHD FILE) (PASSED TO
!*                        WRITE_R2C)
!* XDELTA_TEMP, XDELTA: AVERAGE DIFFERENCE BETWEEN TWO X-DIRECTION
!*                      SIDES OF GRID SQUARE (FROM BASIN SHD FILE)
!*                      (PASSED TO WRITE_R2C)
!* YDELTA_TEMP, YDELTA: AVERAGE DIFFERENCE BETWEEN TWO Y-DIRECTION
!*                      SIDES OF GRID SQUARE (FROM BASIN SHD FILE)
!*                      (PASSED TO WRITE_R2C)
!* SOURCE_FILE_NAME: DATA SOURCE = 'CLASS' (PASSED TO WRITE_R2C)
!* NAME: R2C-FORMAT DATA FILE NAME (PASSED TO WRITE_R2C)
!* ATTRIBUTE_NAME: R2C-FORMAT DATA IDENTIFER (PASSED TO WRITE_R2C)
!* ATTRIBUTE_UNITS: R2C-FORMAT DATA UNITS (PASSED TO WRITE_R2C)
!* ATTRIBUTE_TYPE: R2C-FORMAT DATA TYPE (PASSED TO WRITE_R2C)
!* YYY: Y-DIRECTION GRID SQUARE CO-ORDINATE (YYY), aka column coordinate
!* XXX: X-DIRECTION GRID SQUARE CO-ORDIANTE (XXX), aka row coordinate


!> These are the types defined in mesh_input_module.f that contain arrays
!> that need to be allocated in read_initial_inputs.f.
TYPE(OutputPoints) :: op
!TYPE(ShedInformation) :: si
TYPE(SoilLevels) :: sl
TYPE(ClassParameters) :: cp
TYPE(SoilValues) :: sv
TYPE(HydrologyParameters) :: hp

type(fl_ids):: fls 

!>THESE ARE THTE TYPES DEFINED IN MODEL_OUTPUT.F95 NEED TO WRITE OUTPUT FIELD ACCUMULATED
!> OR AVERAGE FOR THE WATER BALANCE AND SOME OTHER STATES VARIABLES
TYPE(OUT_FLDS)      :: VR
type(basin_info)    :: bi
TYPE(DATES_MODEL)   :: TS
TYPE(INFO_OUT)      :: IOF
TYPE(CLIM_INFO)     :: cm
type(met_data) :: md
type(CLASSOUT_VARS) :: co
type(water_balance) :: wb, wb_h
type(energy_balance) :: eng
type(soil_statevars) :: sov

LOGICAL :: R2COUTPUT,EXISTS
INTEGER, PARAMETER :: R2CFILEUNITSTART = 500
INTEGER NR2C,DELTR2C,NR2CFILES,NR2CSTATES,NR2C_R,DELTR2C_R,NR2C_S,DELTR2C_S
INTEGER, ALLOCATABLE, DIMENSION(:)        :: GRD,GAT,GRDGAT,GRD_R,GAT_R,GRDGAT_R,GRD_S,GAT_S,GRDGAT_S
CHARACTER*50, ALLOCATABLE, DIMENSION(:,:) :: R2C_ATTRIBUTES, R2C_ATTRIBUTES_R, R2C_ATTRIBUTES_S

INTEGER  NMELT
REAL ::  SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS
INTEGER, ALLOCATABLE, DIMENSION(:):: INFILTYPE
REAL, DIMENSION(:), ALLOCATABLE   :: SI,TSI,SNOWMELTD,SNOWMELTD_LAST, &
                                     SNOWINFIL,CUMSNOWINFILCS,MELTRUNOFF,CUMSNOWINFILGS
!* PDMROF
REAL                              :: ZPND, FSTR
REAL, DIMENSION(:), ALLOCATABLE   :: CMINPDM,   CMAXPDM,   BPDM,      K1PDM,   K2PDM, &
                                     ZPNDPRECS, ZPONDPREC, ZPONDPREG, ZPNDPREGS,      &
                                     UM1CS,     UM1C,      UM1G,      UM1GS,          &
                                     QM1CS,     QM1C,      QM1G,      QM1GS,          &
                                     QM2CS,     QM2C,      QM2G,      QM2GS,   UMQ,   &
                                     FSTRCS,    FSTRC,     FSTRG,    FSTRGS

! To use with variable format expressions in writing some output files
CHARACTER*20 IGND_CHAR
CHARACTER*2000 FMT

CHARACTER*500 WRT_900_1,WRT_900_2,WRT_900_3,WRT_900_4,WRT_900_f
CHARACTER*500 fl_listMesh
CHARACTER*5  strInt
!=======================================================================
!     * SET PHYSICAL CONSTANTS AND COMMON BLOCKS

COMMON    /PARAMS/    X1, X2, X3, X4, G, GAS, X5, X6, CPRES, &
                      GASV, X7
COMMON    /PARAM1/    CPI, X8, CELZRO, X9, X10, X11
COMMON    /PARAM3/    X12, X13, X14, X15, SIGMA, X16
COMMON    /TIMES/     DELTIM, K1, K2, K3, K4, K5, K6, K7, K8, K9, &
                      K10, K11

!> THE FOLLOWING COMMON BLOCKS ARE DEFINED SPECIFICALLY FOR USE
!> IN CLASS, VIA BLOCK DATA AND THE SUBROUTINE "CLASSD".
COMMON    /CLASS1/    DELT, TFREZ
COMMON    /CLASS2/    RGAS, RGASV, GRAV, SBC, VKC, CT, VMIN
COMMON    /CLASS3/    TCW, TCICE, TCSAND, TCCLAY, TCOM, TCDRYS, &
                      RHOSOL, RHOOM
COMMON    /CLASS4/    HCPW, HCPICE, HCPSOL, HCPOM, HCPSND, &
                      HCPCLY, SPHW, SPHICE, SPHVEG, SPHAIR, RHOW, &
                      RHOICE, TCGLAC, CLHMLT, CLHVAP
COMMON    /CLASS5/    THPORG, THRORG, THMORG, BORG, PSISORG, &
                      GRKSORG
COMMON    /CLASS6/    PI, GROWYR, ZOLNG, ZOLNS, ZOLNI, ZORAT, &
                      ZORATG
COMMON    /CLASS7/    CANEXT, XLEAF
COMMON    /CLASS8/    ALVSI, ALIRI, ALVSO, ALIRO, ALBRCK
COMMON    /PHYCON/    DELTA, CGRAV, CKARM, CPD
COMMON /CLASSD2/ AS,ASX,CI,BS,BETA,FACTN,HMIN,ANGMAX

!> THE FOLLOWING COMMON BLOCKS ARE DEFINED FOR WATROF
!COMMON    /WATFLGS/   VICEFLG, PSI_LIMIT, HICEFLG, LZFFLG, &
!                      EXTFLG, IWFICE, ERRFLG, IMIN, IHOUR, IDAY, &
!                      IYEAR

DATA VICEFLG/3.0/, PSI_LIMIT/1.0/, HICEFLG/1.0/, LZFFLG/0/, &
  EXTFLG/0/, IWFICE/3/, ERRFLG/1/

real :: startprog, endprog
integer :: narg
!real :: alpharain
!character*50 :: alphCh

!> ((((((((((((((((((((((((((((((((((
!> Set the acceptable version numbers
!> ))))))))))))))))))))))))))))))))))
!> todo this should be input file dependant,
!>  because different files will work with different releases
!>  so, make them local variables inside each read subroutine.
      RELEASE(1) = "1.1.a01"
      RELEASE(2) = "1.1.a02"
      RELEASE(3) = "1.1.a04"
      RELEASE(4) = "1.2.000"
      RELEASE(5) = "1.2.a01"
      RELEASE(6) = "1.3.000"
      RELEASE(7) = "1.3.1"

call cpu_time(startprog)
!>=======================================================================
!>      PROGRAM START

    !> Initialize MPI.
    call mpi_init(ierr)
    if (ierr /= mpi_success) then
        print *, "Failed to initialize MPI."
        call mpi_abort(mpi_comm_world, ierrcode, ierr)
        print *, "ierrcode ", ierrcode, "ierr ", ierr
    end if

    !> Grab number of total processes and current process ID.
    call mpi_comm_size(mpi_comm_world, inp, ierr)
    call mpi_comm_rank(mpi_comm_world, ipid, ierr)

    !> izero is active if the head node is used for booking and lateral flow
    !> processes.
    if (inp > 1) then
        izero = 1
    else
        izero = 0
    end if

    !> Reset verbose flag for worker nodes.
    if (ipid > 0) ro%VERBOSEMODE = 0

!>!TODO: UPDATE THIS (RELEASE(*)) WITH VERSION CHANGE
    if (ro%VERBOSEMODE > 0) print 951, trim(RELEASE(7)), trim(VERSION)

951 format(1x, 'MESH 'a, ' ---  ('a, ')'/)

!File handled for variable in/out names
!At the moment only class,hydro parameters and some outputs

    !> Check if any command line arguments are found.
    narg = command_argument_count()
    !print *, narg
    if (narg > 0) then
        VARIABLEFILESFLAG = 1
        if (narg >= 1) then
            call get_command_argument(1, fl_listMesh)
!        print *, fl_listMesh
!    elseif (narg .eq. 2) then
!        call get_command_argument(1, fl_listMesh)
!        print *, fl_listMesh
!todo: re-instate alpha
!        call get_command_argument(2, alphCh)
!        call value(alphCh, alpharain, ios)
!        cm%clin(8)%alpharain = alpharain
!        print *, cm%clin(8)%alpharain
        end if
        call Init_fls(fls, trim(adjustl(fl_listMesh)))
    else
!todo: Call this anyway, make loading values from file an alternate subroutine of module_files
        call Init_fls(fls)
    end if !(narg .gt. 0) then

    !> Determine the value of IGND from MESH_input_soil_levels.txt
!todo: Move this to read_soil_levels
    IGND = 0

    !> Open soil levels file and check for IOSTAT errors.
!    if ((VARIABLEFILESFLAG == 1) .and. (fls%fl(10)%isInit)) then
    iun = fls%fl(mfk%f52)%iun
    open(iun, &
        file = trim(adjustl(fls%fl(mfk%f52)%fn)), &
        action = 'read', &
        status = 'old', iostat = ios)
!    else
!        open(52, file = 'MESH_input_soil_levels.txt', status = 'old', iostat = IOS)
!    end if
    if (ios /= 0) then
        print 1002
        stop
    end if

    !> Count the number of soil layers.
    IGND_TEST = 1.0
    do while (IGND_TEST /= 0.0 .and. ios == 0)
        read(52, * , iostat = ios) IGND_TEST, IGND_DEEP
        IGND = IGND + 1
    end do

    !> because IGND increments the first time that IGND_TEST = 0.0
    IGND = IGND - 1
    print *, "IGND = ", IGND
    close(iun)

1002 format(/ &
        /1x, 'MESH_input_soil_levels.txt could not be opened.', &
        /1x', Ensure that the file exists and restart the program.', /)

!>=======================================================================
!> INITIALIZE CLASS VARIABLES
!> SET COMMON CLASS PARAMETERS.
CALL CLASSD
!>
!>*******************************************************************
!>
CALL READ_INITIAL_INPUTS( &
!>GENERIC VARIABLES
  RELEASE, &
!>VARIABLES FOR READ_RUN_OPTIONS
  IDISP, IZREF, ISLFD, IPCP, IWF, &
  IPAI, IHGT, IALC, IALS, IALG, ITG, ITC, ITCG, &
  ICTEMMOD, IOS, PAS, N, IROVAL, WF_NUM_POINTS, &
!  IYEAR_START, IDAY_START, IHOUR_START, IMIN_START, &
!  IYEAR_END,IDAY_END, IHOUR_END, IMIN_END, &
  IRONAME, GENDIR_OUT, &
!>variables for drainage database or new_shd
 IGND, ILG, WF_IYMAX, WF_JXMAX, &
 WF_LAND_COUNT, &
 LATDEGMIN, LATMINMIN, LATDEGMAX, LATMINMAX, &
 LONDEGMIN, LONMINMIN, LONDEGMAX, LONMINMAX, &
 WF_LAND_MAX, WF_LAND_SUM, &
!>variables for READ_CHECK_FORCING_FILES
! NUM_CSV, NUM_R2C, NUM_SEQ, &
!>variables for READ_PARAMETERS_CLASS
  TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6, &
  NAME1, NAME2, NAME3, NAME4, NAME5, NAME6, &
  PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6, &
  ILW, NLTEST, NMTEST, JLAT, ICAN, &
  DEGLAT, DEGLON, &
  HOURLY_START_DAY,  HOURLY_STOP_DAY, &
  DAILY_START_DAY,   DAILY_STOP_DAY, &
  HOURLY_START_YEAR, HOURLY_STOP_YEAR, &
  DAILY_START_YEAR,  DAILY_STOP_YEAR, &
!  IHOUR, IMIN, IDAY, IYEAR, &
 !>variables for READ_SOIL_INI
 !>variables for READ_PARAMETERS_HYDROLOGY
  INDEPPAR, DEPPAR, WF_R2, M_C, &
 !>the types that are to be allocated and initialised
  bi, op, sl, cp, sv, hp, ts, cm, &
  SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS, fls)

!>
!>***********************************************************************
!> Forcing data time step should not be less than 30 min - there is no 
!> any increase in accuracy as delt (CLASS model time step) is 30 min.
!>=======================================================================

    if (HOURLYFLAG < 30) then
        print 1028
        stop
    end if

1028 format( &
    //1x'FORCING DATA TIME STEP IS LESS THAN 30 MIN', &
    /1x'AGGREGATE THE FORCING DATA TO 30 MIN INTERVAL AND TRY AGAIN'/)

!>
!>***********************************************************************
!> MAM - Check for parameter values - all parameters should lie within the 
!> specified ranges in the "minmax_parameters.txt" file.
!>=======================================================================
!>
call check_parameters(WF_R2,M_C,NMTEST,cp,hp,soil_por_max,soil_depth,s0,t_ice_lens)

!>
!>*******************************************************************
!>
!>=======================================================================
!> ALLOCATE ALL VARIABLES
!> DAN * IGND, ICAN, AND ICP1 HAVE BEEN INCLUDED IN CASE THEY WILL BE
!> DAN * CONFIGURABLE IN THE FUTURE (IF IN THE RUN_OPTIONS.INI FILE)
!> DAN * (APR 20/08).


!> ANDY * Allocate some variables
ALLOCATE (WF_NHYD(NA), WF_QR(NA), &
  WF_QBASE(NA), WF_QI2(NA), WF_QO1(NA), WF_QO2(NA), &
  WF_STORE1(NA), WF_STORE2(NA), WF_QI1(NA), SNOGRD(NA))

    !> ANDY * Zero everything we just allocated
    WF_NHYD = 0.0
    WF_QBASE = 0.0
    WF_QI2 = 0.0
    WF_QO1 = 0.0
    WF_QO2 = 0.0
    WF_QR = 0.0
    WF_STORE1 = 0.0
    WF_STORE2 = 0.0
    WF_QI1 = 0.0

!!> WATROUTE INPUT FILES:
!ALLOCATE (RUNOFF(YCOUNT, XCOUNT), &
!  RECHARGE(YCOUNT, XCOUNT), STAT=PAS)
ALLOCATE (OUTARRAY(YCOUNT, XCOUNT), RUNOFF(YCOUNT, XCOUNT), &
  RECHARGE(YCOUNT, XCOUNT), LEAKAGES(YCOUNT, XCOUNT), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'WATROUTE input'
    print 1118, 'Grid square rows', YCOUNT
    print 1118, 'Grid square columns', XCOUNT
    stop
END IF

1114 format( &
    //1x, 'Error allocating 'a, ' variables.', &
    /1x'Check that these bounds are within an acceptable range.')
1118 format(3x, a, ': ', i6)

!> MET. FORCING DATA:


!> LAND SURFACE PROGNOSTIC VARIABLES (CLASS.INI):
ALLOCATE ( &
  TBARGAT(ILG, IGND), &
  THLQGAT(ILG, IGND), THICGAT(ILG, IGND), &
  SANDGAT(ILG, IGND), CLAYGAT(ILG, IGND), &
  TBASROW(NA, NTYPE), &
  CMAIROW(NA, NTYPE), TACROW(NA, NTYPE), &
  QACROW(NA, NTYPE), WSNOROW(NA, NTYPE), &
  TPNDGAT(ILG), ZPNDGAT(ILG), TBASGAT(ILG), &
  ALBSGAT(ILG), TSNOGAT(ILG), RHOSGAT(ILG), &
  SNOGAT(ILG), TCANGAT(ILG), RCANGAT(ILG), &
  SCANGAT(ILG), &
  GROGAT(ILG), FRZCGAT(ILG), CMAIGAT(ILG), TACGAT(ILG), &
  QACGAT(ILG), WSNOGAT(ILG), &
  TSFSROW(NA, NTYPE, 4), &
  TSFSGAT(ILG, 4), STAT=PAS)
!> PBSM PROGNOSTIC VARIABLES
ALLOCATE ( &
  DrySnowROW(NA, NTYPE), SnowAgeROW(NA, NTYPE), &
  DrySnowGAT(ILG), SnowAgeGAT(ILG), &
  TSNOdsROW(NA, NTYPE), RHOSdsROW(NA, NTYPE), &
  TSNOdsGAT(ILG), RHOSdsGAT(ILG), &
  DriftROW(NA, NTYPE), SublROW(NA, NTYPE), DepositionROW(NA, NTYPE), &
  DriftGAT(ILG), SublGAT(ILG), DepositionGAT(ILG), &
  ZSNOCS(ILG),ZSNOGS(ILG), &
  ZSNOWC(ILG),ZSNOWG(ILG), &
  HCPSCS(ILG),HCPSGS(ILG), &
  HCPSC(ILG),HCPSG(ILG), &
  TSNOWC(ILG),TSNOWG(ILG), &
  RHOSC(ILG),RHOSG(ILG), &
  XSNOWC(ILG),XSNOWG(ILG), &
  XSNOCS(ILG),XSNOGS(ILG), STAT=PAS)

!> LAND SURFACE PROGNOSTIC VARIABLES (for Basin_average_water_balance.csv):
ALLOCATE (TOTAL_THLQ(IGND), TOTAL_THIC(IGND), &
    TOTAL_THLQ_M(IGND), TOTAL_THIC_M(IGND), STAT=PAS)

IF (PAS .NE. 0) THEN
    print 1114, 'land surface prognostic'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Soil layers', IGND
    stop
END IF

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

ALLOCATE ( SUBBASIN(ILG), STAT=PAS)


IF (PAS .NE. 0) THEN
    print 1114, 'subbasin grid'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    stop
END IF

!     * GATHER-SCATTER COUNTS:
ALLOCATE (ILMOS(ILG), JLMOS(ILG), IWMOS(ILG), &
  JWMOS(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'gather-scatter count'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    stop
END IF


ALLOCATE ( &
  FCANGAT(ILG, ICP1), LNZ0GAT(ILG, ICP1), &
  ALVCGAT(ILG, ICP1), ALICGAT(ILG, ICP1), &
  PAIDROW(NA, NTYPE, ICAN), &
  HGTDROW(NA, NTYPE, ICAN), ACVDROW(NA, NTYPE, ICAN), &
  ACIDROW(NA, NTYPE, ICAN), &
  PAMXGAT(ILG, ICAN), PAMNGAT(ILG, ICAN), &
  CMASGAT(ILG, ICAN), ROOTGAT(ILG, ICAN), &
  RSMNGAT(ILG, ICAN), QA50GAT(ILG, ICAN), &
  VPDAGAT(ILG, ICAN), VPDBGAT(ILG, ICAN), &
  PSGAGAT(ILG, ICAN), &
  PSGBGAT(ILG, ICAN), PAIDGAT(ILG, ICAN), &
  HGTDGAT(ILG, ICAN), ACVDGAT(ILG, ICAN), &
  ACIDGAT(ILG, ICAN), &
  THPROW(NA, NTYPE, IGND), THRROW(NA, NTYPE, IGND), &
  THMROW(NA, NTYPE, IGND), &
  BIROW(NA, NTYPE, IGND), PSISROW(NA, NTYPE, IGND), &
  GRKSROW(NA, NTYPE, IGND), THRAROW(NA, NTYPE, IGND), &
  HCPSROW(NA, NTYPE, IGND), TCSROW(NA, NTYPE, IGND), &
  THFCROW(NA, NTYPE, IGND), &
  PSIWROW(NA, NTYPE, IGND), DLZWROW(NA, NTYPE, IGND), &
  ZBTWROW(NA, NTYPE, IGND), &
  THPGAT(ILG, IGND), THRGAT(ILG, IGND), &
  THMGAT(ILG, IGND), &
  BIGAT(ILG, IGND), PSISGAT(ILG, IGND), &
  GRKSGAT(ILG, IGND), THRAGAT(ILG, IGND), &
  HCPSGAT(ILG, IGND), TCSGAT(ILG, IGND), &
  THFCGAT(ILG, IGND), &
  PSIWGAT(ILG, IGND), DLZWGAT(ILG, IGND), &
  ZBTWGAT(ILG, IGND), GFLXGAT(ILG, IGND), &
  WFSFROW(NA, NTYPE),  ALGWROW(NA, NTYPE), &
  ALGDROW(NA, NTYPE), ASVDROW(NA, NTYPE), ASIDROW(NA, NTYPE), &
  AGVDROW(NA, NTYPE), &
  AGIDROW(NA, NTYPE), &
  DRNGAT(ILG), XSLPGAT(ILG), XDGAT(ILG), &
  WFSFGAT(ILG), KSGAT(ILG), ALGWGAT(ILG), &
  ALGDGAT(ILG), ASVDGAT(ILG), ASIDGAT(ILG), &
  AGVDGAT(ILG), &
  AGIDGAT(ILG), ZSNLGAT(ILG), ZPLGGAT(ILG), &
  ZPLSGAT(ILG), SDEPGAT(ILG), FAREGAT(ILG), &
  ISNDROW(NA, NTYPE, IGND), IORG(NA, NTYPE, IGND), &
  ISNDGAT(ILG, IGND), IGDRROW(NA,NTYPE), &
  IGDRGAT(ILG), &
  fetchGAT(ILG),HtGAT(ILG),N_SGAT(ILG),A_SGAT(ILG), &
  DistribGAT(ILG),STAT=PAS)

IF (PAS .NE. 0) THEN
    print 1114, 'canopy and soil info.'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    print 1118, 'Canopy types with urban areas', ICP1
    print 1118, 'Canopy types', ICAN
    print 1118, 'Soil layers', IGND
    stop
END IF

!> WATROF FLAGS AND VARIABLES:
ALLOCATE (DDGAT(ILG), MANNGAT(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'WATROF'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    stop
END IF

!> ATMOSPHERIC AND GRID-CONSTANT INPUT VARIABLES:
ALLOCATE ( ZDMGRD(NA), &
  ZDHGRD(NA), RADJGRD(NA), &
  CSZGRD(NA), &
  PADRGRD(NA), VPDGRD(NA), &
  TADPGRD(NA), RHOAGRD(NA), RPCPGRD(NA), TRPCGRD(NA), &
  SPCPGRD(NA), TSPCGRD(NA), RHSIGRD(NA), &
  FCLOGRD(NA), DLONGRD(NA), Z0ORGRD(NA), GGEOGRD(NA), UVGRD(NA), &
  XDIFFUS(NA), &
  RPREGRD(NA), SPREGRD(NA), VMODGRD(NA), &
  ZRFMGAT(ILG), ZRFHGAT(ILG), ZDMGAT(ILG), &
  ZDHGAT(ILG), ZBLDGAT(ILG), &
  RADJGAT(ILG), CSZGAT(ILG), &
  RPREGAT(ILG), SPREGAT(ILG), &
  PADRGAT(ILG), VPDGAT(ILG), &
  TADPGAT(ILG), RHOAGAT(ILG), RPCPGAT(ILG), &
  TRPCGAT(ILG), SPCPGAT(ILG), TSPCGAT(ILG), &
  RHSIGAT(ILG), &
  FCLOGAT(ILG), DLONGAT(ILG), Z0ORGAT(ILG), &
  GGEOGAT(ILG), VMODGAT(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'atmospheric and grid-cst.'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    stop
END IF

!> LAND SURFACE DIAGNOSTIC VARIABLES:
ALLOCATE (CDHROW(NA, NTYPE), CDMROW(NA, NTYPE), &
  HFSROW(NA, NTYPE), &
  TFXROW(NA, NTYPE), QEVPROW(NA, NTYPE), QFSROW(NA, NTYPE), &
  QFXROW(NA, NTYPE), PETROW(NA, NTYPE), GAROW(NA, NTYPE), &
  EFROW(NA, NTYPE), GTROW(NA, NTYPE), &
  QGROW(NA, NTYPE), TSFROW(NA, NTYPE), ALVSROW(NA, NTYPE), &
  ALIRROW(NA, NTYPE), FSNOROW(NA, NTYPE), SFCTROW(NA, NTYPE), &
  SFCUROW(NA, NTYPE), &
  SFCVROW(NA, NTYPE), SFCQROW(NA, NTYPE), FSGVROW(NA, NTYPE), &
  FSGSROW(NA, NTYPE), FSGGROW(NA, NTYPE), FLGVROW(NA, NTYPE), &
  FLGSROW(NA, NTYPE), &
  FLGGROW(NA, NTYPE), HFSCROW(NA, NTYPE), HFSSROW(NA, NTYPE), &
  HFSGROW(NA, NTYPE), HEVCROW(NA, NTYPE), HEVSROW(NA, NTYPE), &
  HEVGROW(NA, NTYPE), &
  HMFCROW(NA, NTYPE), HMFNROW(NA, NTYPE), HTCCROW(NA, NTYPE), &
  HTCSROW(NA, NTYPE), PCFCROW(NA, NTYPE), PCLCROW(NA, NTYPE), &
  PCPNROW(NA, NTYPE), &
  PCPGROW(NA, NTYPE), QFGROW(NA, NTYPE), QFNROW(NA, NTYPE), &
  QFCLROW(NA, NTYPE), QFCFROW(NA, NTYPE), ROFROW(NA, NTYPE), &
  ROFOROW(NA, NTYPE), &
  ROFSROW(NA, NTYPE), ROFBROW(NA, NTYPE), ROFCROW(NA, NTYPE), &
  ROFNROW(NA, NTYPE), ROVGROW(NA, NTYPE), WTRCROW(NA, NTYPE), &
  WTRSROW(NA, NTYPE), &
  WTRGROW(NA, NTYPE), DRROW(NA, NTYPE), WTABROW(NA, NTYPE), &
  ILMOROW(NA, NTYPE), UEROW(NA, NTYPE), HBLROW(NA, NTYPE), &
  TROFROW(NA, NTYPE), &
  TROOROW(NA, NTYPE), TROSROW(NA, NTYPE), TROBROW(NA, NTYPE), &
  CDHGAT(ILG), CDMGAT(ILG), HFSGAT(ILG), &
  TFXGAT(ILG), QEVPGAT(ILG), QFSGAT(ILG), &
  QFXGAT(ILG), PETGAT(ILG), GAGAT(ILG), &
  EFGAT(ILG), GTGAT(ILG), &
  QGGAT(ILG), ALVSGAT(ILG), &
  ALIRGAT(ILG), FSNOGAT(ILG), SFRHGAT(ILG), SFCTGAT(ILG), &
  SFCUGAT(ILG), &
  SFCVGAT(ILG), SFCQGAT(ILG), FSGVGAT(ILG), &
  FSGSGAT(ILG), FSGGGAT(ILG), FLGVGAT(ILG), &
  FLGSGAT(ILG), &
  FLGGGAT(ILG), HFSCGAT(ILG), HFSSGAT(ILG), &
  HFSGGAT(ILG), HEVCGAT(ILG), HEVSGAT(ILG), &
  HEVGGAT(ILG), &
  HMFCGAT(ILG), HMFNGAT(ILG), HTCCGAT(ILG), &
  HTCSGAT(ILG), PCFCGAT(ILG), PCLCGAT(ILG), &
  PCPNGAT(ILG), &
  PCPGGAT(ILG), QFGGAT(ILG), QFNGAT(ILG), &
  QFCLGAT(ILG), QFCFGAT(ILG), ROFGAT(ILG), &
  ROFOGAT(ILG), &
  ROFSGAT(ILG), ROFBGAT(ILG), ROFCGAT(ILG), &
  ROFNGAT(ILG), ROVGGAT(ILG), WTRCGAT(ILG), &
  WTRSGAT(ILG), &
  WTRGGAT(ILG), DRGAT(ILG), WTABGAT(ILG), &
  ILMOGAT(ILG), UEGAT(ILG), HBLGAT(ILG), QLWOGAT(ILG), &
  FTEMP(ILG),   FVAP(ILG),  RIB(ILG), TROFGAT(ILG), &
  TROOGAT(ILG), TROSGAT(ILG), TROBGAT(ILG), &
  CDHGRD(NA), CDMGRD(NA), HFSGRD(NA), &
  TFXGRD(NA), QEVPGRD(NA), QFSGRD(NA), QFXGRD(NA), PETGRD(NA), &
  GAGRD(NA), EFGRD(NA), GTGRD(NA), &
  QGGRD(NA), TSFGRD(NA), ALVSGRD(NA), ALIRGRD(NA), FSNOGRD(NA), &
  SFCTGRD(NA), SFCUGRD(NA), &
  SFCVGRD(NA), SFCQGRD(NA), FSGVGRD(NA), FSGSGRD(NA), &
  FSGGGRD(NA), FLGVGRD(NA), FLGSGRD(NA), &
  FLGGGRD(NA), HFSCGRD(NA), HFSSGRD(NA), HFSGGRD(NA), &
  HEVCGRD(NA), HEVSGRD(NA), HEVGGRD(NA), &
  HMFCGRD(NA), HMFNGRD(NA), HTCCGRD(NA), HTCSGRD(NA), &
  PCFCGRD(NA), PCLCGRD(NA), PCPNGRD(NA), &
  PCPGGRD(NA), QFGGRD(NA), QFNGRD(NA), QFCLGRD(NA), QFCFGRD(NA), &
  ROFGRD(NA), ROFOGRD(NA), &
  ROFSGRD(NA), ROFBGRD(NA), ROFCGRD(NA), ROFNGRD(NA), &
  ROVGGRD(NA), WTRCGRD(NA), WTRSGRD(NA), &
  WTRGGRD(NA), DRGRD(NA), WTABGRD(NA), ILMOGRD(NA), UEGRD(NA), &
  HBLGRD(NA), &
  HMFGROW(NA, NTYPE, IGND), HTCROW(NA, NTYPE, IGND), &
  QFCROW(NA, NTYPE, IGND), GFLXROW(NA, NTYPE, IGND), &
  HMFGGAT(ILG, IGND), HTCGAT(ILG, IGND), &
  QFCGAT(ILG, IGND), &
  HMFGGRD(NA, IGND), HTCGRD(NA, IGND), QFCGRD(NA, IGND), &
  GFLXGRD(NA, IGND), &
  ITCTROW(NA, NTYPE, 6, 50), &
  ITCTGAT(ILG, 6, 50), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'land surface diagnostic'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    print 1118, 'Soil layers', IGND
    stop
END IF

!> OUTPUT VARIABLES:
ALLOCATE (PREACC(NA), GTACC(NA), QEVPACC(NA), &
  HFSACC(NA), ROFACC(NA), SNOACC(NA), ALVSACC(NA), ALIRACC(NA), &
  FSINACC(NA), FLINACC(NA), &
  TAACC(NA), UVACC(NA), PRESACC(NA), QAACC(NA), EVAPACC(NA), &
  FLUTACC(NA), ROFOACC(NA), &
  ROFSACC(NA), ROFBACC(NA), HMFNACC(NA), WTBLACC(NA), ZPNDACC(NA), &
  WSNOACC(NA), RHOSACC(NA), TSNOACC(NA), &
  TCANACC(NA), RCANACC(NA), SCANACC(NA), GROACC(NA), CANARE(NA), &
  SNOARE(NA), &
  TBARACC(NA, IGND), THLQACC(NA, IGND), THICACC(NA, IGND), &
  THALACC(NA, IGND), GFLXACC(NA, IGND), &
  STG_I(NA), DSTG(NA),THLQ_FLD(NA,IGND),THIC_FLD(NA,IGND), &
  STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'accumulator'
    print 1118, 'Grid squares', NA
    print 1118, 'Soil layers', IGND
    stop
END IF

!> CROSS-CLASS VARIABLES (CLASS):
ALLOCATE (TBARC(ILG, IGND), TBARG(ILG, IGND), &
  TBARCS(ILG, IGND), &
  TBARGS(ILG, IGND), THLIQC(ILG, IGND), &
  THLIQG(ILG, IGND), THICEC(ILG, IGND), &
  THICEG(ILG, IGND), FROOT(ILG, IGND), &
  HCPC(ILG, IGND), HCPG(ILG, IGND), &
  TCTOPC(ILG, IGND), TCBOTC(ILG, IGND), &
  TCTOPG(ILG, IGND), TCBOTG(ILG, IGND), &
  FC(ILG), FG(ILG), FCS(ILG), &
  FGS(ILG), RBCOEF(ILG), &
  ZSNOW(ILG), &
  FSVF(ILG), FSVFS(ILG), ALVSCN(ILG), &
  ALIRCN(ILG), ALVSG(ILG), &
  ALIRG(ILG), ALVSCS(ILG), ALIRCS(ILG), &
  ALVSSN(ILG), ALIRSN(ILG), ALVSGC(ILG), &
  ALIRGC(ILG), ALVSSC(ILG), &
  ALIRSC(ILG), TRVSCN(ILG), TRIRCN(ILG), &
  TRVSCS(ILG), TRIRCS(ILG), RC(ILG), &
  RCS(ILG), FRAINC(ILG), &
  FSNOWC(ILG),FRAICS(ILG),FSNOCS(ILG), &
  CMASSC(ILG), CMASCS(ILG), &
  DISP(ILG), DISPS(ILG), ZOMLNC(ILG), &
  ZOELNC(ILG), ZOMLNG(ILG), &
  ZOELNG(ILG), ZOMLCS(ILG), ZOELCS(ILG), &
  ZOMLNS(ILG), ZOELNS(ILG), TRSNOW(ILG), &
  CHCAP(ILG), CHCAPS(ILG), &
  GZEROC(ILG), GZEROG(ILG), GZROCS(ILG), &
  GZROGS(ILG), G12C(ILG), G12G(ILG), &
  G12CS(ILG), G12GS(ILG), G23C(ILG), &
  G23G(ILG), G23CS(ILG), G23GS(ILG), &
  QFREZC(ILG), QFREZG(ILG), QMELTC(ILG), &
  QMELTG(ILG), EVAPC(ILG), &
  EVAPCG(ILG), EVAPG(ILG), EVAPCS(ILG), &
  EVPCSG(ILG), EVAPGS(ILG), TCANO(ILG), &
  TCANS(ILG), RAICAN(ILG), &
  SNOCAN(ILG), RAICNS(ILG), SNOCNS(ILG), &
  CWLCAP(ILG), CWFCAP(ILG), CWLCPS(ILG), &
  CWFCPS(ILG), TSNOCS(ILG), &
  TSNOGS(ILG), RHOSCS(ILG), RHOSGS(ILG), &
  WSNOCS(ILG), WSNOGS(ILG), TPONDC(ILG), &
  TPONDG(ILG), TPNDCS(ILG), &
  TPNDGS(ILG), ZPLMCS(ILG), ZPLMGS(ILG), &
  ZPLIMC(ILG), ZPLIMG(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'cross-CLASS'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    print 1118, 'Soil layers', IGND
    stop
END IF

!> BALANCE ERRORS (CLASS):
ALLOCATE (CTVSTP(ILG), CTSSTP(ILG), &
  CT1STP(ILG), &
  CT2STP(ILG), CT3STP(ILG), WTVSTP(ILG), &
  WTSSTP(ILG), WTGSTP(ILG), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'balance error diagnostic'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    stop
END IF

!> CTEM ERRORS (CLASS):
ALLOCATE (CO2CONC(ILG), COSZS(ILG), XDIFFUSC(ILG), CFLUXCG(ILG), CFLUXCS(ILG), &
 AILCG(ILG,ICTEM), AILCGS(ILG,ICTEM), FCANC(ILG,ICTEM), FCANCS(ILG,ICTEM), &
 CO2I1CG(ILG,ICTEM), CO2I1CS(ILG,ICTEM), CO2I2CG(ILG,ICTEM), CO2I2CS(ILG,ICTEM), &
 SLAI(ILG,ICTEM), FCANCMX(ILG,ICTEM), ANCSVEG(ILG,ICTEM), ANCGVEG(ILG,ICTEM), &
 RMLCSVEG(ILG,ICTEM), RMLCGVEG(ILG,ICTEM), &
 AILC(ILG,ICAN), PAIC(ILG,ICAN), FIELDSM(ILG,IGND), WILTSM(ILG,IGND), &
 RMATCTEM(ILG,ICTEM,IGND), RMATC(ILG,ICAN,IGND), NOL2PFTS(ICAN), STAT=PAS)
IF (PAS .NE. 0) THEN
    print 1114, 'CTEM'
    print 1118, 'Grid squares', NA
    print 1118, 'GRUs', NTYPE
    print 1118, 'Total tile elements', ILG
    print 1118, 'Canopy types', ICAN
    print 1118, 'Soil layers', IGND
    print 1118, 'CTEM flag', ICTEM
    stop
END IF
!>
!>*******************************************************************
!>
!> *********************************************************************
!>  Open additional output files
!> *********************************************************************
    if (ipid == 0 .and. BASINSWEOUTFLAG > 0) then
        open(85, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/basin_SCA_alldays.csv")
        open(86, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/basin_SWE_alldays.csv")
    end if !(BASINSWEOUTFLAG > 0) then

!> CLASS requires that each GRU for each grid square has its own parameter value,
!> for MESH the value read in from the parameter file is assumed to be valid for
!> all grid squares in the study area - Frank Seglenieks Aug 2007

!> bjd - This would be a good spot for setting pre-distributed values

DO I=2,NA
  DO M=1,NMTEST
    DO J=1, ICP1
      cp%FCANROW(I,M,J)=   cp%FCANROW(1,M,J)
      cp%LNZ0ROW(I,M,J)=   cp%LNZ0ROW(1,M,J)
      cp%ALVCROW(I,M,J)=   cp%ALVCROW(1,M,J)
      cp%ALICROW(I,M,J)=   cp%ALICROW(1,M,J)
    ENDDO

    DO J=1, ICAN
      cp%PAMXROW(I,M,J)=   cp%PAMXROW(1,M,J)
      cp%PAMNROW(I,M,J)=   cp%PAMNROW(1,M,J)
      cp%CMASROW(I,M,J)=   cp%CMASROW(1,M,J)
      cp%ROOTROW(I,M,J)=   cp%ROOTROW(1,M,J)
      cp%RSMNROW(I,M,J)=   cp%RSMNROW(1,M,J)
      cp%QA50ROW(I,M,J)=   cp%QA50ROW(1,M,J)
      cp%VPDAROW(I,M,J)=   cp%VPDAROW(1,M,J)
      cp%VPDBROW(I,M,J)=   cp%VPDBROW(1,M,J)
      cp%PSGAROW(I,M,J)=   cp%PSGAROW(1,M,J)
      cp%PSGBROW(I,M,J)=   cp%PSGBROW(1,M,J)
    ENDDO

    DO J=1,IGND
      cp%SANDROW(I,M,J)=   cp%SANDROW(1,M,J)
      cp%CLAYROW(I,M,J)=   cp%CLAYROW(1,M,J)
      cp%ORGMROW(I,M,J)=   cp%ORGMROW(1,M,J)
!> note333 see read_s_temperature_txt.f for more TBARROW information
      cp%TBARROW(I,M,J)=   cp%TBARROW(1,M,J)
!> note444 see read_s_moisture_txt.f for more THLQROW information
      cp%THLQROW(I,M,J)=   cp%THLQROW(1,M,J)
      cp%THICROW(I,M,J)=   cp%THICROW(1,M,J)
    ENDDO

    cp%TCANROW(I,M) =  cp%TCANROW(1,M)
    cp%TSNOROW(I,M) =  cp%TSNOROW(1,M)
    cp%DRNROW(I,M)  =  cp%DRNROW(1,M)
    cp%SDEPROW(I,M) =  cp%SDEPROW(1,M)
    cp%FAREROW(I,M) =  cp%FAREROW(1,M)
    cp%MANNROW(I,M) =  cp%MANNROW(1,M)
!> note, if drdn (drainage density) is provided from the Mesh_drainage_database.r2c
!> we give the same value for all the GRU that are in one cell    
    if (allocated(demslp) .eqv. .true.) then
		cp%XSLPROW(I,M) = demslp(I)
		if (i == 2) then
            cp%XSLPROW(I-1,M) = demslp(I-1)
        end if
    else
        cp%XSLPROW(I,M) = cp%XSLPROW(1,M)
    end if
    cp%XDROW(I,M)   =  cp%XDROW(1,M)
!> note, if drdn (drainage density) is provided from the Mesh_drainage_database.r2c
!> we give the same value for all the GRU that are in one cell
    if (allocated(drdn) .eqv. .true.) then
        if (i == 2) then
            cp%DDROW(I-1,M) = drdn(I-1)
        end if
        cp%DDROW(I,M) = drdn(I)
    else
        cp%DDROW(I,M) = cp%DDROW(1,M)
    end if
    WFSFROW(I,M)    =  WFSFROW(1,M)
    cp%KSROW(I,M)   =  cp%KSROW(1,M)
    cp%MIDROW(I,M)  =  cp%MIDROW(1,M)
    cp%TPNDROW(I,M) =  cp%TPNDROW(1,M)
    cp%ZPNDROW(I,M) =  cp%ZPNDROW(1,M)
    cp%RCANROW(I,M) =  cp%RCANROW(1,M)
    cp%SCANROW(I,M) =  cp%SCANROW(1,M)
    cp%SNOROW(I,M)  =  cp%SNOROW(1,M)
    cp%ALBSROW(I,M) =  cp%ALBSROW(1,M)
    cp%RHOSROW(I,M) =  cp%RHOSROW(1,M)
    cp%GROROW(I,M)  =  cp%GROROW(1,M)
  ENDDO  !DO M=1,NMTEST
ENDDO  !DO I=2,NA

!> *********************************************************************
!>  Open and read in values from MESH_input_reservoir.txt file
!> *********************************************************************

OPEN(UNIT=21,FILE='MESH_input_reservoir.txt',STATUS='OLD', action = 'read')
    READ(21,'(3I5)') WF_NORESV,WF_NREL,WF_KTR
WF_NORESV_CTRL=0

! allocate reservoir arrays
M_R=WF_NORESV
ALLOCATE (WF_IRES(M_R), WF_JRES(M_R), WF_RES(M_R), WF_R(M_R),WF_B1(M_R),WF_B2(M_R), &
  WF_QREL(M_R), WF_RESSTORE(M_R),WF_RESNAME(M_R))


IF( WF_NORESV>0 ) THEN
  DO I=1,WF_NORESV
! KCK Added to allow higher precision gauge sites    
    IF (LOCATIONFLAG == 1) THEN
      READ(21,'(2F7.1,2G10.3,25X,A12,I2)') I_G,J_G, &
        WF_B1(I),WF_B2(I),WF_RESNAME(I),WF_RES(I)
        WF_IRES(I) = NINT((I_G-YORIGIN*60.0)/GRDN)
        WF_JRES(I) = NINT((J_G-XORIGIN*60.0)/GRDE)
    ELSE

      READ(21,'(2I5,2G10.3,25X,A12,I2)') WF_IRES(I),WF_JRES(I), & 
        WF_B1(I),WF_B2(I),WF_RESNAME(I), WF_RES(I)
        WF_IRES(I)=INT((REAL(WF_IRES(I))-REAL(IYMIN))/GRDN+1.0) 
        WF_JRES(I)=INT((REAL(WF_JRES(I))-REAL(JXMIN))/GRDE+1.0)
    ENDIF
!> check if point is in watershed and in river reaches
    WF_R(I)=0
    DO J=1,NA
      IF( WF_IRES(I)==YYY(J).AND.WF_JRES(I)==XXX(J))THEN
        WF_R(I)=J
      ENDIF
    ENDDO
    IF(WF_R(I)==0) THEN
      PRINT *, 'Reservoir Station: ',I,' is not in the basin'
          PRINT *, 'Up/Down Coordinate: ', wf_ires(I), Iymin
          PRINT *, 'Left/Right Coordinate: ', wf_jres(I),jxmin
      STOP
    ENDIF
    IF(WF_IREACH(WF_R(I))/=I) THEN
      PRINT *, 'Reservoir Station: ',I, &
        ' is not in the correct reach'
          PRINT *, 'Up/Down Coordinate: ', wf_ires(I)
          PRINT *, 'Left/Right Coordinate: ', wf_jres(I)
          PRINT *, 'ireach value at station: ', wf_iy(I)
      STOP
        ENDIF
    IF( WF_B1(I)==0.0 ) THEN
      WF_NORESV_CTRL=WF_NORESV_CTRL+1
    ENDIF
  ENDDO
ENDIF
!> leave file open and read in the reservoir files when needed



!> *********************************************************************
!> Open and read in values from MESH_input_streamflow.txt file
!> *********************************************************************
OPEN(UNIT=22,FILE='MESH_input_streamflow.txt',STATUS='OLD', action = 'read')
READ(22,*)
READ(22,*) WF_NO,WF_NL,WF_MHRD,WF_KT, WF_START_YEAR,&
        WF_START_DAY,WF_START_HOUR


! Allocate variable based on value from streamflow file
M_S=WF_NO !todo M_S is same as WF_NO and could be removed.

Allocate (WF_IY(M_S),WF_JX(M_S), WF_S(M_S),WF_QHYD(M_S),WF_QHYD_AVG(M_S),WF_QHYD_CUM(M_S), &
    WF_QSYN(M_S),WF_QSYN_AVG(M_S),WF_QSYN_CUM(M_S),WF_GAGE(M_S))

DO I=1,WF_NO 
  IF (LOCATIONFLAG == 1) THEN
    READ(22,*) I_G, J_G, WF_GAGE(I)    !
    WF_IY(I) = NINT((I_G-YORIGIN*60.0)/GRDN)
    WF_JX(I) = NINT((J_G-XORIGIN*60.0)/GRDE)
  ELSE
    READ(22,*)WF_IY(I),WF_JX(I),WF_GAGE(I)
    WF_IY(I)=INT((REAL(WF_IY(I))-REAL(IYMIN))/GRDN+1.0)
    WF_JX(I)=INT((REAL(WF_JX(I))-REAL(JXMIN))/GRDE+1.0)
  ENDIF
ENDDO

DO I=1,WF_NO
  WF_S(I)=0
  DO J=1,NA
    IF( WF_JX(I)==xxx(J).AND.WF_IY(I)==yyy(J) ) THEN
      WF_S(I)=J
    ENDIF
  ENDDO
  IF(WF_S(I)==0) THEN
    PRINT *, 'STREAMFLOW GAUGE: ',I,' IS NOT IN THE BASIN'
        PRINT *, 'UP/DOWN', WF_IY(I),iymin,yyy(J),ycount
        PRINT *, 'LEFT/RIGHT', WF_JX(I),jxmin,xxx(J),xcount
    STOP
      ENDIF
!> ric     initialise smoothed variables
  wf_qsyn(I)=0.0
      WF_QSYN_AVG = 0.0
      wf_qhyd_avg(I)=0.0
      wf_qsyn_cum(I)=0.0
      wf_qhyd_cum(I)=0.0
ENDDO

!>MAM - The first stream flow record is used for flow initialization
READ(22,*,IOSTAT=IOS) (WF_QHYD(I),I=1,WF_NO)

      ! fixed streamflow start time bug. add in function to enable the
      ! correct start time. Feb2009 aliu.
         call Julian_Day_ID(WF_START_YEAR, WF_START_day, Jday_IND1)
         call Julian_Day_ID(YEAR_START, JDAY_START, Jday_IND2)
!          write (*,*) WF_START_YEAR, WF_START_day, Jday_IND1
             if (YEAR_START ==0) then
               jday_ind2=jday_ind1
             endif
         if (jday_ind2 < jday_ind1) then
         PRINT *, 'ERROR: Simulation start date too early, check ', &
          ' MESH_input_streamflow.txt, The start date in ', &
          ' MESH_input_run_options.ini may be out of range'
          stop
          endif
         jday_ind_strm=(jday_ind2-jday_ind1)*24/WF_KT
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !skip the unused streamflow records in streamflow.txt .

         DO J=1, jday_ind_strm                                        !
          READ(22,*,IOSTAT=IOS)                                       !
           IF (IOS < 0) THEN                                          !
             PRINT *, 'ERROR: end of file reached when reading ', &   !
             ' MESH_input_streamflow.txt, The start date in ', &      !
             ' MESH_input_run_options.ini may be out of range'        !
             STOP                                                     !
           ENDIF                                                      !
         enddo                                                        !
          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          PRINT *, 'Skipping',jday_ind_strm,'Registers in streamflow file'
!> leave unit open and read new streamflow each hour


!todo - verify that all checks are needed and in the right spot
!> *********************************************************************
!> Check to make sure input values are consistent
!> *********************************************************************
!> compare land classes in class.ini and drainage database files
IF(NTYPE/=NMTEST.AND.NTYPE>0) THEN
  PRINT *, 'land classes from MESH_parameters_CLASS.ini: ',NMTEST
  PRINT *, 'land classes from MESH_drainage_database.txt:', &
            NTYPE
  PRINT *, 'Please adjust these values.'
      STOP
    ENDIF

!> check that run points are in the basin and that there are no repeats

DO I=1, WF_NUM_POINTS
  IF(op%N_OUT(I)>NA) THEN
    PRINT *, 'No. of grids from MESH_drainage_database.txt:',NA
    PRINT *, 'out point ',i,' is: ',op%N_OUT(I)
    PRINT *, 'please adjust MESH_run_options.ini file'
    STOP
  ENDIF

  IF(I<WF_NUM_POINTS) THEN
    DO J=I+1,WF_NUM_POINTS
      IF(op%N_OUT(I)==op%N_OUT(J) .AND. op%II_OUT(I) == op%II_OUT(J)) THEN
        PRINT *, 'grid number ', op%N_OUT(i)
        PRINT *, 'is repeated in MESH_run_options.ini file'
        PRINT *, 'please adjust MESH_run_options.ini file'
        STOP
      ENDIF
    ENDDO
  ENDIF
  
ENDDO

!> *********************************************************************
!> Set some more intial values and clear accumulators
!> *********************************************************************

!> ASSIGN VALUES OF LAT/LONG TO EACH SQUARE:
!> NOTE FROM FRANK
!> I got the equations to determine the actual length of a 
!> degree of latitude and longitude from this paper, thank you 
!> Geoff Kite (I have attached it):
!> http://www.agu.org/pubs/crossref/1994/94WR00231.shtml
!> This chunk of code is a way to put the actual values of 
!> longitude and latitude for each cell in a large basin.  
!> The original CLASS code just put in the same value for each cell.  
!> The problem is that the class.ini file only has a single value 
!> of long and lat (as it was only designed for a point).  So in order 
!> to get the values across the basin I assumed that the single value 
!> from the class.ini file is in the centre of the basin and then use 
!> information from the watflow.shd file to figure out the long/lat 
!> varies across the basin.  However, the watflod.shd file only gives 
!> information in kilometers not degrees of long/lat so I had 
!> to use the formulas from the above paper to go between the two.
!
!> The only value of DEGLAT is the one read in from the class.ini file, 
!> after that Diana uses RADJGRD (the value of latitude in radians) so 
!> after DEGLAT is used to calculate RADJGRD is it no longer used.  This 
!> is how it was in the original CLASS code.

    !> Read an intial value for geothermal flux from file.
    if (GGEOFLAG == 1) then
!        if ((VARIABLEFILESFLAG == 1) .and. (fls%fl(7)%isInit)) then
!            open(fls%fl(7)%unit, file = trim(adjustl(fls%fl(7)%name)))
        iun = fls%fl(mfk%f18)%iun
        open(iun, &
             file = trim(adjustl(fls%fl(mfk%f18)%fn)), &
             action = 'read', &
             status = 'old', iostat = ios)
!        else
!            open(18, file = 'MESH_ggeo.ini', status = 'old')
!        end if
        read(iun, *) GGEOGRD(1)
        close(iun)
    else
        GGEOGRD(1) = 0.0
    end if

	do i = 1, NA

        !LATLENGTH = AL/1000.0/(111.136 - 0.5623*COS(2*(DEGLAT*PI/180.0)) + 0.0011*COS(4*(DEGLAT*PI/180.0)))
        !LONGLENGTH = AL/1000.0/(111.4172*COS((DEGLAT*PI/180.0)) - 0.094*COS(3*(DEGLAT*PI/180.0)) + 0.0002*COS(5*(DEGLAT*PI/180.0)))
        RADJGRD(I) = ((YORIGIN + YDELTA*YYY(I)) - YDELTA/2.0)*PI/180.0
        DLONGRD(I) = (XORIGIN + XDELTA*XXX(I)) - XDELTA/2.0
        cp%ZRFMGRD(I) = cp%ZRFMGRD(1)
        cp%ZRFHGRD(I) = cp%ZRFHGRD(1)
        cp%ZBLDGRD(I) = cp%ZBLDGRD(1)
        cp%GCGRD(i) = cp%GCGRD(1)
        Z0ORGRD(I) = 0.0
        GGEOGRD(I) = GGEOGRD(1)
        ZDMGRD(I) = 10.0
        ZDHGRD(I) = 2.0

	end do

!> adjust NAA to the be number of outlet squares, as currently it is the
!> number of squares with outlets into other squares in the basin, and
!> we want it to be the number of squares with outlets to outside the
!> basin.
!todo - look into the logic of this and suggest how it could be changed
NAA=NA-NAA

!> set initial values of ncount and nsum
! NCOUNT = which half-hour period the current time is:
! The first period (0:00-0:30) is #1, the last period (23:30-0:00) is #48
NCOUNT=HOUR_NOW*2+MINS_NOW/TIME_STEP_MINS+1
NSUM=1
NSUM_TOTAL=1

!> **********************************************************************
!>  Start of section to only run on squares that make up the watersheds
!>  that are listed in the streamflow file (subbasin)
!> **********************************************************************

IF(SUBBASINFLAG.GT.0) THEN

  DO I=1,NA
    SUBBASIN(I)=0
  ENDDO

!> Set values at guages to 1

DO I=1,WF_NO
  SUBBASIN(WF_S(I)) = 1
ENDDO

!> Set values of subbasin to 1 for all upstream grids

SUBBASINCOUNT=1

DO WHILE (SUBBASINCOUNT.GT.0) 

SUBBASINCOUNT=0

  DO I=1,NA-1
    IF(SUBBASIN( WF_NEXT(I) ).EQ.1.AND.SUBBASIN(I).EQ.0) THEN
      SUBBASIN(I)=1
      SUBBASINCOUNT=SUBBASINCOUNT+1
    ENDIF
  ENDDO

ENDDO  !DO WHILE (SUBBASINCOUNT.GT.0) 

!> Set values of frac to 0 for all grids non-upstream grids

SUBBASINCOUNT=0

  DO I=1,NA
    IF(SUBBASIN(I).EQ.0) THEN
      FRAC(I)=0
    ELSE
      SUBBASINCOUNT=SUBBASINCOUNT+1
    ENDIF
  ENDDO
  
  !> MAM - Write grid number, grid fractional area and percentage of GRUs in each grid
  
  OPEN(10,FILE='SUBBASIN_INFO.TXT',STATUS='UNKNOWN')
  WRITE(10,'(A7,3X,A18,3X,A58)')'GRID NO', 'GRID AREA FRACTION', 'GRU FRACTIONS, GRU 1, GRU 2, GRU 3,... IN INCREASING ORDER'
  DO I=1,NA
    IF(SUBBASIN(I).EQ.0) THEN
    ELSE
      WRITE(10,'(I5,3X,F10.3,8X,50(F10.3,3X))')I, FRAC(I),(ACLASS(I,M),M=1,NMTEST)
    ENDIF
  ENDDO
  CLOSE(10)

ENDIF


!> **********************************************************************
!>  End of subbasin section
!> **********************************************************************

!> Set value of FAREROW:
!todo - flag this as an issue to explore later and hide basin average code
!todo - document the problem
TOTAL_AREA = 0.0
DO I = 1, NA
    DO M = 1, NMTEST
        cp%FAREROW(I, M) = ACLASS(I, M)*FRAC(I)
        TOTAL_AREA = TOTAL_AREA + cp%FAREROW(I, M)
    !FUTUREDO: Bruce, FRAC is calculated by EnSim
    ! using Dan Princz's instructions for EnSim
    ! FRAC can be greater than 1.00
    ! So, we cannot use FAREROW in place of BASIN_FRACTION
    END DO
END DO

CALL GATPREP(ILMOS,JLMOS,IWMOS,JWMOS, &
             NML,NMW,cp%GCGRD,cp%FAREROW,cp%MIDROW, &
             NA,NTYPE,ILG,1,NA,NMTEST)

    !> Update basin information.
    bi%NML = NML
    bi%NMW = NMW
    allocate(bi%ILMOS(size(ILMOS)), bi%JLMOS(size(JLMOS)))
    bi%ILMOS = ILMOS
    bi%JLMOS = JLMOS

!> Initialize output variables.
call init_water_balance(wb, bi)
wb%grid_area = 0.0
wb%basin_area = 0.0
DO I = 1, NA
    DO M = 1, NMTEST
        wb%grid_area(i) = wb%grid_area(i) + cp%farerow(i, m)
    END DO
    wb%basin_area = wb%basin_area + wb%grid_area(i)
END DO

    call climate_module_init(bi, ts, cm, ENDDATA)
    if (ENDDATA) goto 999

!> *********************************************************************
!> Initialize water balance output fields
!> *********************************************************************

if (ipid == 0) then

    call init_energy_balance(eng, bi)
    call init_soil_statevars(sov, bi)
    call init_met_data(md, bi)
    call init_water_balance(wb_h, bi)

    if (OUTFIELDSFLAG == 1) call init_out(vr, ts, iof, bi)

end if !(ipid == 0) then

!> routing parameters
WF_ROUTETIMESTEP=900
WF_TIMECOUNT=0
DRIVERTIMESTEP=DELT    ! Be sure it's REAL*8

!* JAN: The first time throught he loop, jan=1. Jan will equal 2 after that.
    JAN=1

!todo - check that this is compatible with Saul's pre-distributed soil moisture and soil temp.
    do I = 1, NA
        do M = 1, NMTEST

            do J = 1, IGND
                cp%TBARROW(I,M,J) = cp%TBARROW(I,M,J) + TFREZ
            end do

            cp%TSNOROW(I,M) = cp%TSNOROW(I,M) + TFREZ
            cp%TCANROW(I,M) = cp%TCANROW(I,M) + TFREZ
            cp%TPNDROW(I,M) = cp%TPNDROW(I,M) + TFREZ
            TBASROW(I,M) = cp%TBARROW(I,M,IGND)
            CMAIROW(I,M) = 0.0
            WSNOROW(I,M) = 0.0
            TSFSROW(I,M,1) = TFREZ
            TSFSROW(I,M,2) = TFREZ
            TSFSROW(I,M,3) = cp%TBARROW(I,M,1)
            TSFSROW(I,M,4) = cp%TBARROW(I,M,1)
            TACROW(I,M) = cp%TCANROW(I,M)
            QACROW(I,M) = 0.5E-2

            if (IGND > 3) then ! should stay this way to work with class

                !todo - if we have time, change this so that soil.ini can take more than 3 layers.
                if (NRSOILAYEREADFLAG == 0) then

                    do J = 4, IGND
                        cp%THLQROW(I,M,J) = cp%THLQROW(I,M,3)
                        cp%THICROW(I,M,J) = cp%THICROW(I,M,3)
                        cp%TBARROW(I,M,J) = cp%TBARROW(I,M,3)
                        if (cp%SDEPROW(I,M) < (sl%ZBOT(J - 1) + 0.001) .and. cp%SANDROW(I,M,3) > -2.5) then
                            cp%SANDROW(I,M,J) = -3.0
                            cp%CLAYROW(I,M,J) = -3.0
                            cp%ORGMROW(I,M,J) = -3.0
                        else
                            cp%SANDROW(I,M,J) = cp%SANDROW(I,M,3)
                            cp%CLAYROW(I,M,J) = cp%CLAYROW(I,M,3)
                            cp%ORGMROW(I,M,J) = cp%ORGMROW(I,M,3)
                        end if
                    end do

                else
                    do J = 4, IGND
                        if (cp%SDEPROW(I,M) < (sl%ZBOT(J - 1) + 0.001) .and. cp%SANDROW(I,M,3) > -2.5) then
                            cp%SANDROW(I,M,J) = -3.0
                            cp%CLAYROW(I,M,J) = -3.0
                            cp%ORGMROW(I,M,J) = -3.0
                        end if
                    end do

                end if !if (NRSOILAYEREADFLAG == 0) then
            end if !(IGND > 3) then

            do K = 1, 6
                do L = 1, 50
                    ITCTROW(I,M,K,L) = 0
                end do
            end do

        end do !M = 1, NMTEST
    end do !I = 1, NA

!> clear accumulating variables
TOTAL_ROF=0.0
TOTAL_ROFO=0.0
TOTAL_ROFS=0.0
TOTAL_ROFB=0.0
TOTAL_EVAP=0.0
TOTAL_PRE=0.0
TOTAL_ROFACC=0.0
TOTAL_ROFOACC=0.0
TOTAL_ROFSACC=0.0
TOTAL_ROFBACC=0.0
TOTAL_EVAPACC=0.0
TOTAL_PREACC=0.0
TOTAL_HFSACC=0.0
TOTAL_QEVPACC=0.0

    ! For monthly totals.
    TOTAL_ROF_M = 0.0
    TOTAL_ROFO_M = 0.0
    TOTAL_ROFS_M = 0.0
    TOTAL_ROFB_M = 0.0
    TOTAL_EVAP_M = 0.0
    TOTAL_PRE_M = 0.0
    TOTAL_ROF_ACC_M = 0.0
    TOTAL_ROFO_ACC_M = 0.0
    TOTAL_ROFS_ACC_M = 0.0
    TOTAL_ROFB_ACC_M = 0.0
    TOTAL_EVAP_ACC_M = 0.0
    TOTAL_PRE_ACC_M = 0.0

!> *********************************************************************
!> Set accumulation variables to zero.
!> *********************************************************************

  !> Grid Variables
  PREACC = 0.
  GTACC = 0.
  QEVPACC = 0.
  EVAPACC = 0.
  HFSACC = 0.
  HMFNACC = 0.
  ROFACC = 0.
  ROFOACC = 0.
  ROFSACC = 0.
  ROFBACC = 0.
  WTBLACC = 0.
  ALVSACC = 0.
  ALIRACC = 0.
  RHOSACC = 0.
  SNOACC = 0.
  WSNOACC = 0.
  CANARE = 0.
  SNOARE = 0.
  TSNOACC = 0.
  TCANACC = 0.
  RCANACC = 0.
  SCANACC = 0.
  GROACC = 0.
  FSINACC = 0.
  FLINACC = 0.
  FLUTACC = 0.
  TAACC = 0.
  UVACC = 0.
  PRESACC = 0.
  QAACC = 0.

    !> Soil variables
    TBARACC = 0.
    THLQACC = 0.
    THICACC = 0.
    THALACC = 0.
    GFLXACC = 0.

STG_I    = 0.
DSTG     = 0.
THLQ_FLD = 0.
THIC_FLD = 0.

!> SET GRID-FORMAT WATROUTE OUTPUT           !
DO I = 1, YCOUNT                            !
  DO J = 1, XCOUNT                          !
      RUNOFF(I, J) = 0.0                    !
      RECHARGE(I, J) = 0.0                  !
      LEAKAGES(I, J) = 0.0
!> CDAN            LEAKAGE(I, J) = 0.0       !
   END DO                                   !
END DO                                      !

!>  SET FRAME COUNT FOR WRITE_R2C
FRAME_NO = 1
NO_FRAMES = FRAME_NO + 1
FRAME_NO_NEW = 1

!> ******************************************************
!> echo print information to MESH_output_echo_print.txt
!> ******************************************************

    if (ipid == 0 .and. MODELINFOOUTFLAG > 0) then

        open(58, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // &
            "/MESH_output_echo_print.txt")

        write(58, "('Number of Soil Layers (IGND) = ',I5)") ignd
        write(58, *)

        write(58, "('MESH_input_run_options.ini')")
        write(58, *)
        write(58, "('Configuration flags - specified by user or default values')")

        !todo: this list should be updated (dgp: 2015-01-09)
        write(58, *) "BASINSHORTWAVEFLAG   = ", cm%clin(cfk%FB)%filefmt
        write(58, *) "BASINLONGWAVEFLAG    = ", cm%clin(cfk%FI)%filefmt
        write(58, *) "BASINRAINFLAG        = ", cm%clin(cfk%PR)%filefmt
        write(58, *) "BASINTEMPERATUREFLAG = ", cm%clin(cfk%TT)%filefmt
        write(58, *) "BASINWINDFLAG        = ", cm%clin(cfk%UV)%filefmt
        write(58, *) "BASINPRESFLAG        = ", cm%clin(cfk%P0)%filefmt
        write(58, *) "BASINHUMIDITYFLAG    = ", cm%clin(cfk%HU)%filefmt
        write(58, *) "HOURLYFLAG           = ", HOURLYFLAG
        write(58, *) "RESUMEFLAG           = ", RESUMEFLAG
        write(58, *) "SAVERESUMEFLAG       = ", SAVERESUMEFLAG
        write(58, *) "SHDFILEFLAG          = ", SHDFILEFLAG
        write(58, *) "SOILINIFLAG          = ", SOILINIFLAG
        write(58, *) "STREAMFLOWFLAG       = ", STREAMFLOWFLAG
        write(58, *) "CONFLAGS             = ", CONFLAGS
        write(58, *) "RELFLG               = ", RELFLG
        write(58, *) "OPTFLAGS             = ", OPTFLAGS
        write(58, *) "PREEMPTIONFLAG       = ", mtsflg%PREEMPTIONFLAG
        write(58, *) "INTERPOLATIONFLAG    = ", INTERPOLATIONFLAG
        write(58, *) "SUBBASINFLAG         = ", SUBBASINFLAG
        write(58, *) "TESTCSVFLAG          = ", 'NOTSUPPORTED'
        write(58, *) "R2COUTPUTFLAG        = ", R2COUTPUTFLAG
        write(58, *) "OBJFNFLAG            = ", OBJFNFLAG
        write(58, *) "AUTOCALIBRATIONFLAG  = ", mtsflg%AUTOCALIBRATIONFLAG
        write(58, *) "WINDOWSIZEFLAG       = ", WINDOWSIZEFLAG
        write(58, *) "WINDOWSPACINGFLAG    = ", WINDOWSPACINGFLAG
        write(58, *) "FROZENSOILINFILFLAG  = ", FROZENSOILINFILFLAG
        write(58, *) "LOCATIONFLAG         = ", LOCATIONFLAG

        !> MAM - ALLOCATE AND INITIALIZE INTERPOLATION VARIABLES:
        !> For 30 minute forcing data there is no need for interpolation and
        !> hence no need to assign PRE and PST variables
        if (INTERPOLATIONFLAG > 1 .or. (INTERPOLATIONFLAG == 1 .and. sum(cm%clin(:)%hf) == 210)) then
            print 9000
            write(58, 9000)
            INTERPOLATIONFLAG = 0
        end if !(INTERPOLATIONFLAG > 1 .or. (INTERPOLATIONFLAG == 1 .and. sum(cm%clin(:)%hf) == 210)) then

        write(58, "('WF_NUM_POINTS: ',I5)") WF_NUM_POINTS
        write(58, "('Out directory:',5A10)") (op%DIR_OUT(i), i = 1, WF_NUM_POINTS)
        write(58, "('Grid number:  ',5I10)") (op%N_OUT(i), i = 1, WF_NUM_POINTS)
        write(58, "('Land class:   ',5I10)") (op%II_OUT(i), i = 1, WF_NUM_POINTS)
        write(58, *)

        write(58, "('MESH_parameters_hydrology.ini')")
        write(58, *)
        write(58, "('Option flags:')")
        if (OPTFLAGS > 0) then
            do i = 1, OPTFLAGS
                write(58, '(a11,i2,a19)') "PARAMETER ", i, " NOT CURRENTLY USED"
            end do
        end if

        write(58, "('River roughnesses:')")
        write(58, "(5F6.3)") (WF_R2(i), i = 1, 5)

        write(58, "('Land class independent hydrologic parameters:')")
        if (FROZENSOILINFILFLAG == 1) then
            write(58, *) "SOIL_POR_MAX = ", SOIL_POR_MAX
            write(58, *) "SOIL_DEPTH   = ", SOIL_DEPTH
            write(58, *) "S0           = ", S0
            write(58, *) "T_ICE_LENS   = ", T_ICE_LENS
            do i = 5, INDEPPAR
                j = i - 4
                write(58, '(a38,i2,a3,f6.2)') "OPPORTUNITY TIME FOR SIMULATION YEAR ", j, " = ", t0_ACC(j)
            end do
        else
            do i = 1, INDEPPAR
                write(58, '(a36,i2,a19)') "FROZEN SOIL INFILTRATION PARAMETER ", i, " READ BUT NOT USED"
            end do
        end if !(FROZENSOILINFILFLAG == 1) then

        write(58, "('Land class dependent hydrologic parameters:')")
        write(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZSNLROW'", NMTEST
        write(58, NMTESTFORMAT) (hp%ZSNLROW(1, m), m = 1, NMTEST)
        write(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZPLSROW'", NMTEST
        write(58, NMTESTFORMAT) (hp%ZPLSROW(1, m), m = 1, NMTEST)
        write(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('ZPLGROW'", NMTEST
        write(58, NMTESTFORMAT) (hp%ZPLGROW(1, m), m = 1, NMTEST)
        if (DEPPAR >= 4) then
            write(NMTESTFORMAT, "(A10,I3,'F10.2)')") "('FRZCROW'", NMTEST
            write(58, NMTESTFORMAT) (hp%FRZCROW(1, m), m = 1, NMTEST)
        end if
        write(58, *)

        write(58, "('MESH_parameters_CLASS.ini')")
        write(58, *)
        write(58, '(2X,6A4)') TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6
        write(58, '(2X,6A4)') NAME1, NAME2, NAME3, NAME4, NAME5, NAME6
        write(58, '(2X,6A4)') PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6
        i=1
        write(58, '(5F10.2,F7.1,3I5)') &
            DEGLAT, DEGLON, cp%ZRFMGRD(i), cp%ZRFHGRD(i), cp%ZBLDGRD(i), cp%GCGRD(i), ILW, NA, NMTEST
        do m = 1, NMTEST
            write(58, '(9F8.3)') (cp%FCANROW(i, m, j), j = 1, ICAN + 1), (cp%PAMXROW(i, m, j), j = 1, ICAN)
            write(58, '(9F8.3)') (cp%LNZ0ROW(i, m, j), j = 1, ICAN + 1), (cp%PAMNROW(i, m, j), j = 1, ICAN)
            write(58, '(9F8.3)') (cp%ALVCROW(i, m, j), j = 1, ICAN + 1), (cp%CMASROW(i, m, j), j = 1, ICAN)
            write(58, '(9F8.3)') (cp%ALICROW(i, m, j), j = 1, ICAN + 1), (cp%ROOTROW(i, m, j), j = 1, ICAN)
            write(58, '(4F8.3,8X,4F8.3)') (cp%RSMNROW(i, m, j), j = 1, ICAN), (cp%QA50ROW(i, m, j), j = 1, ICAN)
            write(58, '(4F8.3,8X,4F8.3)') (cp%VPDAROW(i, m, j), j = 1, ICAN), (cp%VPDBROW(i, m, j), j = 1, ICAN)
            write(58, '(4F8.3,8X,4F8.3)') (cp%PSGAROW(i, m, j), j = 1, ICAN), (cp%PSGBROW(i, m, j), j = 1, ICAN)
            write(58, '(3F8.3,F8.4)') cp%DRNROW(i, m), cp%SDEPROW(i, m), cp%FAREROW(i, m), cp%DDROW(i, m)
            write(58, '(4E8.1,I8)') cp%XSLPROW(i, m), cp%XDROW(i, m), cp%MANNROW(i, m), cp%KSROW(i, m), cp%MIDROW(i, m)
            write(58, '(6F10.1)') (cp%SANDROW(i, m, j), j = 1, IGND)
            write(58, '(6F10.1)') (cp%CLAYROW(i, m, j), j = 1, IGND)
            write(58, '(6F10.1)') (cp%ORGMROW(i, m, j), j = 1, IGND)
            write(58, '(9F10.2)') (cp%TBARROW(i, m, j), j = 1, IGND), cp%TCANROW(i, m), cp%TSNOROW(i, m), cp%TPNDROW(i, m)
            write(58, '(10F10.3)') (cp%THLQROW(i, m, j), j = 1, IGND), (cp%THICROW(i, m, j), j = 1, IGND), cp%ZPNDROW(i, m)
            write(58, '(2F10.4,F10.2,F10.3,F10.4,F10.3,F10.3)') &
                cp%RCANROW(i, m), cp%SCANROW(i, m), cp%SNOROW(i, m), cp%ALBSROW(i, m), cp%RHOSROW(i, m), cp%GROROW(i, m)
            write(58, *)
        end do !m = 1, NMTEST
    end if !(MODELINFOOUTFLAG > 0) then

    ALLOCATE(INFILTYPE(ILG),SI(ILG),TSI(ILG), &
             SNOWMELTD(ILG),SNOWMELTD_LAST(ILG),SNOWINFIL(ILG),&
             CUMSNOWINFILCS(ILG),MELTRUNOFF(ILG), CUMSNOWINFILGS(ILG))
             
             NMELT         = 1
             INFILTYPE     = 2     !> INITIALIZED WITH UNLIMITED INFILTRATION
             SNOWMELTD     = 0.0
             SNOWINFIL     = 0.0
             CUMSNOWINFILCS  = 0.0
             CUMSNOWINFILGS = 0.0
             MELTRUNOFF    = 0.0
             SI            = 0.20
             TSI           = -0.10
!* PDMROF
    ALLOCATE(CMINPDM(ILG),   CMAXPDM(ILG),   BPDM(ILG),      K1PDM(ILG),     &
             K2PDM(ILG),     ZPNDPRECS(ILG), ZPONDPREC(ILG), ZPONDPREG(ILG), &
             ZPNDPREGS(ILG),                                                 &
             UM1CS    (ILG), UM1C    (ILG),  UM1G    (ILG),  UM1GS    (ILG), &
             QM1CS    (ILG), QM1C    (ILG),  QM1G    (ILG),  QM1GS    (ILG), &
             QM2CS    (ILG), QM2C    (ILG),  QM2G    (ILG),  QM2GS    (ILG), &
             UMQ      (ILG),                                                 &
             FSTRCS   (ILG), FSTRC   (ILG),  FSTRG   (ILG),  FSTRGS   (ILG))

!* PDMROF: INITIALIZE VARIABLES
ZPNDPRECS = 0.0
ZPONDPREC = 0.0
ZPONDPREG = 0.0
ZPNDPREGS = 0.0
ZPND      = 0.0
UM1CS     = 0.0
UM1C      = 0.0
UM1G      = 0.0
UM1GS     = 0.0
QM1CS     = 0.0
QM1C      = 0.0
QM1G      = 0.0
QM1GS     = 0.0
QM2CS     = 0.0
QM2C      = 0.0
QM2G      = 0.0
QM2GS     = 0.0
UMQ       = 0.0
FSTRCS    = 0.0
FSTRC     = 0.0
FSTRG     = 0.0
FSTRGS    = 0.0
FSTR      = 0.0
!>
!>****************CHECK RESUME FILE***************************************************
!>
IF (RESUMEFLAG == 1 ) THEN
  OPEN(88,FILE="class_resume.txt", STATUS="UNKNOWN", IOSTAT=IOS, action = 'read')
  IF (IOS /= 0) THEN
    if (ipid == 0 .and. MODELINFOOUTFLAG > 0) then
        write(58, *), "WARNING: You've specified a start time", &
            " without having a resume file. Now ending run."
    end if

    PRINT*, "No class_resume.txt found."
    PRINT*, "The RESUMEFLAG in MESH_input_run_options.ini is", &
      " set to 1, which means that class_resume.txt should be here,", &
      " but it is not here."
    PRINT*,"Ending Run"
    STOP
  END IF
  CLOSE (UNIT=88)
END IF
!>
!> *******************************************************************
!> FOR SPL WATROUTE (MODIFIED RPN CODE)
!> *******************************************************************
!>

if (ipid == 0) then

!> R2C-FORMAT OUTPUT FILES (RUNOFF, RECHARGE, AND LEAKAGES VALUES)
!> CALL WRITE_R2C TO WRITE R2C-FORMAT FILES
!>
!> IF (MODELFLG .EQ. "i") AUTHOR="MESH_DRIVER (rte -i)"
!>   Requires _RFF (RUNOFF) file
!> IF (MODELFLG .EQ. "r") AUTHOR="MESH_DRIVER (rte -r)"
!>   Requires _RFF (RUNOFF) &
!>            _RCH (RECHARGE) files
!> IF (MODELFLG .EQ. "l") AUTHOR="MESH_DRIVER (rte -l)"
!>   Requires _RFF (RUNOFF) &
!>            _LKG (LEAKAGE) files (not currently supported)
!>
!> HEADER INFORMATION
!>
AUTHOR = "MESH_DRIVER"
COORDSYS_TEMP = COORDSYS1
ZONE_TEMP = ZONE1
DATUM_TEMP = DATUM1
XORIGIN_TEMP = XORIGIN
YORIGIN_TEMP = YORIGIN
XCOUNT_TEMP = XCOUNT
YCOUNT_TEMP = YCOUNT
XDELTA_TEMP = XDELTA
YDELTA_TEMP = YDELTA
SOURCE_FILE_NAME = "CLASS"
!>
!> OPEN RTE.EXE INPUT FILES (UNIT 261, UNIT 262)
!> (RTE.EXE MIGHT ALSO BE CALLED WATROUTE.EXE)
!> UNIT NUMBERS HAVE BEEN PULLED FROM RTE.EXE SUBROUTINES, THEIR
!> FILE NAMES (FLN(31), FLN(32)) ARE READ FROM THE EVENT FILE
!> FILES ARE OPENED ACCORDING TO MODELFLG IN THE EVENT FILE
!>
!> RUNOFF (MODELFLG .EQ. 'r', 'l', or 'i' (ALL))
!>
IF (PRINTRFFR2CFILEFLAG == 1) THEN
  NAME = "Gridded Channel Inflow"
  ATTRIBUTE_NAME = "channel_inflow"
  ATTRIBUTE_UNITS = "mm"
  ATTRIBUTE_TYPE = "flow"
  CALL WRITE_R2C(261,31,0,1,0,1,1, &
                 EF_YEAR_NOW, EF_MONTH_NOW, EF_DAY_NOW, EF_HOUR_NOW)
END IF
!>
!> RECHARGE (MODELFLG .EQ. 'r')
!>
IF (PRINTRCHR2CFILEFLAG == 1) THEN
  NAME = "Gridded Recharge"
  ATTRIBUTE_NAME = "recharge"
  ATTRIBUTE_UNITS = "mm"
  ATTRIBUTE_TYPE = "flow"
  CALL WRITE_R2C(262,32,0,1,0,1,1, &
                 EF_YEAR_NOW, EF_MONTH_NOW, EF_DAY_NOW, EF_HOUR_NOW)
END IF
!>
!> LEAKAGE (MODELFLG .EQ. 'l' (NOT SUPPORTED))
!>
!!+IF (PRINTLKGR2CFILEFLAG == 1) THEN
!!+  NAME = "Gridded Leakage"
!!+  ATTRIBUTE_NAME = "leakage"
!!+  ATTRIBUTE_UNITS = "cms"
!!+  ATTRIBUTE_TYPE = " "
!!+  CALL WRITE_R2C(263,33,0,1,0,1,1)
!!+END IF

end if !(ipid == 0) then

!> *********************************************************************
!> Open and print header information to the output files
!> *********************************************************************

if (ipid == 0) then

    !> Streamflow output files.
    if (STREAMFLOWOUTFLAG > 0) then

        !> Daily streamflow file.
!        if ((VARIABLEFILESFLAG .eq. 1) .and. (fls%fl(6)%isInit)) then
        open(fls%fl(mfk%f70)%iun, &
!todo: This creates a bug if a space doesn't exist in the name of the folder!
             file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/' // trim(adjustl(fls%fl(mfk%f70)%fn)), &
             iostat = ios)
!        else
!            open(70, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/MESH_output_streamflow.csv")
!        end if

        !> Hourly and cumulative daily streamflow files.
        if (STREAMFLOWOUTFLAG >= 2) then
            open(71, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/MESH_output_streamflow_all.csv")
            open(72, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/MESH_output_streamflow_cumulative.csv")
        end if

    end if !(STREAMFLOWOUTFLAG > 0) then

!> *********************************************************************
!> Open and read in values from r2c_output.txt file
!> *********************************************************************
NR2CFILES = 0
IF(R2COUTPUTFLAG .GE. 1)THEN
   INQUIRE(FILE='r2c_output.txt', EXIST = R2COUTPUT)
   IF(R2COUTPUT)THEN
      OPEN(56, FILE = 'r2c_output.txt', action = 'read')
      READ(56,*,IOSTAT=IOS)NR2C,DELTR2C
      IF(IOS == 0)THEN
         ALLOCATE(GRD(NR2C),GAT(NR2C),GRDGAT(NR2C),R2C_ATTRIBUTES(NR2C,3),STAT=PAS)
         IF(PAS /= 0)THEN
           PRINT*,'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                  'RECORD AT THE FIRST LINE IN THE r2c_output.txt FILE. ', &
                  'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
           STOP
         ENDIF
      ENDIF
      IF(IOS /= 0 .OR. MOD(DELTR2C,30) /= 0)THEN
            print 9002
            stop
      ENDIF

      PRINT*
      PRINT*,'THE FOLLOWING R2C OUTPUT FILES WILL BE WRITTEN:'

      DO I = 1, NR2C
          READ(56,*,IOSTAT = IOS)GRD(I),GAT(I),GRDGAT(I),(R2C_ATTRIBUTES(I,J),J=1,3)
          IF(IOS /= 0)THEN
             PRINT*,'ERROR READING r2c_output.txt FILE AT LINE ', I + 1
             STOP
         ELSE
           IF(GRD(I)==1)THEN
              NR2CFILES = NR2CFILES + 1
              PRINT*,NR2CFILES,' (GRD)    : ',R2C_ATTRIBUTES(I,3)
           ENDIF
           IF(GAT(I)==1)THEN
              NR2CFILES = NR2CFILES + 1
              PRINT*,NR2CFILES,' (GAT)    : ',R2C_ATTRIBUTES(I,3)
           ENDIF
           IF(GRDGAT(I)==1)THEN
              NR2CFILES = NR2CFILES + 1
              PRINT*,NR2CFILES,' (GRDGAT) : ',R2C_ATTRIBUTES(I,3)
           ENDIF

         ENDIF
      ENDDO
      CLOSE(56)
   ELSE
      PRINT*
      PRINT*,"r2c_output.txt FILE DOESN'T EXIST. ", &
             "R2COUTPUTFLAG SHOULD BE SET TO ZERO IF R2C OUTPUTS ARE NOT NEEDED."
      PRINT*
      STOP
   ENDIF
ENDIF

!> WRITE THE HEADER FOR R2C FILES:

IF(NR2CFILES > 0)THEN
 CALL WRITE_R2C_HEADER(NMTEST,NR2C,NR2CFILES,GRD,GAT,GRDGAT,R2C_ATTRIBUTES, &
                       R2CFILEUNITSTART,NR2CSTATES,coordsys1,datum1,zone1,   &
                       XORIGIN,YORIGIN,XDELTA,YDELTA,XCOUNT,YCOUNT)
ENDIF

!> For the ENSIM timestamp
wfo_seq=0

end if !(ipid == 0) then

!> End of ENSIM Changes

!> *********************************************************************
!> Output information to screen
!> *********************************************************************

if (ro%VERBOSEMODE > 0) then

PRINT *, 'NUMBER OF GRID SQUARES: ',NA
    PRINT *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NMTEST
    PRINT *, 'NUMBER OF RIVER CLASSES: ', NRVR
    PRINT *, 'MINIMUM NUMBER FOR ILG: ',NA*NMTEST
PRINT *, 'NUMBER OF GRID SQUARES IN West-East DIRECTION: ', XCOUNT
PRINT *, 'NUMBER OF GRID SQUARES IN South-North DIRECTION: ', YCOUNT
PRINT *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', AL
    PRINT *, 'NUMBER OF DRAINAGE OUTLETS: ', NAA

    PRINT *, 'NUMBER OF STREAMFLOW GUAGES: ', WF_NO
DO I=1,WF_NO
  PRINT *,'STREAMFLOW STATION: ',I,'I: ',WF_IY(I),'J: ',WF_JX(I)
ENDDO
PRINT *, 'NUMBER OF RESERVOIR STATIONS: ', WF_NORESV
IF( WF_NORESV>0 ) THEN
  DO I=1,WF_NORESV
 PRINT *,'RESERVOIR STATION: ',I,'I: ',WF_IRES(I),'J: ',WF_JRES(I)
  ENDDO
ENDIF


PRINT *
PRINT *, 'Found these output locations:'
PRINT *, 'Output Directory, grid number, land class number'
DO I=1, WF_NUM_POINTS
  PRINT *, op%DIR_OUT(I),op%N_OUT(I),op%II_OUT(I)
ENDDO

PRINT *
PRINT *
PRINT *

end if !(ro%VERBOSEMODE > 0) then

    if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_init(ts, wf_no)

!>
!>*******************************************************************
!>
!> Check if we are reading in a resume file
IF (RESUMEFLAG == 1) THEN
  PRINT *, 'Reading saved state variables'
call resume_state( &
   HOURLYFLAG, MINS_NOW, TIME_STEP_NOW, &
   cm%clin(cfk%FB)%filefmt, cm%clin(cfk%FI)%filefmt, &
   cm%clin(cfk%PR)%filefmt, cm%clin(cfk%TT)%filefmt, &
   cm%clin(cfk%UV)%filefmt, cm%clin(cfk%P0)%filefmt, cm%clin(cfk%HU)%filefmt, &
   cm%clin(cfk%FB)%climvGrd, FSVHGRD, FSIHGRD, cm%clin(cfk%FI)%climvGrd, &
   I, J, XCOUNT, YCOUNT, jan, &
   VPDGRD, TADPGRD, PADRGRD, RHOAGRD, RHSIGRD, &
   RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, cm%clin(cfk%TT)%climvGrd, &
   cm%clin(cfk%HU)%climvGrd, cm%clin(cfk%PR)%climvGrd, RPREGRD, SPREGRD, cm%clin(cfk%P0)%climvGrd, &

!> MAM - FOR FORCING DATA INTERPOLATION
   FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
   TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &
   IPCP, NA, NA, ILMOS, JLMOS, IWMOS, JWMOS, &
   NML, NMW, &
   cp%GCGRD, cp%FAREROW, cp%MIDROW, NTYPE, ILG, NMTEST, &
   TBARGAT, THLQGAT, THICGAT, TPNDGAT, ZPNDGAT, &
   TBASGAT, ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, &
   TCANGAT, RCANGAT, SCANGAT, GROGAT, FRZCGAT, CMAIGAT, &
   FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
   PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
   VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
   HGTDGAT, ACVDGAT, ACIDGAT, TSFSGAT, WSNOGAT, &
   THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
   GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
   PSIWGAT, DLZWGAT, ZBTWGAT, ZSNLGAT, ZPLGGAT, &
   ZPLSGAT, TACGAT, QACGAT, DRNGAT, XSLPGAT, &
   XDGAT, WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, &
   ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ISNDGAT, &
   RADJGAT, ZBLDGAT, Z0ORGAT, ZRFMGAT, ZRFHGAT, &
   ZDMGAT, ZDHGAT, FSVHGAT, FSIHGAT, CSZGAT, &
   FDLGAT, ULGAT, VLGAT, TAGAT, QAGAT, PRESGAT, &
   PREGAT, PADRGAT, VPDGAT, TADPGAT, RHOAGAT, &
   RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
   FCLOGAT, DLONGAT, GGEOGAT, CDHGAT, CDMGAT, &
   HFSGAT, TFXGAT, QEVPGAT, QFSGAT, QFXGAT, &
   PETGAT, GAGAT, EFGAT, GTGAT, QGGAT, &
   ALVSGAT, ALIRGAT, SFCTGAT, SFCUGAT, SFCVGAT, &
   SFCQGAT, FSNOGAT, FSGVGAT, FSGSGAT, FSGGGAT, &
   FLGVGAT, FLGSGAT, FLGGGAT, HFSCGAT, HFSSGAT, &
   HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, HMFCGAT, &
   HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, &
   PCPNGAT, PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, &
   QFCFGAT, ROFGAT, ROFOGAT, ROFSGAT, ROFBGAT, &
   TROFGAT, TROOGAT, TROSGAT, TROBGAT, ROFCGAT, &
   ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, WTRGGAT, &
   DRGAT, HMFGGAT, HTCGAT, QFCGAT, ITCTGAT, &
   IGND, ICAN, ICP1, &
   cp%TBARROW, cp%THLQROW, cp%THICROW, cp%TPNDROW, cp%ZPNDROW, &
   TBASROW, cp%ALBSROW, cp%TSNOROW, cp%RHOSROW, cp%SNOROW, &
   cp%TCANROW, cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, &
   cp%FCANROW, cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
   cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, cp%QA50ROW, &
   cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, cp%PSGBROW, PAIDROW, &
   HGTDROW, ACVDROW, ACIDROW, TSFSROW, WSNOROW, &
   THPROW, THRROW, THMROW, BIROW, PSISROW, &
   GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
   PSIWROW, DLZWROW, ZBTWROW, hp%ZSNLROW, hp%ZPLGROW, &
   hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, cp%DRNROW, cp%XSLPROW, &
   cp%XDROW, WFSFROW, cp%KSROW, ALGWROW, ALGDROW, &
   ASVDROW, ASIDROW, AGVDROW, AGIDROW, &
   ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
   cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, CSZGRD, &
   cm%clin(cfk%UV)%climvGrd, VLGRD, FCLOGRD, DLONGRD, GGEOGRD, &
   cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
   IGDRROW, IGDRGAT, VMODGRD, VMODGAT, QLWOGAT, &
   CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
   WTVSTP, WTSSTP, WTGSTP, &
   sl%DELZ, FCS, FGS, FC, FG, N, &
   ALVSCN, ALIRCN, ALVSG, ALIRG, ALVSCS, &
   ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, &
   ALVSSC, ALIRSC, TRVSCN, TRIRCN, TRVSCS, &
   TRIRCS, FSVF, FSVFS, &
   RAICAN, RAICNS, SNOCAN, SNOCNS, &
   FRAINC, FSNOWC, FRAICS, FSNOCS, &
   DISP, DISPS, ZOMLNC, ZOMLCS, ZOELNC, ZOELCS, &
   ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
   CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, &
   CWFCAP, CWLCPS, CWFCPS, RC, RCS, RBCOEF, &
   FROOT, ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, &
   TRSNOW, ZSNOW, JDAY_NOW, JLAT, IDISP, &
   IZREF, IWF, IPAI, IHGT, IALC, IALS, IALG, &
   TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
   THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, &
   TCTOPG, TCBOTG, &
   GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
   G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
   QFREZC, QFREZG, QMELTC, QMELTG, &
   EVAPC, EVAPCG,EVAPG, EVAPCS, EVPCSG, EVAPGS, &
   TCANO, TCANS, TPONDC, TPONDG, TPNDCS, TPNDGS, &
   TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
   WTABGAT, &
   ILMOGAT, UEGAT, HBLGAT, &
   ILW, ITC, ITCG, ITG, ISLFD, &
   NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
   GFLXGAT, CDHROW, CDMROW, HFSROW, TFXROW, &
   QEVPROW, QFSROW, QFXROW, PETROW, GAROW, &
   EFROW, GTROW, QGROW, TSFROW, ALVSROW, &
   ALIRROW, SFCTROW, SFCUROW, SFCVROW, SFCQROW, &
   FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
   FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, &
   HEVSROW, HEVGROW, HMFCROW, HMFNROW, HTCCROW, &
   HTCSROW, PCFCROW, PCLCROW, PCPNROW, PCPGROW, &
   QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, &
   ROFOROW, ROFSROW, ROFBROW, TROFROW, TROOROW, &
   TROSROW, TROBROW, ROFCROW, ROFNROW, ROVGROW, &
   WTRCROW, WTRSROW, WTRGROW, DRROW, WTABROW, &
   ILMOROW, UEROW, HBLROW, HMFGROW, HTCROW, &
   QFCROW, FSNOROW, ITCTROW, NCOUNT, ireport, &
   wfo_seq, YEAR_NOW, ensim_MONTH, ensim_DAY, &
   HOUR_NOW, XXX, YYY, NA, &
   NTYPE, DELT, TFREZ, UVGRD, SBC, RHOW, CURREC, &
   M_C, M_S, M_R, &

     WF_ROUTETIMESTEP,WF_R1,WF_R2,NAA,IYMIN, &
     WF_IYMAX,JXMIN,WF_JXMAX,WF_IBN,WF_IROUGH, &
     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE, &
     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE,WF_ELEV,FRAC, &
     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX, &
     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R, &
     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME, &
     WF_B1,WF_B2,WF_QREL, WF_QR, &
     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2, &
     WF_STORE1,WF_STORE2, &
     DRIVERTIMESTEP,ROFGRD, &
     WF_S, &

  TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
  FINAL_STORE, TOTAL_AREA, TOTAL_HFSACC, TOTAL_QEVPACC, &
  SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS,NMELT,t0_ACC, &
  CO2CONC, COSZS, XDIFFUSC, CFLUXCG, CFLUXCS, &
  AILCG, AILCGS, FCANC, FCANCS, CO2I1CG, CO2I1CS, CO2I2CG, CO2I2CS, &
  SLAI, FCANCMX, ANCSVEG, ANCGVEG, RMLCSVEG, RMLCGVEG, &
  AILC, PAIC, FIELDSM,  WILTSM, &
  RMATCTEM, RMATC, NOL2PFTS, ICTEMMOD, L2MAX, ICTEM, &
  hp%fetchROW,hp%HtROW,hp%N_SROW,hp%A_SROW,hp%DistribROW, &
  fetchGAT,HtGAT,N_SGAT,A_SGAT,DistribGAT)
ENDIF! IF (RESUMEFLAG == 1) THEN

!>
!>*******************************************************************
!>
!> Check if we are reading in a resume_state.r2c file
IF (RESUMEFLAG == 2) THEN
  PRINT *, 'Reading saved state variables'

! Allocate arrays for resume_state_r2c
      OPEN(54, FILE = 'resume_state_r2c.txt', action = 'read')
      READ(54,*,IOSTAT=IOS)NR2C_R,DELTR2C_R
      IF(IOS == 0)THEN
         ALLOCATE(GRD_R(NR2C_R),GAT_R(NR2C_R),GRDGAT_R(NR2C_R),R2C_ATTRIBUTES_R(NR2C_R,3),STAT=PAS)
         IF(PAS /= 0)THEN
           PRINT*,'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                  'RECORD AT THE FIRST LINE IN THE resume_state_r2c.txt FILE. ', &
                  'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
           STOP
         ENDIF
      ENDIF
      CLOSE(54)

! start by gathering from ROW to GAT so as not to mess-up with CLASSS after call to save_state_r2c
CALL CLASSG (TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
             TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT, &
             TCANGAT,RCANGAT,SCANGAT,GROGAT, FRZCGAT, CMAIGAT, &
             FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT, &
             PAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT, &
             VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,PAIDGAT, &
             HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT, &
             THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT, &
             GRKSGAT,THRAGAT,HCPSGAT,TCSGAT, IGDRGAT, &
             THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT, VMODGAT,&
             ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT, &
             DRNGAT, XSLPGAT,XDGAT,WFSFGAT,KSGAT, &
             ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT, &
             AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT, &
             ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT, &
             FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT, &
             TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT, &
             VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT, &
             SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT, &
             GGEOGAT, &
             CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
             QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT, &
             GTGAT,  QGGAT,  ALVSGAT,ALIRGAT, &
             SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT, &
             FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
             FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
             HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
             HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
             QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT, &
             ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
             TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
             WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  GFLXGAT, &
             HMFGGAT,HTCGAT, QFCGAT, ITCTGAT, &
!BEGIN: PDMROF
             CMINPDM,CMAXPDM,BPDM,   K1PDM,  K2PDM,      &
!END: PDMROF
             ILMOS,JLMOS,IWMOS,JWMOS,NML,NA,NTYPE, &
             NA*NTYPE,IGND,ICAN,ICP1,cp%TBARROW,cp%THLQROW, &
             cp%THICROW,cp%TPNDROW,cp%ZPNDROW,TBASROW,cp%ALBSROW, &
             cp%TSNOROW,cp%RHOSROW,cp%SNOROW,cp%TCANROW, &
             cp%RCANROW,cp%SCANROW,cp%GROROW, CMAIROW,cp%FCANROW, &
             cp%LNZ0ROW,cp%ALVCROW,cp%ALICROW,cp%PAMXROW, &
             cp%PAMNROW,cp%CMASROW,cp%ROOTROW,cp%RSMNROW, &
             cp%QA50ROW,cp%VPDAROW,cp%VPDBROW,cp%PSGAROW, &
             cp%PSGBROW,PAIDROW,HGTDROW,ACVDROW,ACIDROW,TSFSROW, &
             WSNOROW, THPROW, THRROW, THMROW, BIROW,  PSISROW, &
             GRKSROW,THRAROW,HCPSROW,TCSROW, IGDRROW, &
             THFCROW,PSIWROW,DLZWROW,ZBTWROW, VMODGRD, &
             hp%ZSNLROW,hp%ZPLGROW,hp%ZPLSROW,hp%FRZCROW, TACROW, QACROW, &
             cp%DRNROW, cp%XSLPROW,cp%XDROW,WFSFROW,cp%KSROW, &
             ALGWROW,ALGDROW,ASVDROW,ASIDROW,AGVDROW, &
             AGIDROW,ISNDROW,RADJGRD,cp%ZBLDGRD,Z0ORGRD, &
             cp%ZRFMGRD,cp%ZRFHGRD,ZDMGRD, ZDHGRD, FSVHGRD, &
             FSIHGRD,CSZGRD, cm%clin(cfk%FI)%climvGrd, cm%clin(cfk%UV)%climvGrd,  VLGRD, &
             cm%clin(cfk%TT)%climvGrd,  cm%clin(cfk%HU)%climvGrd,  cm%clin(cfk%P0)%climvGrd,cm%clin(cfk%PR)%climvGrd, PADRGRD, &
             VPDGRD, TADPGRD,RHOAGRD,RPCPGRD,TRPCGRD, &
             SPCPGRD,TSPCGRD,RHSIGRD,FCLOGRD,DLONGRD, &
             GGEOGRD,cp%MANNROW,MANNGAT,cp%DDROW,DDGAT, &
             cp%SANDROW,SANDGAT,cp%CLAYROW,CLAYGAT,     &
!BEGIN: PDMROF
             hp%CMINROW,hp%CMAXROW,hp%BROW,hp%K1ROW,hp%K2ROW, &
!END: PDMROF
             cp%FAREROW, FAREGAT, &
             hp%fetchROW,hp%HtROW,hp%N_SROW,hp%A_SROW,hp%DistribROW, &
             fetchGAT,HtGAT,N_SGAT,A_SGAT,DistribGAT, &
             DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
             TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
             DriftROW, SublROW, DepositionROW, &
             DriftGAT, SublGAT, DepositionGAT)
!>
!>   * INITIALIZATION OF DIAGNOSTIC VARIABLES SPLIT OUT OF CLASSG
!>   * FOR CONSISTENCY WITH GCM APPLICATIONS.
!>

!> *********************************************************************
!> Set variables arrays to zero.
!> *********************************************************************

          CDHGAT  = 0.0
          CDMGAT  = 0.0
          HFSGAT  = 0.0
          TFXGAT  = 0.0
          QEVPGAT = 0.0
          QFSGAT  = 0.0
          QFXGAT  = 0.0
          PETGAT  = 0.0
          GAGAT   = 0.0
          EFGAT   = 0.0
          GTGAT   = 0.0
          QGGAT   = 0.0
          ALVSGAT = 0.0
          ALIRGAT = 0.0
          SFCTGAT = 0.0
          SFCUGAT = 0.0
          SFCVGAT = 0.0
          SFCQGAT = 0.0
          FSNOGAT = 0.0
          FSGVGAT = 0.0
          FSGSGAT = 0.0
          FSGGGAT = 0.0
          FLGVGAT = 0.0
          FLGSGAT = 0.0
          FLGGGAT = 0.0
          HFSCGAT = 0.0
          HFSSGAT = 0.0
          HFSGGAT = 0.0
          HEVCGAT = 0.0
          HEVSGAT = 0.0
          HEVGGAT = 0.0
          HMFCGAT = 0.0
          HMFNGAT = 0.0
          HTCCGAT = 0.0
          HTCSGAT = 0.0
          PCFCGAT = 0.0
          PCLCGAT = 0.0
          PCPNGAT = 0.0
          PCPGGAT = 0.0
          QFGGAT  = 0.0
          QFNGAT  = 0.0
          QFCFGAT = 0.0
          QFCLGAT = 0.0
          ROFGAT  = 0.0
          ROFOGAT = 0.0
          ROFSGAT = 0.0
          ROFBGAT = 0.0
          TROFGAT = 0.0
          TROOGAT = 0.0
          TROSGAT = 0.0
          TROBGAT = 0.0
          ROFCGAT = 0.0
          ROFNGAT = 0.0
          ROVGGAT = 0.0
          WTRCGAT = 0.0
          WTRSGAT = 0.0
          WTRGGAT = 0.0
          DRGAT   = 0.0
120   CONTINUE
!>
          HMFGGAT = 0.0
          HTCGAT  = 0.0
          QFCGAT  = 0.0
          GFLXGAT = 0.0
130   CONTINUE
140   CONTINUE
!>
                  ITCTGAT = 0
150           CONTINUE
160       CONTINUE
170   CONTINUE
!>
call resume_state_r2c(NML,NLTEST,NMTEST,NCOUNT, &
                    MINS_NOW,ACLASS,NR2C_R,GRD_R,GAT_R,GRDGAT_R,R2C_ATTRIBUTES_R,&
                    NA,XXX,YYY,XCOUNT,YCOUNT,ILMOS,JLMOS,ILG,ICAN,ICP1,IGND, &
                       TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
                       TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT,  &
                       TCANGAT,RCANGAT,SCANGAT,GROGAT, CMAIGAT, &
                       FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT, &
                       PAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT, &
                       VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,PAIDGAT, &
                       HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT, &
                       THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT, &
                       GRKSGAT,THRAGAT,HCPSGAT,TCSGAT,          &
                       THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT,         &
                       ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT,  &
                       DRNGAT, XSLPGAT,XDGAT,WFSFGAT,KSGAT,     &
                       ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT, &
                       AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT, &
                       ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT, &
                       FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT,   &
                       TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT, &
                       VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT, &
                       SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT, &
                       GGEOGAT,                                 &
                       CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
                       QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT,   &
                       GTGAT,  QGGAT,  ALVSGAT,ALIRGAT, &
                       SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT, &
                       FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
                       FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
                       HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
                       HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
                       QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT,  &
                       ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
                       TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
                       WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  GFLXGAT, &
                       HMFGGAT,HTCGAT, QFCGAT,MANNGAT, DDGAT,   &
                       SANDGAT,CLAYGAT,IGDRGAT,VMODGAT,QLWOGAT, &
                       coordsys1,datum1, zone1,  XORIGIN,YORIGIN,XDELTA,YDELTA)
!>
! now scatter the variables so that the GATs don't get overwritten incorrectly
CALL CLASSS (cp%TBARROW,cp%THLQROW,cp%THICROW,GFLXROW,TSFSROW, &
             cp%TPNDROW,cp%ZPNDROW,TBASROW,cp%ALBSROW,cp%TSNOROW, &
             cp%RHOSROW,cp%SNOROW,cp%TCANROW,cp%RCANROW,cp%SCANROW, &
             cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
             ILMOS,JLMOS,IWMOS,JWMOS, &
             NML,NA,NTYPE,ILG,IGND,ICAN,ICAN+1, &
             TBARGAT,THLQGAT,THICGAT,GFLXGAT,TSFSGAT, &
             TPNDGAT,ZPNDGAT,TBASGAT,ALBSGAT,TSNOGAT, &
             RHOSGAT,SNOGAT,TCANGAT,RCANGAT,SCANGAT, &
             GROGAT,CMAIGAT,TACGAT,QACGAT,WSNOGAT, &
             cp%MANNROW,MANNGAT,cp%DDROW,DDGAT, &
             cp%SANDROW,SANDGAT,cp%CLAYROW,CLAYGAT,cp%XSLPROW,XSLPGAT, &
             DrySnowRow, SnowAgeROW,DrySnowGAT, SnowAgeGAT, &
             TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
             DriftROW, SublROW, DepositionROW, &
             DriftGAT, SublGAT, DepositionGAT)
!>
!>   * SCATTER OPERATION ON DIAGNOSTIC VARIABLES SPLIT OUT OF
!>   * CLASSS FOR CONSISTENCY WITH GCM APPLICATIONS.
!>
      DO 180 K=1,NML
          CDHROW (ILMOS(K),JLMOS(K))=CDHGAT (K)
          CDMROW (ILMOS(K),JLMOS(K))=CDMGAT (K)
          HFSROW (ILMOS(K),JLMOS(K))=HFSGAT (K)
          TFXROW (ILMOS(K),JLMOS(K))=TFXGAT (K)
          QEVPROW(ILMOS(K),JLMOS(K))=QEVPGAT(K)
          QFSROW (ILMOS(K),JLMOS(K))=QFSGAT (K)
          QFXROW (ILMOS(K),JLMOS(K))=QFXGAT (K)
          PETROW (ILMOS(K),JLMOS(K))=PETGAT (K)
          GAROW  (ILMOS(K),JLMOS(K))=GAGAT  (K)
          EFROW  (ILMOS(K),JLMOS(K))=EFGAT  (K)
          GTROW  (ILMOS(K),JLMOS(K))=GTGAT  (K)
          QGROW  (ILMOS(K),JLMOS(K))=QGGAT  (K)
          ALVSROW(ILMOS(K),JLMOS(K))=ALVSGAT(K)
          ALIRROW(ILMOS(K),JLMOS(K))=ALIRGAT(K)
          SFCTROW(ILMOS(K),JLMOS(K))=SFCTGAT(K)
          SFCUROW(ILMOS(K),JLMOS(K))=SFCUGAT(K)
          SFCVROW(ILMOS(K),JLMOS(K))=SFCVGAT(K)
          SFCQROW(ILMOS(K),JLMOS(K))=SFCQGAT(K)
          FSNOROW(ILMOS(K),JLMOS(K))=FSNOGAT(K)
          FSGVROW(ILMOS(K),JLMOS(K))=FSGVGAT(K)
          FSGSROW(ILMOS(K),JLMOS(K))=FSGSGAT(K)
          FSGGROW(ILMOS(K),JLMOS(K))=FSGGGAT(K)
          FLGVROW(ILMOS(K),JLMOS(K))=FLGVGAT(K)
          FLGSROW(ILMOS(K),JLMOS(K))=FLGSGAT(K)
          FLGGROW(ILMOS(K),JLMOS(K))=FLGGGAT(K)
          HFSCROW(ILMOS(K),JLMOS(K))=HFSCGAT(K)
          HFSSROW(ILMOS(K),JLMOS(K))=HFSSGAT(K)
          HFSGROW(ILMOS(K),JLMOS(K))=HFSGGAT(K)
          HEVCROW(ILMOS(K),JLMOS(K))=HEVCGAT(K)
          HEVSROW(ILMOS(K),JLMOS(K))=HEVSGAT(K)
          HEVGROW(ILMOS(K),JLMOS(K))=HEVGGAT(K)
          HMFCROW(ILMOS(K),JLMOS(K))=HMFCGAT(K)
          HMFNROW(ILMOS(K),JLMOS(K))=HMFNGAT(K)
          HTCCROW(ILMOS(K),JLMOS(K))=HTCCGAT(K)
          HTCSROW(ILMOS(K),JLMOS(K))=HTCSGAT(K)
          PCFCROW(ILMOS(K),JLMOS(K))=PCFCGAT(K)
          PCLCROW(ILMOS(K),JLMOS(K))=PCLCGAT(K)
          PCPNROW(ILMOS(K),JLMOS(K))=PCPNGAT(K)
          PCPGROW(ILMOS(K),JLMOS(K))=PCPGGAT(K)
          QFGROW (ILMOS(K),JLMOS(K))=QFGGAT (K)
          QFNROW (ILMOS(K),JLMOS(K))=QFNGAT (K)
          QFCLROW(ILMOS(K),JLMOS(K))=QFCLGAT(K)
          QFCFROW(ILMOS(K),JLMOS(K))=QFCFGAT(K)
          ROFROW (ILMOS(K),JLMOS(K))=ROFGAT (K)
          ROFOROW(ILMOS(K),JLMOS(K))=ROFOGAT(K)
          ROFSROW(ILMOS(K),JLMOS(K))=ROFSGAT(K)
          ROFBROW(ILMOS(K),JLMOS(K))=ROFBGAT(K)
          TROFROW(ILMOS(K),JLMOS(K))=TROFGAT(K)
          TROOROW(ILMOS(K),JLMOS(K))=TROOGAT(K)
          TROSROW(ILMOS(K),JLMOS(K))=TROSGAT(K)
          TROBROW(ILMOS(K),JLMOS(K))=TROBGAT(K)
          ROFCROW(ILMOS(K),JLMOS(K))=ROFCGAT(K)
          ROFNROW(ILMOS(K),JLMOS(K))=ROFNGAT(K)
          ROVGROW(ILMOS(K),JLMOS(K))=ROVGGAT(K)
          WTRCROW(ILMOS(K),JLMOS(K))=WTRCGAT(K)
          WTRSROW(ILMOS(K),JLMOS(K))=WTRSGAT(K)
          WTRGROW(ILMOS(K),JLMOS(K))=WTRGGAT(K)
          DRROW  (ILMOS(K),JLMOS(K))=DRGAT  (K)
          WTABROW(ILMOS(K),JLMOS(K))=WTABGAT(K)
          ILMOROW(ILMOS(K),JLMOS(K))=ILMOGAT(K)
          UEROW  (ILMOS(K),JLMOS(K))=UEGAT(K)
          HBLROW (ILMOS(K),JLMOS(K))=HBLGAT(K)
180   CONTINUE
!>
      DO 190 L=1,IGND
      DO 190 K=1,NML
          HMFGROW(ILMOS(K),JLMOS(K),L)=HMFGGAT(K,L)
          HTCROW (ILMOS(K),JLMOS(K),L)=HTCGAT (K,L)
          QFCROW (ILMOS(K),JLMOS(K),L)=QFCGAT (K,L)
190   CONTINUE
!>
      DO 230 M=1,50
          DO 220 L=1,6
              DO 210 K=1,NML
                  ITCTROW(ILMOS(K),JLMOS(K),L,M)=ITCTGAT(K,L,M)
210           CONTINUE
220       CONTINUE
230   CONTINUE

ENDIF !IF (RESUMEFLAG == 2) THEN

!> *********************************************************************
!> Call read_init_prog_variables.f90 for initi prognostic variables by
!> by fields needd by classas as initial conditions
!> *********************************************************************
!> bjd - July 14, 2014: Gonzalo Sapriza
IF (RESUMEFLAG == 3) THEN

    CALL read_init_prog_variables_class( CMAIROW  , QACROW  , TACROW   , &
                                         TBASROW  , TSFSROW , WSNOROW  , &
                                         cp       , NA      , NTYPE    , &
                                         IGND     , fls                )

END IF !IF (RESUMEFLAG == 3) THEN

!> *********************************************************************
!> Call CLASSB to set more CLASS variables
!> *********************************************************************
!> bjd - July 25, 2005: For inputting field measured soil properties.

  CALL CLASSB(THPROW       , THRROW       , THMROW       , BIROW    , PSISROW      , &
              GRKSROW      , THRAROW      , HCPSROW      , TCSROW   , THFCROW      , &
              PSIWROW      , DLZWROW      , ZBTWROW      , ALGWROW  , ALGDROW      , &
              cp%SANDROW   , cp%CLAYROW   , cp%ORGMROW   , sl%DELZ  , sl%ZBOT      , &
              cp%SDEPROW   , ISNDROW      , IGDRROW      , NA       , NTYPE        , &
              1            , NA           , NMTEST       , IGND     , ICTEMMOD     , &
              SV%WC_THPOR  , SV%WC_THLRET , SV%WC_THLMIN , SV%WC_BI , SV%WC_PSISAT , &
              SV%WC_GRKSAT , SV%WC_HCPS   , SV%WC_TCS                                )

!> Allocate variables for WATDRN3
!> ******************************************************************
!> DGP - June 3, 2011: Now that variables are shared, moved from WD3
!> flag to ensure allocation.
ALLOCATE(BTC(NTYPE,IGND),BCAP(NTYPE,IGND),DCOEFF(NTYPE,IGND), &
        BFCAP(NTYPE,IGND),BFCOEFF(NTYPE,IGND),BFMIN(NTYPE,IGND), &
        BQMAX(NTYPE,IGND),STAT=PAS)

!> Call WATDRN3B to set WATDRN (Ric) variables
!> ******************************************************************
!> DGP - May 5, 2011: Added.
IF (PAS /= 0) WRITE(*) "Error allocating on WD3 for new WATDRN."
CALL WATDRN3B(PSISROW,THPROW,GRKSROW,BIROW,cp%XSLPROW,cp%DDROW, &
    NA,NTYPE,IGND, &
    BTC,BCAP,DCOEFF,BFCAP,BFCOEFF,BFMIN,BQMAX, &
    cp%SANDROW,cp%CLAYROW)

!> *********************************************************************
!> MAM - Initialize ENDDATE and ENDDATA
!> *********************************************************************
ENDDATE = .FALSE.
ENDDATA = .FALSE.

    call climate_module_loaddata(bi, .true., cm, ENDDATA)

if (ipid == 0) then

TOTAL_STORE = 0.0
TOTAL_STORE_2 = 0.0
TOTAL_RCAN = 0.0
TOTAL_SCAN = 0.0
TOTAL_SNO = 0.0
TOTAL_WSNO = 0.0
TOTAL_ZPND = 0.0
TOTAL_THLQ = 0.0
TOTAL_THIC = 0.0

    TOTAL_STORE_M = 0.0
    TOTAL_STORE_2_M = 0.0
    TOTAL_STORE_ACC_M = 0.0
    TOTAL_RCAN_M = 0.0
    TOTAL_SCAN_M = 0.0
    TOTAL_SNO_M = 0.0
    TOTAL_WSNO_M = 0.0
    TOTAL_ZPND_M = 0.0
    TOTAL_THLQ_M = 0.0
    TOTAL_THIC_M = 0.0

    !> Open CSV output files.
    if (BASINBALANCEOUTFLAG > 0) then

        !> Water balance.
!        if ((VARIABLEFILESFLAG == 1) .and. (fls%fl(4)%isInit)) then
        open(fls%fl(mfk%f900)%iun, &
!todo: This creates a bug if a space doesn't exist in the name of the folder!
             file = './' // GENDIR_OUT(1:index(GENDIR_OUT, ' ') - 1) // '/' // trim(adjustl(fls%fl(mfk%f900)%fn)), &
             iostat = ios)
!        else
!            open(900, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/Basin_average_water_balance.csv")
        open(902, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/Basin_average_water_balance_Monthly.csv")
!        end if

        wrt_900_1 = "DAY,YEAR,PREACC" // ",EVAPACC,ROFACC,ROFOACC," // &
            "ROFSACC,ROFBACC,PRE,EVAP,ROF,ROFO,ROFS,ROFB,SCAN,RCAN,SNO,WSNO,ZPND,"

        wrt_900_2 = "THLQ"
        wrt_900_3 = "THIC"
        wrt_900_4 = "THLQIC"

        do i = 1, ignd
            write(strInt, "(i1)") i
            if (i < ignd) then
                wrt_900_2 = trim(adjustl(wrt_900_2)) // trim(adjustl(strInt)) // ",THLQ"
                wrt_900_3 = trim(adjustl(wrt_900_3)) // trim(adjustl(strInt)) // ",THIC"
                wrt_900_4 = trim(adjustl(wrt_900_4)) // trim(adjustl(strInt)) // ",THLQIC"
            else
                wrt_900_2 = trim(adjustl(wrt_900_2)) // trim(adjustl(strInt)) // ","
                wrt_900_3 = trim(adjustl(wrt_900_3)) // trim(adjustl(strInt)) // ","
                wrt_900_4 = trim(adjustl(wrt_900_4)) // trim(adjustl(strInt)) // ","
            end if
        end do !> i = 1, ignd

        wrt_900_f = trim(adjustl(wrt_900_1)) // &
            trim(adjustl(wrt_900_2)) // &
            trim(adjustl(wrt_900_3)) // &
            trim(adjustl(wrt_900_4)) // &
            "THLQ,THLIC,THLQIC,STORAGE,DELTA_STORAGE,DSTOR_ACC"

        write(fls%fl(mfk%f900)%iun, "(a)") trim(adjustl(wrt_900_f))
        write(902, '(a)') trim(adjustl(wrt_900_f))

        !> Energy balance.
        open(901, file = "./" // GENDIR_OUT(1:index(GENDIR_OUT, " ") - 1) // "/Basin_average_energy_balance.csv")

        write(901, "(a)") "DAY,YEAR,HFSACC,QEVPACC"

    end if !(BASINBALANCEOUTFLAG > 0) then

!>**********************************************************************
!> Set initial SnowAge & DrySnow values for PBSM calculations
!> (MK MacDonald, Sept 2010)
!>**********************************************************************
IF(PBSMFLAG == 1)THEN
 DO I=1,NA  !I=2,NA
   DO M=1,NMTEST
     IF(cp%SNOROW(I,M).LE.0.) THEN
       DrySnowROW(I,M) = 0. !1=snowpack is dry (i.e. cold)
       SnowAgeROW(I,M) = 0. !hours since last snowfall
       !todo: this can use the TFREZ parameter instead of a hard-coded value. (dgp: 2015-01-09)
       IF(cm%clin(cfk%TT)%climvGrd(I).GE.273.16) THEN
         DrySnowROW(I,M) = 0.
         SnowAgeROW(I,M) = 48. !assume 48 hours since last snowfall
       ELSE
         DrySnowROW(I,M) = 1.
         SnowAgeROW(I,M) = 48.
       ENDIF
     ENDIF
   ENDDO
 ENDDO
ENDIF !PBSMFLAG == 1

end if !(ipid == 0) then

CALL CLASSG (TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
             TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT, &
             TCANGAT,RCANGAT,SCANGAT,GROGAT, FRZCGAT, CMAIGAT, &
             FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT, &
             PAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT, &
             VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,PAIDGAT, &
             HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT, &
             THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT, &
             GRKSGAT,THRAGAT,HCPSGAT,TCSGAT, IGDRGAT, &
             THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT, VMODGAT, &
             ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT, &
             DRNGAT, XSLPGAT,XDGAT,WFSFGAT,KSGAT, &
             ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT, &
             AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT, &
             ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT, &
             FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT, &
             TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT, &
             VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT, &
             SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT, &
             GGEOGAT, &
             CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
             QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT, &
             GTGAT,  QGGAT,  ALVSGAT,ALIRGAT, &
             SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT, &
             FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
             FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
             HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
             HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
             QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT, &
             ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
             TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
             WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  GFLXGAT, &
             HMFGGAT,HTCGAT, QFCGAT, ITCTGAT, &
!BEGIN: PDMROF
             CMINPDM,CMAXPDM,BPDM,   K1PDM,   K2PDM,  &
!END: PDMROF
             ILMOS,JLMOS,IWMOS,JWMOS,NML,NA,NTYPE, &
             NA*NTYPE,IGND,ICAN,ICP1,cp%TBARROW,cp%THLQROW, &
             cp%THICROW,cp%TPNDROW,cp%ZPNDROW,TBASROW,cp%ALBSROW, &
             cp%TSNOROW,cp%RHOSROW,cp%SNOROW,cp%TCANROW, &
             cp%RCANROW,cp%SCANROW,cp%GROROW, CMAIROW,cp%FCANROW, &
             cp%LNZ0ROW,cp%ALVCROW,cp%ALICROW,cp%PAMXROW, &
             cp%PAMNROW,cp%CMASROW,cp%ROOTROW,cp%RSMNROW, &
             cp%QA50ROW,cp%VPDAROW,cp%VPDBROW,cp%PSGAROW, &
             cp%PSGBROW,PAIDROW,HGTDROW,ACVDROW,ACIDROW,TSFSROW, &
             WSNOROW, THPROW, THRROW, THMROW, BIROW,  PSISROW, &
             GRKSROW,THRAROW,HCPSROW,TCSROW, IGDRROW, &
             THFCROW,PSIWROW,DLZWROW,ZBTWROW, VMODGRD, &
             hp%ZSNLROW,hp%ZPLGROW,hp%ZPLSROW,hp%FRZCROW, TACROW, QACROW, &
             cp%DRNROW, cp%XSLPROW,cp%XDROW,WFSFROW,cp%KSROW, &
             ALGWROW,ALGDROW,ASVDROW,ASIDROW,AGVDROW, &
             AGIDROW,ISNDROW,RADJGRD,cp%ZBLDGRD,Z0ORGRD, &
             cp%ZRFMGRD,cp%ZRFHGRD,ZDMGRD, ZDHGRD, FSVHGRD, &
             FSIHGRD,CSZGRD, cm%clin(cfk%FI)%climvGrd, cm%clin(cfk%UV)%climvGrd,  VLGRD, &
             cm%clin(cfk%TT)%climvGrd,  cm%clin(cfk%HU)%climvGrd,  cm%clin(cfk%P0)%climvGrd,cm%clin(cfk%PR)%climvGrd, PADRGRD, &
             VPDGRD, TADPGRD,RHOAGRD,RPCPGRD,TRPCGRD, &
             SPCPGRD,TSPCGRD,RHSIGRD,FCLOGRD,DLONGRD, &
             GGEOGRD,cp%MANNROW,MANNGAT,cp%DDROW,DDGAT, &
             cp%SANDROW,SANDGAT,cp%CLAYROW,CLAYGAT,     &
!BEGIN: PDMROF
             hp%CMINROW,hp%CMAXROW,hp%BROW,hp%K1ROW,hp%K2ROW, &
!END: PDMROF
             cp%FAREROW, FAREGAT, &
             hp%fetchROW,hp%HtROW,hp%N_SROW,hp%A_SROW,hp%DistribROW, &
             fetchGAT,HtGAT,N_SGAT,A_SGAT,DistribGAT, &
             DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
             TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
             DriftROW, SublROW, DepositionROW, &
             DriftGAT, SublGAT, DepositionGAT)

!todo+++: Perhaps land-unit indexing can be done prior in the sequence
!todo+++: of initialization, after reading the drainage database.
!todo+++: Then, variables could be allocated (il1:il2) instead of
!todo+++: (1:ILG) to reduce the memory footprint of the model per node.
!> *********************************************************************
!> Calculate Indices
!> *********************************************************************

    call GetIndices(inp, izero, ipid, NML, ILMOS, il1, il2, ilen)

    !> Initialize and open files for CLASS output.
    if (WF_NUM_POINTS > 0) then

        !> After GATPREP. Determine the GAT-index of the output point.
        do k = il1, il2
            do i = 1, WF_NUM_POINTS
                if (op%N_OUT(i) == ilmos(k) .and. op%II_OUT(i) == jlmos(k)) op%K_OUT(i) = k
            end do
        end do

        !> Allocate the CLASS output variables.
        allocate( &
            co%PREACC(WF_NUM_POINTS), co%GTACC(WF_NUM_POINTS), co%QEVPACC(WF_NUM_POINTS), co%EVAPACC(WF_NUM_POINTS), &
            co%HFSACC(WF_NUM_POINTS), co%HMFNACC(WF_NUM_POINTS), &
            co%ROFACC(WF_NUM_POINTS), co%ROFOACC(WF_NUM_POINTS), co%ROFSACC(WF_NUM_POINTS), co%ROFBACC(WF_NUM_POINTS), &
            co%WTBLACC(WF_NUM_POINTS), co%ALVSACC(WF_NUM_POINTS), co%ALIRACC(WF_NUM_POINTS), &
            co%RHOSACC(WF_NUM_POINTS), co%TSNOACC(WF_NUM_POINTS), co%WSNOACC(WF_NUM_POINTS), co%SNOARE(WF_NUM_POINTS), &
            co%TCANACC(WF_NUM_POINTS), co%CANARE(WF_NUM_POINTS), co%SNOACC(WF_NUM_POINTS), &
            co%RCANACC(WF_NUM_POINTS), co%SCANACC(WF_NUM_POINTS), co%GROACC(WF_NUM_POINTS), co%FSINACC(WF_NUM_POINTS), &
            co%FLINACC(WF_NUM_POINTS), co%FLUTACC(WF_NUM_POINTS), &
            co%TAACC(WF_NUM_POINTS), co%UVACC(WF_NUM_POINTS), co%PRESACC(WF_NUM_POINTS), co%QAACC(WF_NUM_POINTS))
        allocate( &
            co%TBARACC(WF_NUM_POINTS, IGND), co%THLQACC(WF_NUM_POINTS, IGND), co%THICACC(WF_NUM_POINTS, IGND), &
            co%THALACC(WF_NUM_POINTS, IGND), co%GFLXACC(WF_NUM_POINTS, IGND))

        !> Initialize the CLASS output variables.
        co%PREACC = 0.0
        co%GTACC = 0.0
        co%QEVPACC = 0.0
        co%EVAPACC = 0.0
        co%HFSACC = 0.0
        co%HMFNACC = 0.0
        co%ROFACC = 0.0
        co%ROFOACC = 0.0
        co%ROFSACC = 0.0
        co%ROFBACC = 0.0
        co%WTBLACC = 0.0
        co%TBARACC = 0.0
        co%THLQACC = 0.0
        co%THICACC = 0.0
        co%THALACC = 0.0
        co%GFLXACC = 0.0
        co%ALVSACC = 0.0
        co%ALIRACC = 0.0
        co%RHOSACC = 0.0
        co%TSNOACC = 0.0
        co%WSNOACC = 0.0
        co%SNOARE = 0.0
        co%TCANACC = 0.0
        co%CANARE = 0.0
        co%SNOACC = 0.0
        co%RCANACC = 0.0
        co%SCANACC = 0.0
        co%GROACC = 0.0
        co%FSINACC = 0.0
        co%FLINACC = 0.0
        co%FLUTACC = 0.0
        co%TAACC = 0.0
        co%UVACC = 0.0
        co%PRESACC = 0.0
        co%QAACC = 0.0

        !> Open the files if the GAT-index of the output point resides on this node.
        do i = 1, WF_NUM_POINTS
            if (op%K_OUT(i) >= il1 .and. op%K_OUT(i) <= il2) then

                !> Open the files in the appropriate directory.
                BNAM = op%DIR_OUT(i)
                j = 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF1.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF2.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF3.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF4.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF5.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF6.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF7.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF8.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/CLASSOF9.csv'); j = j + 1
                open(150 + i*10 + j, file = './' // trim(adjustl(BNAM)) // '/GRU_water_balance.csv')

                !> Write project header information.
                do j = 1, 9
                    write(150 + i*10 + j, "('CLASS TEST RUN:     ', 6a4)") TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6
                    write(150 + i*10 + j, "('RESEARCHER:         ', 6a4)") NAME1, NAME2, NAME3, NAME4, NAME5, NAME6
                    write(150 + i*10 + j, "('INSTITUTION:        ', 6a4)") PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6
                end do

                !> CLASSOF1.
                write(150 + i*10 + 1, "('IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE,SNOMLT,BEG," // &
                    "GTOUT,SNOACC(I),RHOSACC(I),WSNOACC(I),ALTOT,ROFACC(I)," // &
                    "ROFOACC(I),ROFSACC(I),ROFBACC(I)')")

                !> CLASSOF2.
                write(FMT, *) ''
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // 'TBARACC(I ' // trim(IGND_CHAR) // ')-TFREZ,THLQACC(I ' // &
                        trim(IGND_CHAR) // '),THICACC(I ' // trim(IGND_CHAR) // '),'
                end do
                write(150 + i*10 + 2, "('IDAY,IYEAR," // trim(FMT) // "TCN,RCANACC(I),SCANACC(I),TSN,ZSN')")

                !> CLASSOF3.
                write(150 + i*10 + 3, "('IDAY,IYEAR,FSINACC(I),FLINACC(I)," // &
                    "TAACC(I)-TFREZ,UVACC(I),PRESACC(I),QAACC(I),PREACC(I)," // &
                    "EVAPACC(I)')")

                !> CLASSOF4.
                write(150 + i*10 + 4, "('IHOUR,IMIN,IDAY,IYEAR,FSSTAR,FLSTAR,QH,QE," // &
                    "SNOMLT,BEG,GTOUT,SNOROW(I M),RHOSROW(I M),WSNOROW(I M),ALTOT," // &
                    "ROFROW(I M),TPN,ZPNDROW(I M),ZPND,FSTR')")

                !> CLASSOF5.
                write(FMT, *) ''
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // 'TBARROW(I ' // trim(IGND_CHAR) // ')-TFREZ,THLQROW(I ' // &
                        trim(IGND_CHAR) // '),THICROW(I ' // trim(IGND_CHAR) // '),'
                end do
                write(150 + i*10 + 5, "('IHOUR,IMIN,IDAY,IYEAR," // trim(FMT) // "TCN,RCANROW(I M),SCANROW(I M),TSN,ZSN')")

                !> CLASSOF6.
                write(150 + i*10 + 6, "('IHOUR,IMIN,IDAY,FSDOWN(I),FDLGRD(I)," // &
                    "PREGRD(I),TAGRD(I)-TFREZ,UVGRD(I),PRESGRD(I),QAGRD(I)')")

                !> CLASSOF7.
                write(150 + i*10 + 7,"('TROFROW(I M),TROOROW(I M),TROSROW(I M)," // &
                    "TROBROW(I M),ROFROW(I M),ROFOROW(I M),ROFSROW(I M)," // &
                    "ROFBROW(I M),FCS(I),FGS(I),FC(I),FG(I)')")

                !> CLASSOF8.
                write(FMT, *) ''
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // ',HMFGROW(I M ' // trim(IGND_CHAR) // ')'
                end do
                FMT = trim(adjustl(FMT)) // ',HTCCROW(I M),HTCSROW(I M)'
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // ',HTCROW(I M ' // trim(IGND_CHAR) // ')'
                end do
                write(150 + i*10 + 8, "('FSGVROW(I M),FSGSROW(I M),FSGGROW(I M)," // &
                    "FLGVROW(I M),FLGSROW(I M),FLGGROW(I M),HFSCROW(I M)," // &
                    "HFSSROW(I M),HFSGROW(I M),HEVCROW(I M),HEVSROW(I M)," // &
                    "HEVGROW(I M),HMFCROW(I M),HMFNROW(I M)" // trim(FMT) // "')")

                !> CLASSOF9.
                write(FMT, *) ''
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // 'QFCROW(I M ' // trim(IGND_CHAR) // '),'
                end do
                write(150 + i*10 + 9, "('PCFCROW(I M),PCLCROW(I M),PCPNROW(I M)," // &
                    "PCPGROW(I M),QFCFROW(I M),QFCLROW(I M),QFNROW(I M),QFGROW(I M)," // trim(FMT) // "ROFCROW(I M)," // &
                    "ROFNROW(I M),ROFOROW(I M),ROFROW(I M),WTRCROW(I M)," // &
                    "WTRSROW(I M),WTRGROW(I M)')")

                !> GRU water balance file.
                write(FMT, *) ''
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // 'THLQ' // trim(IGND_CHAR) // ','
                end do
                do j = 1, IGND
                    write(IGND_CHAR, *) j
                    IGND_CHAR = adjustl(IGND_CHAR)
                    FMT = trim(adjustl(FMT)) // 'THIC' // trim(IGND_CHAR) // ','
                end do
                write(150 + i*10 + 10, "('IHOUR,IMIN,IDAY,IYEAR," // &
                    "PRE,EVAP,ROF,ROFO,ROFS,ROFB," // &
                    "SCAN,RCAN,SNO,WSNO,ZPND," // trim(FMT) // "')")

            end if !(op%K_OUT(i) >= il1 .and. op%K_OUT(i) <= il2) then
        end do !i = 1, wf_num_points
    end if !(WF_NUM_POINTS > 0) then

!> *********************************************************************
!> End of Initialization
!> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *
        print 2836
        print 2835
    end if !(ro%VERBOSEMODE > 0) then

2836 format(/1x'DONE INTITIALIZATION')
2835 format(/1x'STARTING MESH')

!> *********************************************************************
!> Start of main loop that is run each half hour
!> *********************************************************************
DO WHILE(.NOT.ENDDATE .AND. .NOT.ENDDATA)

!* N: is only used for debugging purposes.
!> N is incremented at the beginning of each loop. so you can tell which
!> iteration of the loop you are on by what the value of N is.
!> N is printed out with each of the error messages in CLASSZ.
N=N+1

    !> MAM - Linearly interpolate forcing data for intermediate time steps
    if (INTERPOLATIONFLAG == 1) then
        call climate_module_interpolatedata(bi, FAREGAT, cm)
    end if
    UVGRD = max(VMIN, cm%clin(cfk%UV)%climvGrd)
    VMODGRD = UVGRD
    VMODGAT = max(VMIN, ULGAT)

!> *********************************************************************
!> Read in current reservoir release value
!> *********************************************************************

!> only read in current value if we are on the correct time step
!> however put in an exception if this is the first time through (ie. jan=1),
!> otherwise depending on the hour of the first time step
!> there might not be any data in wf_qrel, wf_qhyd
!> make sure we have a controlled reservoir (if not the mod(HOUR_NOW,wf_ktr)
!> may give an error. Frank S Jun 2007
IF(WF_NORESV_CTRL>0) THEN
  IF(MOD(HOUR_NOW,WF_KTR)==0.AND.MINS_NOW==0) THEN
!>        READ in current reservoir value
    READ(21,'(100F10.3)',IOSTAT=IOS)(WF_QREL(I), &
        I=1,WF_NORESV_CTRL)
    IF(IOS/=0) THEN
      PRINT *, 'ran out of reservoir data before met data'
      STOP
        ENDIF
  ELSE
    IF (JAN==1.AND.WF_NORESV_CTRL>0) THEN
      READ(21,'(100F10.3)',IOSTAT=IOS)(WF_QREL(I), &
          I=1,WF_NORESV_CTRL)
      REWIND 21
      READ(21,*)
      DO I=1,WF_NORESV
        READ(21,*)
          ENDDO
    ENDIF
  ENDIF
ENDIF

! *********************************************************************
!> Read in current streamflow value
!> *********************************************************************

!> only read in current value if we are on the correct time step
!> also read in the first value if this is the first time through
IF(MOD(HOUR_NOW,WF_KT)==0.AND.MINS_NOW==0 .AND. JAN > 1) THEN
!>       read in current streamflow value
  READ(22,*,IOSTAT=IOS) (WF_QHYD(I),I=1,WF_NO)
  IF(IOS/=0) THEN
    PRINT *, 'ran out of streamflow data before met data'
    STOP
  ENDIF
ENDIF

!> *********************************************************************
!> Set some more CLASS parameters
!> *********************************************************************

!> This estimates the fractional cloud cover (FCLOGRD) by the basis
!>  of the solar zenith angle and the occurrence of precipitation.
!>  Assumed to be 1 (100%) when precipitation occurs and somewhere
!>  in the range of [0.1,1] based on the location of the sun in the
!>  sky when precipitation is not occuring. (0.1 when the sun is at
!>  the zenith, 1 when the sun is at the horizon).
RDAY=REAL(JDAY_NOW)+(REAL(HOUR_NOW)+REAL(MINS_NOW)/60.)/24.
DECL=SIN(2.*PI*(284.+RDAY)/365.)*23.45*PI/180.
HOUR=(REAL(HOUR_NOW)+REAL(MINS_NOW)/60.)*PI/12.-PI

DO I=il1,il2
  COSZ=SIN(RADJgat(I))*SIN(DECL)+COS(RADJgat(I))*COS(DECL)*COS(HOUR)
  CSZgat(I)=SIGN(MAX(ABS(COSZ),1.0E-3),COSZ)
  cszgrd(ilmos(i)) = cszgat(i)
  IF(PREgat(I)>0.) THEN
    !todo: there isn't a GAT variable for this (although, there might be for the canopy)?
    XDIFFUS(ilmos(I))=1.0
  ELSE
    XDIFFUS(ilmos(I))=MAX(0.0,MIN(1.0-0.9*COSZ,1.0))
  ENDIF
  FCLOgat(I)=XDIFFUS(ilmos(I))
  fclogrd(ilmos(i)) = fclogat(i)
ENDDO

!> *********************************************************************
!> Start of calls to CLASS subroutines
!> *********************************************************************

        !> Were initialized in CLASSG and so have been extracted.
          DriftGAT=0.0 !DriftROW (ILMOS(K),JLMOS(K))
          SublGAT=0.0 !SublROW (ILMOS(K),JLMOS(K))
          DepositionGAT=0.0

!>
!>   * INITIALIZATION OF DIAGNOSTIC VARIABLES SPLIT OUT OF CLASSG
!>   * FOR CONSISTENCY WITH GCM APPLICATIONS.
!>

          CDHGAT  = 0.0
          CDMGAT  = 0.0
          HFSGAT  = 0.0
          TFXGAT  = 0.0
          QEVPGAT = 0.0
          QFSGAT  = 0.0
          QFXGAT  = 0.0
          PETGAT  = 0.0
          GAGAT   = 0.0
          EFGAT   = 0.0
          GTGAT   = 0.0
          QGGAT   = 0.0
          ALVSGAT = 0.0
          ALIRGAT = 0.0
          SFCTGAT = 0.0
          SFCUGAT = 0.0
          SFCVGAT = 0.0
          SFCQGAT = 0.0
          FSNOGAT = 0.0
          FSGVGAT = 0.0
          FSGSGAT = 0.0
          FSGGGAT = 0.0
          FLGVGAT = 0.0
          FLGSGAT = 0.0
          FLGGGAT = 0.0
          HFSCGAT = 0.0
          HFSSGAT = 0.0
          HFSGGAT = 0.0
          HEVCGAT = 0.0
          HEVSGAT = 0.0
          HEVGGAT = 0.0
          HMFCGAT = 0.0
          HMFNGAT = 0.0
          HTCCGAT = 0.0
          HTCSGAT = 0.0
          PCFCGAT = 0.0
          PCLCGAT = 0.0
          PCPNGAT = 0.0
          PCPGGAT = 0.0
          QFGGAT  = 0.0
          QFNGAT  = 0.0
          QFCFGAT = 0.0
          QFCLGAT = 0.0
          ROFGAT  = 0.0
          ROFOGAT = 0.0
          ROFSGAT = 0.0
          ROFBGAT = 0.0
          TROFGAT = 0.0
          TROOGAT = 0.0
          TROSGAT = 0.0
          TROBGAT = 0.0
          ROFCGAT = 0.0
          ROFNGAT = 0.0
          ROVGGAT = 0.0
          WTRCGAT = 0.0
          WTRSGAT = 0.0
          WTRGGAT = 0.0
          DRGAT   = 0.0
320   CONTINUE
!>
          HMFGGAT = 0.0
          HTCGAT  = 0.0
          QFCGAT  = 0.0
          GFLXGAT = 0.0
330   CONTINUE
340   CONTINUE
!>
                  ITCTGAT = 0
350           CONTINUE
360       CONTINUE
370   CONTINUE
!>

CALL CLASSI(VPDGAT,TADPGAT,PADRGAT,RHOAGAT,RHSIGAT, &
            RPCPGAT,TRPCGAT,SPCPGAT,TSPCGAT,TAGAT,QAGAT, &
            PREGAT,RPREGAT,SPREGAT,PRESGAT, &
            IPCP,ILG,il1,il2)

if (ipid == 0) then

!> Calculate initial storage (after reading in resume.txt file if applicable)
IF (JAN == 1) THEN
    INIT_STORE = 0.0
    DO I = 1, NA
        IF (FRAC(I) >= 0.0) THEN
            DO M = 1, NMTEST
                INIT_STORE = INIT_STORE + cp%FAREROW(I, M)* &
                    (cp%RCANROW(I, M) + cp%SCANROW(I, M) + cp%SNOROW(I, M) + WSNOROW(I, M) + cp%ZPNDROW(I, M)*RHOW)
                wb%stg(i) = cp%farerow(i, m)* &
                    (cp%rcanrow(i, m) + cp%scanrow(i, m) + cp%snorow(i, m) + wsnorow(i, m) + cp%zpndrow(i, m)*rhow)
                DO J = 1, IGND
                    INIT_STORE = INIT_STORE + cp%FAREROW(I, M)* &
                        (cp%THLQROW(I, M, J)*RHOW + cp%THICROW(I, M, J)*RHOICE)*DLZWROW(I, M, J)
                    wb%stg(i) = cp%farerow(i, m)* &
                        (cp%thlqrow(i, m, j)*rhow + cp%thicrow(i, m, j)*rhoice)*dlzwrow(i, m, j)
                END DO
            END DO
            wb%dstg(i) = wb%stg(i)
        END IF
    END DO
    TOTAL_STORE_2 = INIT_STORE

    ! For monthly totals.
    call FIND_MONTH(JDAY_NOW, YEAR_NOW, imonth_old)
    TOTAL_STORE_2_M = INIT_STORE

END IF

!>=========================================================================
!> Initialization of the Storage field
 IF(JAN==1) THEN
    DO M = 1, NMTEST

        STG_I(:) =  STG_I(:) + cp%FAREROW(:,M)*(cp%RCANROW(:,M) + &
                                                cp%SCANROW(:,M) + &
                                                cp%SNOROW(:,M)  + &
                                                cp%ZPNDROW(:,M)*RHOW)
        DO J = 1, IGND

            STG_I(:) = STG_I(:) + cp%FAREROW(:,M)*(cp%THLQROW(:,M,J)*RHOW + &
                                                   cp%THICROW(:,M,J)*RHOICE)*DLZWROW(:,M,J)

        ENDDO

    ENDDO
  ENDIF

end if !(ipid == 0) then

!> *********************************************************************
!> Start of the NML-based LSS loop.
!> *********************************************************************

!> ========================================================================
if (ipid /= 0 .or. izero == 0) then

CALL CLASSZ (0       , CTVSTP  , CTSSTP  , CT1STP, CT2STP, CT3STP  , &
             WTVSTP  , WTSSTP  , WTGSTP                            , &
             FSGVGAT , FLGVGAT , HFSCGAT , HEVCGAT,HMFCGAT,HTCCGAT , &
             FSGSGAT , FLGSGAT , HFSSGAT , HEVSGAT,HMFNGAT,HTCSGAT , &
             FSGGGAT , FLGGGAT , HFSGGAT , HEVGGAT,HMFGGAT,HTCGAT  , &
             PCFCGAT , PCLCGAT , QFCFGAT , QFCLGAT,ROFCGAT,WTRCGAT , &
             PCPNGAT , QFNGAT  , ROFNGAT , WTRSGAT,PCPGGAT,QFGGAT  , &
             QFCGAT  , ROFGAT  , WTRGGAT , CMAIGAT,RCANGAT,SCANGAT , &
             TCANGAT , SNOGAT  , WSNOGAT , TSNOGAT,THLQGAT,THICGAT , &
             HCPSGAT , THPGAT  , DLZWGAT , TBARGAT,ZPNDGAT,TPNDGAT , &
             sl%DELZ , FCS     , FGS     ,    FC,     FG           , &
             il1     , il2     ,    ILG  ,    IGND,   N            , &
             DriftGAT, SublGAT                                     )
!> ========================================================================
!> ALBEDO AND TRANSMISSIVITY CALCULATIONS; GENERAL VEGETATION
!> CHARACTERISTICS.

CALL CLASSA    (FC,     FG,     FCS,    FGS,    ALVSCN, ALIRCN, &
                ALVSG,  ALIRG,  ALVSCS, ALIRCS, ALVSSN, ALIRSN, &
                ALVSGC, ALIRGC, ALVSSC, ALIRSC, TRVSCN, TRIRCN, &
                TRVSCS, TRIRCS, FSVF,   FSVFS, &
                RAICAN, RAICNS, SNOCAN, SNOCNS, FRAINC, FSNOWC, &
                FRAICS, FSNOCS, &
                DISP,   DISPS,  ZOMLNC, ZOMLCS, &
                ZOELNC, ZOELCS, ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
                CHCAP,  CHCAPS, CMASSC, CMASCS, CWLCAP, CWFCAP, &
                CWLCPS, CWFCPS, RC,     RCS,    RBCOEF, FROOT, &
                ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TRSNOW, ZSNOW, &
                WSNOGAT,ALVSGAT,ALIRGAT,HTCCGAT,HTCSGAT,HTCGAT, &
                WTRCGAT,WTRSGAT,WTRGGAT,CMAIGAT,FSNOGAT, &
                FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT,PAMNGAT, &
                CMASGAT,ROOTGAT,RSMNGAT,QA50GAT,VPDAGAT,VPDBGAT, &
                PSGAGAT,PSGBGAT,PAIDGAT,HGTDGAT,ACVDGAT,ACIDGAT, &
                ASVDGAT,ASIDGAT,AGVDGAT,AGIDGAT,ALGWGAT,ALGDGAT, &
                THLQGAT,THICGAT,TBARGAT,RCANGAT,SCANGAT,TCANGAT, &
                GROGAT, SNOGAT, TSNOGAT,RHOSGAT,ALBSGAT,ZBLDGAT, &
                Z0ORGAT,ZSNLGAT,ZPLGGAT,ZPLSGAT, &
                FCLOGAT,TAGAT,  VPDGAT, RHOAGAT,CSZGAT, &
                FSVHGAT,RADJGAT,DLONGAT,RHSIGAT,sl%DELZ,DLZWGAT, &
                ZBTWGAT,THPGAT, THMGAT, PSISGAT,BIGAT,  PSIWGAT, &
                HCPSGAT,ISNDGAT, &
                FCANCMX,ICTEM,  ICTEMMOD,       RMATC, &
                AILC,   PAIC,   L2MAX,  NOL2PFTS, &
                AILCG,  AILCGS, FCANC,  FCANCS, &
                JDAY_NOW,   ILG,    il1,    il2, &
                JLAT,N, ICAN,   ICAN+1, IGND,   IDISP,  IZREF, &
                IWF,    IPAI,   IHGT,   IALC,   IALS,   IALG  )
!
!-----------------------------------------------------------------------
!          * SURFACE TEMPERATURE AND FLUX CALCULATIONS.
!
CALL  CLASST     (TBARC,  TBARG,  TBARCS, TBARGS, THLIQC, THLIQG, &
  THICEC, THICEG, HCPC,   HCPG,   TCTOPC, TCBOTC, TCTOPG, TCBOTG, &
  GZEROC, GZEROG, GZROCS, GZROGS, G12C,   G12G,   G12CS,  G12GS, &
  G23C,   G23G,   G23CS,  G23GS,  QFREZC, QFREZG, QMELTC, QMELTG, &
  EVAPC,  EVAPCG, EVAPG,  EVAPCS, EVPCSG, EVAPGS, TCANO,  TCANS, &
  RAICAN, SNOCAN, RAICNS, SNOCNS, CHCAP,  CHCAPS, TPONDC, TPONDG, &
  TPNDCS, TPNDGS, TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
  ITCTGAT,CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT,QFSGAT, QFXGAT, &
  PETGAT, GAGAT,  EFGAT,  GTGAT,  QGGAT,  SFCTGAT,SFCUGAT,SFCVGAT,&
  SFCQGAT,SFRHGAT,FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT,FLGGGAT, &
  HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT,HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT, &
  HTCCGAT,HTCSGAT,HTCGAT, QFCFGAT,QFCLGAT,DRGAT,  WTABGAT,ILMOGAT, &
  UEGAT,  HBLGAT, TACGAT, QACGAT, ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, &
  VPDGAT, TADPGAT,RHOAGAT,FSVHGAT,FSIHGAT,FDLGAT, ULGAT,  VLGAT, &
  TAGAT,  QAGAT,  PADRGAT,FC,     FG,     FCS,    FGS,    RBCOEF, &
  FSVF,   FSVFS,  PRESGAT,VMODGAT,ALVSCN, ALIRCN, ALVSG,  ALIRG, &
  ALVSCS, ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, ALVSSC, ALIRSC, &
  TRVSCN, TRIRCN, TRVSCS, TRIRCS, RC,     RCS, WTRGGAT,   QLWOGAT, &
  FRAINC, FSNOWC, FRAICS, FSNOCS, CMASSC, CMASCS, DISP,   DISPS, &
  ZOMLNC, ZOELNC, ZOMLNG, ZOELNG, ZOMLCS, ZOELCS, ZOMLNS, ZOELNS, &
  TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT,TBASGAT,TCANGAT,TSNOGAT, &
  ZSNOW,  TRSNOW, RHOSGAT,WSNOGAT,THPGAT, THRGAT, THMGAT, THFCGAT, &
  RADJGAT,PREGAT, HCPSGAT,TCSGAT, TSFSGAT,sl%DELZ,DLZWGAT,ZBTWGAT, &
  FTEMP,  FVAP,   RIB,    ISNDGAT, &
  AILCG,  AILCGS, FCANC,  FCANCS, CO2CONC,CO2I1CG,CO2I1CS,CO2I2CG, &
  CO2I2CS,COSZS,  XDIFFUSC,SLAI,  ICTEM,  ICTEMMOD,RMATCTEM, &
  FCANCMX,L2MAX,  NOL2PFTS,       CFLUXCG,CFLUXCS,ANCSVEG,ANCGVEG, &
  RMLCSVEG,   RMLCGVEG,   FIELDSM,WILTSM, &
  ITC,    ITCG,   ITG,   ILG,  il1,il2,  JLAT,N, ICAN, &
  IGND,   IZREF,  ISLFD,  NLANDCS,NLANDGS,NLANDC, NLANDG, NLANDI)
!
!-----------------------------------------------------------------------
!          * WATER BUDGET CALCULATIONS.
!
    IF(JDAY_NOW == 1 .AND. NCOUNT == 48)THEN
       ! bruce davison - only increase NMELT if we don't start the run on January 1st, otherwise t0_ACC allocation is too large
       ! and the model crashes if the compiler is checking for array bounds when t0_ACC is passed into CLASSW with size NMELT
       IF(JDAY_START .EQ. 1 .AND. NSUM_TOTAL .LT. 49) THEN
         continue ! NMELT should stay = 1
       ELSE
         NMELT = NMELT + 1
       ENDIF
       CUMSNOWINFILCS  = 0.0
       CUMSNOWINFILGS  = 0.0
       INFILTYPE     = 2
    ENDIF

    CALL CLASSW  (THLQGAT, THICGAT, TBARGAT, TCANGAT, RCANGAT, SCANGAT, &
                  ROFGAT, TROFGAT, SNOGAT, TSNOGAT, RHOSGAT, ALBSGAT, &
                  WSNOGAT, ZPNDGAT, TPNDGAT, GROGAT, FRZCGAT, TBASGAT, GFLXGAT, &
                  PCFCGAT, PCLCGAT, PCPNGAT, PCPGGAT, QFCFGAT, QFCLGAT, &
                  QFNGAT, QFGGAT, QFCGAT, HMFCGAT, HMFGGAT, HMFNGAT, &
                  HTCCGAT, HTCSGAT, HTCGAT, ROFCGAT, ROFNGAT, ROVGGAT, &
                  WTRSGAT, WTRGGAT, ROFOGAT, ROFSGAT, ROFBGAT, &
                  TROOGAT, TROSGAT, TROBGAT, QFSGAT, &
                  TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
                  THICEC, THICEG, HCPC, HCPG, RPCPGAT, TRPCGAT, &
                  SPCPGAT, TSPCGAT, PREGAT, TAGAT, RHSIGAT, GGEOGAT, &
                  FC,     FG,     FCS,    FGS,    TPONDC, TPONDG, &
                  TPNDCS, TPNDGS, EVAPC,  EVAPCG, EVAPG,  EVAPCS, &
                  EVPCSG, EVAPGS, QFREZC, QFREZG, QMELTC, QMELTG, &
                  RAICAN, SNOCAN, RAICNS, SNOCNS, FROOT,  FSVF, &
                  FSVFS,  CWLCAP, CWFCAP, CWLCPS, CWFCPS, TCANO, &
                  TCANS,  CHCAP,  CHCAPS, CMASSC, CMASCS, ZSNOW, &
                  GZEROC, GZEROG, GZROCS, GZROGS, G12C,   G12G, &
                  G12CS,  G12GS,  G23C,   G23G,   G23CS,  G23GS, &
                  TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
                  ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, TSFSGAT, &
                  TCTOPC, TCBOTC, TCTOPG, TCBOTG, &
                  THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT,GRKSGAT, &
                  THRAGAT,THFCGAT,DRNGAT, HCPSGAT,sl%DELZ, &
                  DLZWGAT,ZBTWGAT,XSLPGAT,XDGAT,WFSFGAT,KSGAT, &
                  ISNDGAT, IGDRGAT, IWF, NA*NTYPE, il1, il2, N, &
                  JLAT,   ICAN,   IGND,   IGND+1, IGND+2, &
                  NLANDCS,NLANDGS,NLANDC, NLANDG,NLANDI, &
                  MANNGAT,DDGAT,NCOUNT, &
                  t0_ACC(NMELT),SI,TSI,INFILTYPE,SNOWMELTD,SNOWMELTD_LAST, &
                  MELTRUNOFF,SNOWINFIL,CUMSNOWINFILCS, CUMSNOWINFILGS, &
                  SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS, &
                  NA,NTYPE,ILMOS,JLMOS, &
                  BTC,BCAP,DCOEFF,BFCAP,BFCOEFF,BFMIN,BQMAX, &
!FOR PDMROF
                  CMINPDM,   CMAXPDM,   BPDM,      K1PDM,    K2PDM,&
                  ZPNDPRECS, ZPONDPREC, ZPONDPREG, ZPNDPREGS,      & 
                  UM1CS,     UM1C,      UM1G,      UM1GS,          &
                  QM1CS,     QM1C,      QM1G,      QM1GS,          &
                  QM2CS,     QM2C,      QM2G,      QM2GS,     UMQ, &
                  FSTRCS,    FSTRC,     FSTRG,    FSTRGS, &
                  ZSNOCS,ZSNOGS,ZSNOWC,ZSNOWG, &
                  HCPSCS,HCPSGS,HCPSC,HCPSG, &
                  TSNOWC,TSNOWG,RHOSC,RHOSG,&
                  XSNOWC,XSNOWG,XSNOCS,XSNOGS)
                 
!
!========================================================================
!          * SINGLE COLUMN BLOWING SNOW CALCULATIONS.
!
IF(PBSMFLAG==1) THEN
 CALL PBSMrun(ZSNOW,WSNOGAT,SNOGAT,RHOSGAT,TSNOGAT,HTCSGAT, &
              ZSNOCS,ZSNOGS,ZSNOWC,ZSNOWG, &
              HCPSCS,HCPSGS,HCPSC,HCPSG, &
              TSNOWC,TSNOWG,TSNOCS,TSNOGS, &
              RHOSC,RHOSG,RHOSCS,RHOSGS,&
              XSNOWC,XSNOWG,XSNOCS,XSNOGS, &
              WSNOCS,WSNOGS, &
              FC, FG, FCS, FGS, &
              fetchGAT,N_SGAT,A_SGAT,HtGAT, &
              SFCTGAT,SFCUGAT,SFCQGAT,PRESGAT,PREGAT, &
              DrySnowGAT, SnowAgeGAT, DriftGAT, SublGAT, &
              TSNOdsGAT, &
              NA*NTYPE,il1,il2,N,ZRFMGAT,ZOMLCS,ZOMLNS)
ENDIF
!========================================================================
!
CALL CLASSZ (1,      CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
             WTVSTP, WTSSTP, WTGSTP, &
             FSGVGAT,FLGVGAT,HFSCGAT,HEVCGAT,HMFCGAT,HTCCGAT, &
             FSGSGAT,FLGSGAT,HFSSGAT,HEVSGAT,HMFNGAT,HTCSGAT, &
             FSGGGAT,FLGGGAT,HFSGGAT,HEVGGAT,HMFGGAT,HTCGAT, &
             PCFCGAT,PCLCGAT,QFCFGAT,QFCLGAT,ROFCGAT,WTRCGAT, &
             PCPNGAT,QFNGAT, ROFNGAT,WTRSGAT,PCPGGAT,QFGGAT, &
             QFCGAT, ROFGAT, WTRGGAT,CMAIGAT,RCANGAT,SCANGAT, &
             TCANGAT,SNOGAT, WSNOGAT,TSNOGAT,THLQGAT,THICGAT, &
             HCPSGAT,THPGAT, DLZWGAT,TBARGAT,ZPNDGAT,TPNDGAT, &
             sl%DELZ,   FCS,    FGS,    FC,     FG, &
             il1,    il2,    ILG,    IGND,   N, &
             DriftGAT, SublGAT )
!
!=======================================================================
!
!          *Redistribute blowing snow mass between GRUs
!
CALL REDISTRIB_SNOW (ILG,1,NA,NTYPE,NML,TSNOGAT,ZSNOW, &
          RHOSGAT,SNOGAT,TSNOCS,ZSNOCS,HCPSCS,RHOSCS,TSNOGS, &
          ZSNOGS,HCPSGS,RHOSGS,TSNOWC,ZSNOWC,HCPSC,RHOSC,TSNOWG, &
          ZSNOWG,HCPSG,RHOSG,cp%GCGRD,ILMOS,DriftGAT,FAREGAT, &
          TSNOdsGAT,DistribGAT,WSNOCS,WSNOGS,FCS,FGS,FC,FG,DepositionGAT, &
          TROOGAT,ROFOGAT,TROFGAT,ROFGAT,ROFNGAT,PCPGGAT,HTCSGAT,WSNOGAT,N)
!
!=======================================================================
ROFGAT = ROFGAT - UMQ

end if !(ipid /= 0 .or. izero == 0) then

!> *********************************************************************
!> End of the NML-based LSS loop.
!> *********************************************************************

! *********************************************************************
! Calculate values for output files and print them out
! *********************************************************************

    !> Send/receive process.
    itag = NSUM_TOTAL*1000
    invars = 14 + 4*IGND

    !> Update the variable count per the active control flags.
    if (SAVERESUMEFLAG == 3) invars = invars + 10 + 4

    if (inp > 1 .and. ipid /= 0) then

        !> Send data back to head-node.

        if (allocated(irqst)) deallocate(irqst)
        if (allocated(imstat)) deallocate(imstat)
        allocate(irqst(invars), imstat(mpi_status_size, invars))
        irqst = mpi_request_null

        i = 1
        call mpi_isend(PREGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(QFSGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(ROFGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(ROFOGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(ROFSGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(ROFBGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(SCANGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(RCANGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(ZPNDGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(SNOGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(FSNOGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(WSNOGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(HFSGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        call mpi_isend(QEVPGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        do j = 1, ignd
            call mpi_isend(THLQGAT(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(THICGAT(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(GFLXGAT(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(TBARGAT(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
        end do

        !> Send optional variables per the active control flags.
        if (SAVERESUMEFLAG == 3) then
            call mpi_isend(ALBSGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(CMAIGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(GROGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(QACGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(RHOSGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(TACGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(TBASGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(TCANGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(TPNDGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(TSNOGAT(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            do j = 1, 4
                call mpi_isend(TSFSGAT(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            end do
        end if !(SAVERESUMEFLAG == 3) then

        lstat = .false.
        do while (.not. lstat)
            call mpi_testall(invars, irqst, lstat, imstat, ierr)
        end do

!        print *, ipid, ' done sending'

    else if (inp > 1) then

        !> Receive data from worker nodes.
        if (allocated(irqst)) deallocate(irqst)
        if (allocated(imstat)) deallocate(imstat)
        allocate(irqst(invars), imstat(mpi_status_size, invars))

        !> Receive and assign variables.
        do u = 1, (inp - 1)

!            print *, 'initiating irecv for:', u, ' with ', itag

            irqst = mpi_request_null
            imstat = 0

            call GetIndices(inp, izero, u, NML, ILMOS, il1, il2, ilen)

            i = 1
            call mpi_irecv(PREGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(QFSGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(ROFGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(ROFOGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(ROFSGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(ROFBGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(SCANGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(RCANGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(ZPNDGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(SNOGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(FSNOGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(WSNOGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(HFSGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_irecv(QEVPGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            do j = 1, ignd
                call mpi_irecv(THLQGAT(il1:il2, j), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(THICGAT(il1:il2, j), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(GFLXGAT(il1:il2, j), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(TBARGAT(il1:il2, j), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            end do

            !> Send optional variables per the active control flags.
            if (SAVERESUMEFLAG == 3) then
                call mpi_irecv(ALBSGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(CMAIGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(GROGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(QACGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(RHOSGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(TACGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(TBASGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(TCANGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(TPNDGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(TSNOGAT(il1:il2), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                do j = 1, 4
                    call mpi_irecv(TSFSGAT(il1:il2, j), ilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                end do
            end if !(SAVERESUMEFLAG == 3) then

            lstat = .false.
            do while (.not. lstat)
                call mpi_testall(invars, irqst, lstat, imstat, ierr)
            end do

        end do !u = 1, (inp - 1)
!        print *, 'done receiving'

    end if !(inp > 1 .and. ipid /= 0) then

    if (inp > 1 .and. NCOUNT == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

!> *********************************************************************
!> Start of book-keeping and grid accumulation.
!> *********************************************************************

!
!=======================================================================
!     * WRITE FIELDS FROM CURRENT TIME STEP TO OUTPUT FILES.

    !> Write to CLASSOF* output files.
    do k = 1, WF_NUM_POINTS
        if (op%K_OUT(k) >= il1 .and. op%K_OUT(k) <= il2) then

            !> Update variables.
            i = op%K_OUT(k)
            if (2.0*FSVHGAT(i) > 0.0) then
                ALTOT = (ALVSGAT(i) + ALIRGAT(i))/2.0
            else
                ALTOT = 0.0
            end if
            FSSTAR = 2.0*FSVHGAT(i)*(1.0 - ALTOT)
            FLSTAR = FDLGAT(i) - SBC*GTGAT(i)**4
            QH = HFSGAT(i)
            QE = QEVPGAT(i)
            BEG = FSSTAR + FLSTAR - QH - QE
            SNOMLT = HMFNGAT(i)
            if (RHOSGAT(i) > 0.0) then
                ZSN = SNOGAT(i)/RHOSGAT(i)
            else
                ZSN = 0.0
            end if
            if (TCANGAT(i) > 0.01) then
                TCN = TCANGAT(i) - TFREZ
            else
                TCN = 0.0
            end if
            if (TSNOGAT(i) > 0.01) then
                TSN = TSNOGAT(i) - TFREZ
            else
                TSN = 0.0
            end if
            if (TPNDGAT(i) > 0.01) then
                TPN = TPNDGAT(i) - TFREZ
            else
                TPN = 0.0
            end if
            if (ILW == 1) then
                GTOUT = GTGAT(i) - TFREZ
            else
                GTOUT = 0.0
            end if
            ZPND = ZPNDPRECS(i)*FCS(i) + ZPONDPREC(i)*FC(i) + ZPONDPREG(i)*FG(i) + &
                ZPNDPREGS(i)*FGS(i)
            FSTR = FSTRCS(i)*FCS(i) + FSTRC(i)*FC(i) + FSTRG(i)*FG(i) + FSTRGS(i)*FGS(i)

            !> Write to the CLASSOF* output files for sub-hourly output.
            write(150 + k*10 + 4, "(I2,',', I3,',', I5,',', I6,',', 9(F8.2,','), 2(F7.3,','), E11.3,',', F8.2,',', 3(F12.4,','))") &
                HOUR_NOW, MINS_NOW, JDAY_NOW, YEAR_NOW, FSSTAR, FLSTAR, QH, &
                QE, SNOMLT, BEG, GTOUT, SNOGAT(i), &
                RHOSGAT(i), WSNOGAT(i), ALTOT, ROFGAT(i), &
                TPN, ZPNDGAT(i), ZPND, FSTR
            write(150 + k*10 + 5, "(I2,',', I3,',', I5,',', I6,',', " // trim(adjustl(IGND_CHAR)) // &
                "(F7.2,',', 2(F6.3,',')), F8.2,',', 2(F8.4,','), F8.2,',', F8.3,',')") &
                HOUR_NOW, MINS_NOW, JDAY_NOW, YEAR_NOW, &
                (TBARGAT(i, j) - TFREZ, THLQGAT(i, j), &
                THICGAT(i, j), j = 1, IGND), TCN, &
                RCANGAT(i), SCANGAT(i), TSN, ZSN
            write(150 + k*10 + 6, "(I2,',', I3,',', I5,',', 2(F10.2,','), F12.6,',', F10.2,',', F8.2,',', F10.2,',', F15.9,',')") &
                HOUR_NOW, MINS_NOW, JDAY_NOW, 2.0*FSVHGAT(i), FDLGAT(i), &
                PREGAT(i), TAGAT(i) - TFREZ, VMODGAT(i), PRESGAT(i), &
                QAGAT(i)
            write(150 + k*10 + 7, "(999(E11.4,','))") &
                TROFGAT(i), TROOGAT(i), TROSGAT(i), &
                TROBGAT(i), ROFGAT(i), ROFOGAT(i), &
                ROFSGAT(i), ROFBGAT(i), &
                FCS(i), FGS(i), FC(i), FG(i)
            write(150 + k*10 + 8, "(999(F12.4,','))") &
                FSGVGAT(i), FSGSGAT(i), FSGGGAT(i), &
                FLGVGAT(i), FLGSGAT(i), FLGGGAT(i), &
                HFSCGAT(i), HFSSGAT(i), HFSGGAT(i), &
                HEVCGAT(i), HEVSGAT(i), HEVGGAT(i), &
                HMFCGAT(i), HMFNGAT(i), &
                (HMFGGAT(i, j), j = 1, IGND), &
                HTCCGAT(i), HTCSGAT(i), &
                (HTCGAT(i, j), j = 1, IGND)
            write(150 + k*10 + 9, "(999(E12.4,','))") &
                PCFCGAT(i), PCLCGAT(i), PCPNGAT(i), &
                PCPGGAT(i), QFCFGAT(i), QFCLGAT(i), &
                QFNGAT(i), QFGGAT(i), (QFCGAT(i, j), j = 1, IGND), &
                ROFCGAT(i), ROFNGAT(i), &
                ROFOGAT(i), ROFGAT(i), WTRCGAT(i), &
                WTRSGAT(i), WTRGGAT(i)
            write(150 + k*10 + 10, "(I2,',', I3,',', I5,',', I6,',', 999(F14.6,','))") &
                HOUR_NOW, MINS_NOW, JDAY_NOW, YEAR_NOW, PREGAT(i)*DELT, QFSGAT(i)*DELT, &
                ROFGAT(i)*DELT, ROFOGAT(i)*DELT, ROFSGAT(i)*DELT, ROFBGAT(i)*DELT, &
                SCANGAT(i), RCANGAT(i), SNOGAT(i), WSNOGAT(i), &
                ZPNDGAT(i)*RHOW, (THLQGAT(i, j)*RHOW*DLZWGAT(i, j), j = 1, IGND), &
                (THICGAT(i, j)*RHOICE*DLZWGAT(i, j), j = 1, IGND)

            !> Calculate accumulated grid variables.
            do i = il1, il2
                if (ILMOS(i) == op%N_OUT(k)) then
                    co%PREACC(k) = co%PREACC(k) + PREGAT(i)*FAREGAT(i)*DELT
                    co%GTACC(k) = co%GTACC(k) + GTGAT(i)*FAREGAT(i)
                    co%QEVPACC(k) = co%QEVPACC(k) + QEVPGAT(i)*FAREGAT(i)
                    co%EVAPACC(k) = co%EVAPACC(k) + QFSGAT(i)*FAREGAT(i)*DELT
                    co%HFSACC(k) = co%HFSACC(k) + HFSGAT(i)*FAREGAT(i)
                    co%HMFNACC(k) = co%HMFNACC(k)+ HMFNGAT(i)*FAREGAT(i)
                    co%ROFACC(k) = co%ROFACC(k) + ROFGAT(i)*FAREGAT(i)*DELT
                    co%ROFOACC(k) = co%ROFOACC(k) + ROFOGAT(i)*FAREGAT(i)*DELT
                    co%ROFSACC(k) = co%ROFSACC(k) + ROFSGAT(i)*FAREGAT(i)*DELT
                    co%ROFBACC(k) = co%ROFBACC(k) + ROFBGAT(i)*FAREGAT(i)*DELT
                    co%WTBLACC(k) = co%WTBLACC(k) + WTABGAT(i)*FAREGAT(i)
                    do j = 1, IGND
                        co%TBARACC(k, j) = co%TBARACC(k, j) + TBARGAT(i, j)*ACLASS(ILMOS(i), JLMOS(i))
                        co%THLQACC(k, j) = co%THLQACC(k, j) + THLQGAT(i, j)*FAREGAT(i)
                        co%THICACC(k, j) = co%THICACC(k, j) + THICGAT(i, j)*FAREGAT(i)
                        co%THALACC(k, j) = co%THALACC(k, j) + (THLQGAT(i, j) + THICGAT(i, j))*FAREGAT(i)
                        co%GFLXACC(k, j) = co%GFLXACC(k, j) + GFLXGAT(i, j)*FAREGAT(i)
                    end do
                    co%ALVSACC(k) = co%ALVSACC(k) + ALVSGAT(i)*FSVHGAT(i)*FAREGAT(i)
                    co%ALIRACC(k) = co%ALIRACC(k) + ALIRGAT(i)*FSIHGAT(i)*FAREGAT(i)
                    if (SNOGAT(i) > 0.0) then
                        co%RHOSACC(k) = co%RHOSACC(k) + RHOSGAT(i)*FAREGAT(i)
                        co%TSNOACC(k) = co%TSNOACC(k) + TSNOGAT(i)*FAREGAT(i)
                        co%WSNOACC(k) = co%WSNOACC(k) + WSNOGAT(i)*FAREGAT(i)
                        co%SNOARE(k) = co%SNOARE(k) + FAREGAT(i)
                    end if
                    if (TCANGAT(i) > 0.5) then
                        co%TCANACC(k) = co%TCANACC(k) + TCANGAT(i)*FAREGAT(i)
                        co%CANARE(k) = co%CANARE(k) + FAREGAT(i)
                    end if
                    co%SNOACC(k) = co%SNOACC(k) + SNOGAT(i)*FAREGAT(i)
                    co%RCANACC(k) = co%RCANACC(k) + RCANGAT(i)*FAREGAT(i)
                    co%SCANACC(k) = co%SCANACC(k) + SCANGAT(i)*FAREGAT(i)
                    co%GROACC(k) = co%GROACC(k) + GROGAT(i)*FAREGAT(i)
                    co%FSINACC(k) = co%FSINACC(k) + 2.0*FSVHGAT(i)*FAREGAT(i)
                    co%FLINACC(k) = co%FLINACC(k) + FDLGAT(i)*FAREGAT(i)
                    co%FLUTACC(k) = co%FLUTACC(k) + SBC*GTGAT(i)**4*FAREGAT(i)
                    co%TAACC(k) = co%TAACC(k) + TAGAT(i)*FAREGAT(i)
                    co%UVACC(k) = co%UVACC(k) + VMODGAT(i)*FAREGAT(i)
                    co%PRESACC(k) = co%PRESACC(k) + PRESGAT(i)*FAREGAT(i)
                    co%QAACC(k) = co%QAACC(k) + QAGAT(i)*FAREGAT(i)
                end if
            end do

            !> Write to the CLASSOF* output files for daily output.
            if (NCOUNT == 48) then

                !> Calculate grid averages.
                co%GTACC(k) = co%GTACC(k)/real(NSUM)
                co%QEVPACC(k) = co%QEVPACC(k)/real(NSUM)
                co%HFSACC(k) = co%HFSACC(k)/real(NSUM)
                co%HMFNACC(k) = co%HMFNACC(k)/real(NSUM)
                co%WTBLACC(k) = co%WTBLACC(k)/real(NSUM)
                co%TBARACC(k, :) = co%TBARACC(k, :)/real(NSUM)
                co%THLQACC(k, :) = co%THLQACC(k, :)/real(NSUM)
                co%THICACC(k, :) = co%THICACC(k, :)/real(NSUM)
                co%THALACC(k, :) = co%THALACC(k, :)/real(NSUM)
                if (co%FSINACC(k) > 0.0) then
                    co%ALVSACC(k) = co%ALVSACC(k)/(co%FSINACC(k)*0.5)
                    co%ALIRACC(k) = co%ALIRACC(k)/(co%FSINACC(k)*0.5)
                else
                    co%ALVSACC(k) = 0.0
                    co%ALIRACC(k) = 0.0
                end if
                if (co%SNOARE(k) > 0.0) then
                    co%RHOSACC(k) = co%RHOSACC(k)/co%SNOARE(k)
                    co%TSNOACC(k) = co%TSNOACC(k)/co%SNOARE(k)
                    co%WSNOACC(k) = co%WSNOACC(k)/co%SNOARE(k)
                end if
                if (co%CANARE(k) > 0.0) then
                    co%TCANACC(k) = co%TCANACC(k)/co%CANARE(k)
                end if
                co%SNOACC(k) = co%SNOACC(k)/real(NSUM)
                co%RCANACC(k) = co%RCANACC(k)/real(NSUM)
                co%SCANACC(k) = co%SCANACC(k)/real(NSUM)
                co%GROACC(k) = co%GROACC(k)/real(NSUM)
                co%FSINACC(k) = co%FSINACC(k)/real(NSUM)
                co%FLINACC(k) = co%FLINACC(k)/real(NSUM)
                co%FLUTACC(k) = co%FLUTACC(k)/real(NSUM)
                co%TAACC(k) = co%TAACC(k)/real(NSUM)
                co%UVACC(k) = co%UVACC(k)/real(NSUM)
                co%PRESACC(k) = co%PRESACC(k)/real(NSUM)
                co%QAACC(k) = co%QAACC(k)/real(NSUM)
                ALTOT = (co%ALVSACC(k) + co%ALIRACC(k))/2.0
                FSSTAR = co%FSINACC(k)*(1.0 - ALTOT)
                FLSTAR = co%FLINACC(k) - co%FLUTACC(k)
                QH = co%HFSACC(k)
                QE = co%QEVPACC(k)
                BEG = FSSTAR + FLSTAR - QH - QE
                SNOMLT = co%HMFNACC(k)
                if (co%RHOSACC(k) > 0.0) then
                    ZSN = co%SNOACC(k)/co%RHOSACC(k)
                else
                    ZSN = 0.0
                end if
                if (co%TCANACC(k) > 0.01) then
                    TCN = co%TCANACC(k) - TFREZ
                else
                    TCN = 0.0
                end if
                if (co%TSNOACC(k) > 0.01) then
                    TSN = co%TSNOACC(k) - TFREZ
                else
                    TSN = 0.0
                end if
                if (ILW == 1) then
                    GTOUT = co%GTACC(k) - TFREZ
                else
                    GTOUT = 0.0
                end if

                !> Write to the CLASSOF* output files for daily accumulated output.
                write(150 + k*10 + 1, "(I4,',', I5,',', 9(F8.2,','), 2(F8.3,','), 999(F12.4,','))") &
                    JDAY_NOW, YEAR_NOW, FSSTAR, FLSTAR, QH, QE, SNOMLT, &
                    BEG, GTOUT, co%SNOACC(k), co%RHOSACC(k), &
                    co%WSNOACC(k), ALTOT, co%ROFACC(k), co%ROFOACC(k), &
                    co%ROFSACC(k), co%ROFBACC(k)
                write(150 + k*10 + 2, "(I4,',', I5,',', " // adjustl(IGND_CHAR) // "((F8.2,','), " // &
                    "2(F6.3,',')), F8.2,',', 2(F7.4,','), 2(F8.2,','))") &
                    JDAY_NOW, YEAR_NOW, (co%TBARACC(k, j) - TFREZ, &
                    co%THLQACC(k, j), co%THICACC(k, j), j = 1, IGND), &
                    TCN, co%RCANACC(k), co%SCANACC(k), TSN, ZSN
                write(150 + k*10 + 3, "(I4,',', I5,',', 3(F9.2,','), F8.2,',', " // &
                    "F10.2,',', E12.3,',', 2(F12.3,','))") &
                    JDAY_NOW, YEAR_NOW, co%FSINACC(k), co%FLINACC(k), &
                    co%TAACC(k) - TFREZ, co%UVACC(k), co%PRESACC(k), &
                    co%QAACC(k), co%PREACC(k), co%EVAPACC(k)

                !> Reset the CLASS output variables.
                co%PREACC = 0.0
                co%GTACC = 0.0
                co%QEVPACC = 0.0
                co%EVAPACC = 0.0
                co%HFSACC = 0.0
                co%HMFNACC = 0.0
                co%ROFACC = 0.0
                co%ROFOACC = 0.0
                co%ROFSACC = 0.0
                co%ROFBACC = 0.0
                co%WTBLACC = 0.0
                co%TBARACC = 0.0
                co%THLQACC = 0.0
                co%THICACC = 0.0
                co%THALACC = 0.0
                co%GFLXACC = 0.0
                co%ALVSACC = 0.0
                co%ALIRACC = 0.0
                co%RHOSACC = 0.0
                co%TSNOACC = 0.0
                co%WSNOACC = 0.0
                co%SNOARE = 0.0
                co%TCANACC = 0.0
                co%CANARE = 0.0
                co%SNOACC = 0.0
                co%RCANACC = 0.0
                co%SCANACC = 0.0
                co%GROACC = 0.0
                co%FSINACC = 0.0
                co%FLINACC = 0.0
                co%FLUTACC = 0.0
                co%TAACC = 0.0
                co%UVACC = 0.0
                co%PRESACC = 0.0
                co%QAACC = 0.0

            end if !(NCOUNT == 48) then

        end if !(op%K_OUT(i) >= il1 .and. op%K_OUT(i) <= il2) then
    end do !i = 1, WF_NUM_POINTS

if (ipid == 0) then

!> Write ENSIM output
!> -----------------------------------------------------c
!>
IF(NR2CFILES > 0 .AND. MOD(NCOUNT*30,DELTR2C) == 0)THEN

  CALL FIND_MONTH (JDAY_NOW, YEAR_NOW, ensim_month)
  CALL FIND_DAY (JDAY_NOW, YEAR_NOW, ensim_day)
  
  CALL WRITE_R2C_DATA(NML,NLTEST,NMTEST,NCOUNT,MINS_NOW,ACLASS,    &
                      NA,XXX,YYY,XCOUNT,YCOUNT,ILMOS,JLMOS,ILG,&
                      NR2C,NR2CFILES,R2CFILEUNITSTART,GRD,GAT, &
                      GRDGAT,NR2CSTATES,R2C_ATTRIBUTES,FRAME_NO_NEW,YEAR_NOW,&
                      ensim_MONTH,ensim_DAY,HOUR_NOW,MINS_NOW,ICAN,   &
                      ICAN+1,IGND,                             &
                      TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
                      TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT,  &
                      TCANGAT,RCANGAT,SCANGAT,GROGAT, CMAIGAT, &
                      FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT, &
                      PAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT, &
                      VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,PAIDGAT, &
                      HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT, &
                      THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT, &
                      GRKSGAT,THRAGAT,HCPSGAT,TCSGAT,          &
                      THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT,         &
                      ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT,  &
                      DRNGAT, XSLPGAT,XDGAT,WFSFGAT,KSGAT,     &
                      ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT, &
                      AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT, &
                      ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT, &
                      FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT,   &
                      TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT, &
                      VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT, &
                      SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT, &
                      GGEOGAT,                                 &
                      CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
                      QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT,   &
                      GTGAT,  QGGAT,  ALVSGAT,ALIRGAT, &
                      SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT, &
                      FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
                      FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
                      HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
                      HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
                      QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT,  &
                      ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
                      TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
                      WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  GFLXGAT, &
                      HMFGGAT,HTCGAT, QFCGAT, MANNGAT,DDGAT,   &
                      IGDRGAT,VMODGAT,QLWOGAT)

  FRAME_NO_NEW = FRAME_NO_NEW + 1 !UPDATE COUNTERS

ENDIF

!> =======================================================================
!>     * CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.

!> many of these varibles are currently not being used for anything,
!> but we want to keep them because they may be useful in the future.
!> these variables hold the grid cell averages. 
!> In the future, someone will need to use them.

    CDHGRD = 0.
    CDMGRD = 0.
    HFSGRD = 0.
    TFXGRD = 0.
    QEVPGRD = 0.
    QFSGRD = 0.
    QFXGRD = 0.
    PETGRD = 0.
    GAGRD = 0.
    EFGRD = 0.
    GTGRD = 0.
    QGGRD = 0.
    TSFGRD = 0.
    ALVSGRD = 0.
    ALIRGRD = 0.
    SFCTGRD = 0.
    SFCUGRD = 0.
    SFCVGRD = 0.
    SFCQGRD = 0.
    FSNOGRD = 0.
    FSGVGRD = 0.
    FSGSGRD = 0.
    FSGGGRD = 0.
    SNOGRD = 0.
    FLGVGRD = 0.
    FLGSGRD = 0.
    FLGGGRD = 0.
    HFSCGRD = 0.
    HFSSGRD = 0.
    HFSGGRD = 0.
    HEVCGRD = 0.
    HEVSGRD = 0.
    HEVGGRD = 0.
    HMFCGRD = 0.
    HMFNGRD = 0.
    HTCCGRD = 0.
    HTCSGRD = 0.
    PCFCGRD = 0.
    PCLCGRD = 0.
    PCPNGRD = 0.
    PCPGGRD = 0.
    QFGGRD = 0.
    QFNGRD = 0.
    QFCLGRD = 0.
    QFCFGRD = 0.
    ROFGRD = 0.
    ROFOGRD = 0.
    ROFSGRD = 0.
    ROFBGRD = 0.
    ROFCGRD = 0.
    ROFNGRD = 0.
    ROVGGRD = 0.
    WTRCGRD = 0.
    WTRSGRD = 0.
    WTRGGRD = 0.
    DRGRD = 0.
    WTABGRD = 0.
    ILMOGRD = 0.
    UEGRD = 0.
    HBLGRD = 0.

      HMFGGRD = 0.
      HTCGRD = 0.
      QFCGRD = 0.
      GFLXGRD = 0.

!>
!>*******************************************************************
!>

    !> Grid data for output.
    md%fsdown = cm%clin(cfk%FB)%climvGrd
    md%fsvh = fsvhgrd
    md%fsih = fsihgrd
    md%fdl = cm%clin(cfk%FI)%climvGrd
    md%ul = cm%clin(cfk%UV)%climvGrd
    md%ta = cm%clin(cfk%TT)%climvGrd
    md%qa = cm%clin(cfk%HU)%climvGrd
    md%pres = cm%clin(cfk%P0)%climvGrd
    md%pre = cm%clin(cfk%PR)%climvGrd

!> GRU-distributed data for output.
wb_h%pre = 0.0
wb_h%evap = 0.0
wb_h%rof = 0.0
wb_h%rofo = 0.0
wb_h%rofs = 0.0
wb_h%rofb = 0.0
wb_h%rcan = 0.0
wb_h%sncan = 0.0
wb_h%pndw = 0.0
wb_h%sno = 0.0
wb_h%wsno = 0.0
wb_h%lqws = 0.0
wb_h%frws = 0.0

!$omp parallel do
DO I=1,nml
    CDHGRD(ilmos(I))=CDHGRD(ilmos(I))+CDHgat(I)*FAREGAT(i)
    CDMGRD(ilmos(I))=CDMGRD(ilmos(I))+CDMgat(I)*FAREGAT(i)
    HFSGRD(ilmos(I))=HFSGRD(ilmos(I))+HFSgat(I)*FAREGAT(i)
    TFXGRD(ilmos(I))=TFXGRD(ilmos(I))+TFXgat(I)*FAREGAT(i)
    QEVPGRD(ilmos(I))=QEVPGRD(ilmos(I))+QEVPgat(I)*FAREGAT(i)
    QFSGRD(ilmos(I))=QFSGRD(ilmos(I))+QFSgat(I)*FAREGAT(i)
    QFXGRD(ilmos(I))=QFXGRD(ilmos(I))+QFXgat(I)*FAREGAT(i)
    PETGRD(ilmos(I))=PETGRD(ilmos(I))+PETgat(I)*FAREGAT(i)
    GAGRD(ilmos(I))=GAGRD(ilmos(I))+GAgat(I)*FAREGAT(i)
    EFGRD(ilmos(I))=EFGRD(ilmos(I))+EFgat(I)*FAREGAT(i)
    GTGRD(ilmos(I))=GTGRD(ilmos(I))+GTgat(I)*FAREGAT(i)
    QGGRD(ilmos(I))=QGGRD(ilmos(I))+QGgat(I)*FAREGAT(i)
!    TSFGRD(ilmos(I))=TSFGRD(ilmos(I))+TSFgat(I)*FAREGAT(i)
    ALVSGRD(ilmos(I))=ALVSGRD(ilmos(I))+ALVSgat(I)*FAREGAT(i)
    ALIRGRD(ilmos(I))=ALIRGRD(ilmos(I))+ALIRgat(I)*FAREGAT(i)
    SFCTGRD(ilmos(I))=SFCTGRD(ilmos(I))+SFCTgat(I)*FAREGAT(i)
    SFCUGRD(ilmos(I))=SFCUGRD(ilmos(I))+SFCUgat(I)*FAREGAT(i)
    SFCVGRD(ilmos(I))=SFCVGRD(ilmos(I))+SFCVgat(I)*FAREGAT(i)
    SFCQGRD(ilmos(I))=SFCQGRD(ilmos(I))+SFCQgat(I)*FAREGAT(i)
    FSNOGRD(ilmos(I))=FSNOGRD(ilmos(I))+FSNOgat(I)*FAREGAT(i)
    FSGVGRD(ilmos(I))=FSGVGRD(ilmos(I))+FSGVgat(I)*FAREGAT(i)
    FSGSGRD(ilmos(I))=FSGSGRD(ilmos(I))+FSGSgat(I)*FAREGAT(i)
    FSGGGRD(ilmos(I))=FSGGGRD(ilmos(I))+FSGGgat(I)*FAREGAT(i)
    SNOGRD(ilmos(I))=SNOGRD(ilmos(I))+SNOgat(I)*FAREGAT(i)
    FLGVGRD(ilmos(I))=FLGVGRD(ilmos(I))+FLGVgat(I)*FAREGAT(i)
    FLGSGRD(ilmos(I))=FLGSGRD(ilmos(I))+FLGSgat(I)*FAREGAT(i)
    FLGGGRD(ilmos(I))=FLGGGRD(ilmos(I))+FLGGgat(I)*FAREGAT(i)
    HFSCGRD(ilmos(I))=HFSCGRD(ilmos(I))+HFSCgat(I)*FAREGAT(i)
    HFSSGRD(ilmos(I))=HFSSGRD(ilmos(I))+HFSSgat(I)*FAREGAT(i)
    HFSGGRD(ilmos(I))=HFSGGRD(ilmos(I))+HFSGgat(I)*FAREGAT(i)
    HEVCGRD(ilmos(I))=HEVCGRD(ilmos(I))+HEVCgat(I)*FAREGAT(i)
    HEVSGRD(ilmos(I))=HEVSGRD(ilmos(I))+HEVSgat(I)*FAREGAT(i)
    HEVGGRD(ilmos(I))=HEVGGRD(ilmos(I))+HEVGgat(I)*FAREGAT(i)
    HMFCGRD(ilmos(I))=HMFCGRD(ilmos(I))+HMFCgat(I)*FAREGAT(i)
    HMFNGRD(ilmos(I))=HMFNGRD(ilmos(I))+HMFNgat(I)*FAREGAT(i)
    HTCCGRD(ilmos(I))=HTCCGRD(ilmos(I))+HTCCgat(I)*FAREGAT(i)
    HTCSGRD(ilmos(I))=HTCSGRD(ilmos(I))+HTCSgat(I)*FAREGAT(i)
    PCFCGRD(ilmos(I))=PCFCGRD(ilmos(I))+PCFCgat(I)*FAREGAT(i)
    PCLCGRD(ilmos(I))=PCLCGRD(ilmos(I))+PCLCgat(I)*FAREGAT(i)
    PCPNGRD(ilmos(I))=PCPNGRD(ilmos(I))+PCPNgat(I)*FAREGAT(i)
    PCPGGRD(ilmos(I))=PCPGGRD(ilmos(I))+PCPGgat(I)*FAREGAT(i)
    QFGGRD(ilmos(I))=QFGGRD(ilmos(I))+QFGgat(I)*FAREGAT(i)
    QFNGRD(ilmos(I))=QFNGRD(ilmos(I))+QFNgat(I)*FAREGAT(i)
    QFCLGRD(ilmos(I))=QFCLGRD(ilmos(I))+QFCLgat(I)*FAREGAT(i)
    QFCFGRD(ilmos(I))=QFCFGRD(ilmos(I))+QFCFgat(I)*FAREGAT(i)
    ROFGRD(ilmos(I))=ROFGRD(ilmos(I))+ROFgat(I)*FAREGAT(i)
    ROFOGRD(ilmos(I))=ROFOGRD(ilmos(I))+ROFOgat(I)*FAREGAT(i)
    ROFSGRD(ilmos(I))=ROFSGRD(ilmos(I))+ROFSgat(I)*FAREGAT(i)
    ROFBGRD(ilmos(I))=ROFBGRD(ilmos(I))+ROFBgat(I)*FAREGAT(i)
    ROFCGRD(ilmos(I))=ROFCGRD(ilmos(I))+ROFCgat(I)*FAREGAT(i)
    ROFNGRD(ilmos(I))=ROFNGRD(ilmos(I))+ROFNgat(I)*FAREGAT(i)
    ROVGGRD(ilmos(I))=ROVGGRD(ilmos(I))+ROVGgat(I)*FAREGAT(i)
    WTRCGRD(ilmos(I))=WTRCGRD(ilmos(I))+WTRCgat(I)*FAREGAT(i)
    WTRSGRD(ilmos(I))=WTRSGRD(ilmos(I))+WTRSgat(I)*FAREGAT(i)
    WTRGGRD(ilmos(I))=WTRGGRD(ilmos(I))+WTRGgat(I)*FAREGAT(i)
    DRGRD(ilmos(I))=DRGRD(ilmos(I))+DRgat(I)*FAREGAT(i)
    WTABGRD(ilmos(I))=WTABGRD(ilmos(I))+WTABgat(I)*FAREGAT(i)
    ILMOGRD(ilmos(I))=ILMOGRD(ilmos(I))+ILMOgat(I)*FAREGAT(i)
    UEGRD(ilmos(I))=UEGRD(ilmos(I))+UEgat(I)*FAREGAT(i)
    HBLGRD(ilmos(I))=HBLGRD(ilmos(I))+HBLgat(I)*FAREGAT(i)
    wb_h%pre(ilmos(I)) = wb_h%pre(ilmos(I)) + FAREGAT(i)*PREGAT(i)*delt
    wb_h%evap(ilmos(I)) = wb_h%evap(ilmos(I)) + FAREGAT(i)*qfsgat(i)*delt
    wb_h%rof(ilmos(I)) = wb_h%rof(ilmos(I)) + FAREGAT(i)*rofgat(i)*delt
    wb_h%rofo(ilmos(I)) = wb_h%rofo(ilmos(I)) + FAREGAT(i)*rofogat(i)*delt
    wb_h%rofs(ilmos(I)) = wb_h%rofs(ilmos(I)) + FAREGAT(i)*rofsgat(i)*delt
    wb_h%rofb(ilmos(I)) = wb_h%rofb(ilmos(I)) + FAREGAT(i)*rofbgat(i)*delt
    wb_h%rcan(ilmos(I)) = wb_h%rcan(ilmos(I)) + FAREGAT(i)*rcangat(i)
    wb_h%sncan(ilmos(I)) = wb_h%sncan(ilmos(I)) + FAREGAT(i)*scangat(i)
    wb_h%pndw(ilmos(I)) = wb_h%pndw(ilmos(I)) + FAREGAT(i)*zpndgat(i)*rhow
    wb_h%sno(ilmos(I)) = wb_h%sno(ilmos(I)) + FAREGAT(i)*snogat(i)
    wb_h%wsno(ilmos(I)) = wb_h%wsno(ilmos(I)) + FAREGAT(i)*wsnogat(i)
    DO J=1,IGND
        HMFGGRD(ilmos(I),J)=HMFGGRD(ilmos(I),J)+HMFGgat(I,J)*FAREGAT(i)
        HTCGRD(ilmos(I),J)=HTCGRD(ilmos(I),J)+HTCgat(I,J)*FAREGAT(i)
        QFCGRD(ilmos(I),J)=QFCGRD(ilmos(I),J)+QFCgat(I,J)*FAREGAT(i)
        GFLXGRD(ilmos(I),J)=GFLXGRD(ilmos(I),J)+GFLXgat(I,J)*FAREGAT(i)
        wb_h%lqws(ilmos(I), j) = wb_h%lqws(ilmos(I), j) + FAREGAT(i) &
                                     *thlqgat(i, j)*dlzwgat(i, j)*rhow
        wb_h%frws(ilmos(I), j) = wb_h%frws(ilmos(I), j) + FAREGAT(i) &
                                     *thicgat(i, j)*dlzwgat(i, j)*rhoice
    ENDDO
    wb_h%stg(ilmos(I)) = wb%rcan(ilmos(I)) + wb%sncan(ilmos(I)) + wb%pndw(ilmos(I)) + wb%sno(ilmos(I)) + wb%wsno(ilmos(I)) + &
        sum(wb%lqws(ilmos(I), :)) + sum(wb%frws(ilmos(I), :))
ENDDO !DO I=1,nml

    CALL tile_connector(runoff, recharge, leakages, ncount, ROFOGRD, ROFSGRD, ROFBGRD, DELT)
!>
!> *******************************************************************
!> FOR SPL WATROUTE (MODIFIED RPN CODE)
!> *******************************************************************
!>
!> FILES ARE ONLY WRITTEN ON THE HOUR (WATROUTE READS HOURLY DATA).
!> HOURLY TIME STEPS ARE ODD-NUMBERED INTEGERS.
!>
!todo: these can be removed at some point, as they've been added
!todo: as flags as a part of the model_output module.
    if (mod(real(NCOUNT), 2.0) == 0.0) then !HOURLY TIME STEP
        EF_YEAR_NOW = YEAR_NOW
        call FIND_MONTH(JDAY_NOW, YEAR_NOW, EF_MONTH_NOW)
        call FIND_DAY(JDAY_NOW, YEAR_NOW, EF_DAY_NOW)
        EF_HOUR_NOW = HOUR_NOW + 1 !ROUTING USES 1-24 RANGE, MESH USES 0-23
!>
!> WRITE OUTPUT FOR RTE.EXE (RUNOFF)
!>
        if (PRINTRFFR2CFILEFLAG == 1) then
            OUTARRAY = RUNOFF !PASS RUNOFF TO OUTARRAY IN WRITE_R2C
            call WRITE_R2C(261, 31, NO_FRAMES, 1, FRAME_NO, 1, 6, &
                           EF_YEAR_NOW, EF_MONTH_NOW, EF_DAY_NOW, EF_HOUR_NOW)
        end if
!>
!> WRITE OUTPUT FOR RTE.EXE (RECHARGE)
!>
        if (PRINTRCHR2CFILEFLAG == 1) THEN !WRITE RECHARGE DATA
            OUTARRAY = RECHARGE !PASS RUNOFF TO OUTARRAY IN WRITE_R2C
            call WRITE_R2C(262, 32, NO_FRAMES, 1, FRAME_NO, 1, 6, &
                           EF_YEAR_NOW, EF_MONTH_NOW, EF_DAY_NOW, EF_HOUR_NOW)
        end if
!>
!> UPDATE COUNTERS
!>
        FRAME_NO = FRAME_NO + 1
        NO_FRAMES = FRAME_NO + 1
    end if !(mod(real(NCOUNT), 2.0) == 0.0) then

!> calculate and write the basin avg SCA similar to watclass3.0f5
!> Same code than in wf_ensim.f subrutine of watclass3.0f8
!> Especially for version MESH_Prototype 3.3.1.7b (not to be incorporated in future versions)
!> calculate and write the basin avg SWE using the similar fudge factor!!!

IF (BASIN_FRACTION(1) == -1) THEN
  DO I = 1, NA ! NA = number of grid squares
!>         BASIN_FRACTION is the basin snow cover
!>         (portions of the grids outside the basin are not included)
!>         for a given day - JDAY_NOW in the if statement
    BASIN_FRACTION(I) = FRAC(I)
    !TODO: FRAC is not actually the fraction of the grid square
    !within the basin, we should be using some other value, but I'm
    !not sure what.
    !todo: calculate frac and write document to send to someone else.
  ENDDO
ENDIF

IF((HOUR_NOW==12).AND.(MINS_NOW==0))  THEN

    basin_SCA = 0.0
    basin_SWE = 0.0

!    do I=1,NA
!       if(BASIN_FRACTION(I)/=0.0) then
!          basin_SCA = basin_SCA + FSNOGRD(I)/BASIN_FRACTION(I)
!          basin_SWE = basin_SWE + SNOGRD(I)/BASIN_FRACTION(I)
!       endif
!    enddo
!
!   basin_SCA = basin_SCA/NA
!   basin_SWE = basin_SWE/NA

! BRUCE DAVISON - AUG 17, 2009 (see notes in my notebook for this day)
! Fixed calculation of basin averages. Needs documenting and testing.
    do I=1,NML
       basin_SCA = basin_SCA + FSNOGAT(I)*FAREGAT(i)
       basin_SWE = basin_SWE + SNOGAT(I)*FAREGAT(i)
    enddo

   basin_SCA = basin_SCA/TOTAL_AREA
   basin_SWE = basin_SWE/TOTAL_AREA

    if (BASINSWEOUTFLAG > 0) then
        write(85, "(i5, ',', f10.3)") JDAY_NOW, basin_SCA
        write(86, "(i5, ',', f10.3)") JDAY_NOW, basin_SWE
    end if

ENDIF

!> =======================================================================
!> ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.

!$omp parallel do
DO I = 1, nml
   IF(FRAC(ilmos(I)) /= 0.0)THEN
         PREACC(ilmos(I))  = PREACC(ilmos(I)) + PREGAT(i)* FAREGAT(i)*DELT
         GTACC(ilmos(I))   = GTACC(ilmos(I))  + GTgat(I)*  FAREGAT(i)
         QEVPACC(ilmos(I)) = QEVPACC(ilmos(I))+ QEVPgat(I)*FAREGAT(i)
         EVAPACC(ilmos(I)) = EVAPACC(ilmos(I))+ QFSgat(I)* FAREGAT(i)*DELT
         HFSACC(ilmos(I))  = HFSACC(ilmos(I)) + HFSgat(I)* FAREGAT(i)
         HMFNACC(ilmos(I)) = HMFNACC(ilmos(I))+ HMFNgat(I)*FAREGAT(i)
         ROFACC(ilmos(I))  = ROFACC(ilmos(I)) + ROFgat(I)* FAREGAT(i)*DELT
         ROFOACC(ilmos(I)) = ROFOACC(ilmos(I))+ ROFOgat(I)*FAREGAT(i)*DELT
         ROFSACC(ilmos(I)) = ROFSACC(ilmos(I))+ ROFSgat(I)*FAREGAT(i)*DELT
         ROFBACC(ilmos(I)) = ROFBACC(ilmos(I))+ ROFBgat(I)*FAREGAT(i)*DELT
         WTBLACC(ilmos(I)) = WTBLACC(ilmos(I))+ WTABgat(I)*FAREGAT(i)
            DO J = 1, IGND
            TBARACC(ilmos(I),J) = TBARACC(ilmos(I),J)+TBARgat(I,J)*ACLASS(ilmos(I),jlmos(i))
            THLQACC(ilmos(I),J) = THLQACC(ilmos(I),J)+THLQgat(I,J)*FAREGAT(i)
            THICACC(ilmos(I),J) = THICACC(ilmos(I),J)+THICgat(I,J)*FAREGAT(i)
            THALACC(ilmos(I),J) = THALACC(ilmos(I),J)+(THLQgat(I,J)+ &
                                         THICgat(I,J))*FAREGAT(i)

            !Added by GSA compute daily heat conduction flux between layers
            GFLXACC(ilmos(I),J) = GFLXACC(ilmos(I),J)+GFLXgat(I,J)*FAREGAT(i)

            !(I) = THALACC_STG(I) + THALACC(I,J)
                THLQ_FLD(ilmos(I),J) =  THLQ_FLD(ilmos(I),J) + THLQgat(I,J)*RHOW*FAREGAT(i)*DLZWgat(I,J)
                THIC_FLD(ilmos(I),J) =  THIC_FLD(ilmos(I),J) + THICgat(I,J)*RHOICE*FAREGAT(i)*DLZWgat(I,J)
         ENDDO
         ALVSACC(ilmos(I)) = ALVSACC(ilmos(I))+ALVSgat(I)*FAREGAT(i)*FSVHGRD(ilmos(I))
         ALIRACC(ilmos(I)) = ALIRACC(ilmos(I))+ALIRgat(I)*FAREGAT(i)*FSIHGRD(ilmos(I))
         IF(SNOgat(I)>0.0) THEN
            RHOSACC(ilmos(I)) = RHOSACC(ilmos(I))+RHOSgat(I)*FAREGAT(i)
            TSNOACC(ilmos(I)) = TSNOACC(ilmos(I))+TSNOgat(I)*FAREGAT(i)
            WSNOACC(ilmos(I)) = WSNOACC(ilmos(I))+WSNOgat(I)*FAREGAT(i)
            SNOARE(ilmos(I))  = SNOARE(ilmos(I))+FAREGAT(i)
         ENDIF
         IF(TCANgat(I) > 0.5) THEN
            TCANACC(ilmos(I)) = TCANACC(ilmos(I))+TCANgat(I)*FAREGAT(i)
            CANARE(ilmos(I))  = CANARE(ilmos(I))+FAREGAT(i)
         ENDIF
         SNOACC(ilmos(I))  = SNOACC(ilmos(I))+SNOgat(I)*FAREGAT(i)
         RCANACC(ilmos(I)) = RCANACC(ilmos(I))+RCANgat(I)*FAREGAT(i)
         SCANACC(ilmos(I)) = SCANACC(ilmos(I))+SCANgat(I)*FAREGAT(i)
         GROACC(ilmos(I))  = GROACC(ilmos(I))+GROgat(I)*FAREGAT(i)
         FSINACC(ilmos(I)) = FSINACC(ilmos(I))+cm%clin(cfk%FB)%climvGrd(ilmos(I))*FAREGAT(i)
         FLINACC(ilmos(I)) = FLINACC(ilmos(I))+cm%clin(cfk%FI)%climvGrd(ilmos(I))*FAREGAT(i)
         FLUTACC(ilmos(I)) = FLUTACC(ilmos(I))+SBC*GTgat(I)**4*FAREGAT(i)
         TAACC(ilmos(I))   = TAACC(ilmos(I))+cm%clin(cfk%TT)%climvGrd(ilmos(I))*FAREGAT(i)
         UVACC(ilmos(I))   = UVACC(ilmos(I))+UVGRD(ilmos(I))*FAREGAT(i)
         PRESACC(ilmos(I)) = PRESACC(ilmos(I))+cm%clin(cfk%P0)%climvGrd(ilmos(I))*FAREGAT(i)
         QAACC(ilmos(I))   = QAACC(ilmos(I))+cm%clin(cfk%HU)%climvGrd(ilmos(I))*FAREGAT(i)
   ENDIF
ENDDO !DO I=1,nml

    !> Update output data.
    call updatefieldsout_temp(vr, ts, iof, bi, &
                              md, wb_h, &
                              YEAR_NOW, JDAY_NOW, ceiling(NCOUNT/2.0), TIME_STEP_DELT - mod(NCOUNT, 2)*TIME_STEP_DELT)

!> CALCULATE AND PRINT DAILY AVERAGES.

!todo: use delta t here
IF(NCOUNT==48) THEN !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

    !no omp b/c of file IO
  DO I=1,NA
  IF(FRAC(I) /= 0.0)THEN
            PREACC(I) = PREACC(I)
            GTACC(I) = GTACC(I)/REAL(NSUM)
            QEVPACC(I) = QEVPACC(I)/REAL(NSUM)
            EVAPACC(I) = EVAPACC(I)
            HFSACC(I) = HFSACC(I)/REAL(NSUM)
            HMFNACC(I) = HMFNACC(I)/REAL(NSUM)
            ROFACC(I) = ROFACC(I)
            ROFOACC(I) = ROFOACC(I)
            ROFSACC(I) = ROFSACC(I)
            ROFBACC(I) = ROFBACC(I)
            WTBLACC(I) = WTBLACC(I)/REAL(NSUM)

    DO J=1,IGND
                TBARACC(I,J) = TBARACC(I,J)/REAL(NSUM)
                THLQACC(I,J) = THLQACC(I,J)/REAL(NSUM)
                THICACC(I,J) = THICACC(I,J)/REAL(NSUM)
                THALACC(I,J) = THALACC(I,J)/REAL(NSUM)
    ENDDO

    IF(FSINACC(I)>0.0) THEN
      ALVSACC(I)=ALVSACC(I)/(FSINACC(I)*0.5)
      ALIRACC(I)=ALIRACC(I)/(FSINACC(I)*0.5)
            ELSE
      ALVSACC(I)=0.0
      ALIRACC(I)=0.0
    ENDIF

    IF(SNOARE(I)>0.0) THEN
      RHOSACC(I)=RHOSACC(I)/SNOARE(I)
      TSNOACC(I)=TSNOACC(I)/SNOARE(I)
      WSNOACC(I)=WSNOACC(I)/SNOARE(I)
    ENDIF

    IF(CANARE(I)>0.0) THEN
      TCANACC(I)=TCANACC(I)/CANARE(I)
    ENDIF

    SNOACC(I)=SNOACC(I)/REAL(NSUM)
    RCANACC(I)=RCANACC(I)/REAL(NSUM)
    SCANACC(I)=SCANACC(I)/REAL(NSUM)
    GROACC(I)=GROACC(I)/REAL(NSUM)
    FSINACC(I)=FSINACC(I)/REAL(NSUM)
    FLINACC(I)=FLINACC(I)/REAL(NSUM)
    FLUTACC(I)=FLUTACC(I)/REAL(NSUM)
    TAACC(I)=TAACC(I)/REAL(NSUM)
    UVACC(I)=UVACC(I)/REAL(NSUM)
    PRESACC(I)=PRESACC(I)/REAL(NSUM)
    QAACC(I)=QAACC(I)/REAL(NSUM)
!* ALTOT: the average of the visible spectrum and infrared spectrum
    ALTOT=(ALVSACC(I)+ALIRACC(I))/2.0
    FSSTAR=FSINACC(I)*(1.-ALTOT)
    FLSTAR=FLINACC(I)-FLUTACC(I)
    QH=HFSACC(I)
    QE=QEVPACC(I)
    BEG=FSSTAR+FLSTAR-QH-QE
    SNOMLT=HMFNACC(I)
    IF(RHOSACC(I)>0.0) THEN
      ZSN=SNOACC(I)/RHOSACC(I)
            ELSE
      ZSN=0.0
    ENDIF

    IF(TCANACC(I)>0.01) THEN 
      TCN=TCANACC(I)-TFREZ
            ELSE
      TCN=0.0
    ENDIF

    IF(TSNOACC(I)>0.01) THEN 
      TSN=TSNOACC(I)-TFREZ
            ELSE
      TSN=0.0
    ENDIF

    IF(ILW==1) THEN
      GTOUT=GTACC(I)-TFREZ
            ELSE
      GTOUT=0.0
    ENDIF

!> update components for final water balance tally
    TOTAL_PRE     = TOTAL_PRE     + PREACC(I)
    TOTAL_EVAP    = TOTAL_EVAP    + EVAPACC(I)
    TOTAL_ROF     = TOTAL_ROF     + ROFACC(I)
    TOTAL_ROFO    = TOTAL_ROFO    + ROFOACC(I)
    TOTAL_ROFS    = TOTAL_ROFS    + ROFSACC(I)
    TOTAL_ROFB    = TOTAL_ROFB    + ROFBACC(I)
    TOTAL_PREACC  = TOTAL_PREACC  + PREACC(I)
    TOTAL_EVAPACC = TOTAL_EVAPACC + EVAPACC(I)
    TOTAL_ROFACC  = TOTAL_ROFACC  + ROFACC(I)
    TOTAL_ROFOACC = TOTAL_ROFOACC + ROFOACC(I)
    TOTAL_ROFSACC = TOTAL_ROFSACC + ROFSACC(I)
    TOTAL_ROFBACC = TOTAL_ROFBACC + ROFBACC(I)
    wb%pre(i) = wb%pre(i) + preacc(i)
    wb%evap(i) = wb%evap(i) + evapacc(i)
    wb%rof(i) = wb%rof(i) + rofacc(i)
    wb%rofo(i) = wb%rofo(i) + rofoacc(i)
    wb%rofs(i) =  wb%rofs(i) + rofsacc(i)
    wb%rofb(i) = wb%rofb(i) + rofbacc(i)

!> update components for final energy balance tally
    TOTAL_HFSACC  = TOTAL_HFSACC  + HFSACC(I)
    TOTAL_QEVPACC = TOTAL_QEVPACC + QEVPACC(I)
    eng%hfs(i) = eng%hfs(i) + HFSACC(I)
    eng%qevp(i) = eng%qevp(i) + QEVPACC(I)
    DO J=1,IGND
      eng%gflx(i,j) = eng%gflx(i,j) + GFLXACC(I,J)
    ENDDO
  ENDIF
            END DO

    !> update components for final water balance tally
    wb%rcan = 0.0
    wb%sncan = 0.0
    wb%pndw = 0.0
    wb%sno = 0.0
    wb%wsno = 0.0
    wb%lqws = 0.0
    wb%frws = 0.0
    sov%tbar = 0.0
    sov%thic = 0.0
    sov%thic = 0.0

    DO I = 1, nml
        IF (FRAC(ilmos(I)) >= 0.0) THEN
!            DO M = 1, NMTEST
                TOTAL_SCAN = TOTAL_SCAN + FAREGAT(i)*SCANgat(I)
                TOTAL_RCAN = TOTAL_RCAN + FAREGAT(i)*RCANgat(I)
                TOTAL_SNO = TOTAL_SNO + FAREGAT(i)*SNOgat(I)
                TOTAL_WSNO = TOTAL_WSNO + FAREGAT(i)*WSNOgat(I)
                TOTAL_ZPND = TOTAL_ZPND + FAREGAT(i)*ZPNDgat(I)*RHOW
                wb%rcan(ilmos(I)) = wb%rcan(ilmos(I)) + FAREGAT(i)*scangat(i)
                wb%sncan(ilmos(I)) = wb%sncan(ilmos(I)) + FAREGAT(i)*rcangat(i)
                wb%pndw(ilmos(I)) = wb%pndw(ilmos(I)) + FAREGAT(i)*zpndgat(i)*rhow
                wb%sno(ilmos(I)) = wb%sno(ilmos(I)) + FAREGAT(i)*snogat(i)
                wb%wsno(ilmos(I)) = wb%wsno(ilmos(I)) + FAREGAT(i)*wsnogat(i)
                DO J = 1, IGND
                    TOTAL_THLQ(J) = TOTAL_THLQ(J) + FAREGAT(i)*THLQgat(I, J)*RHOW*DLZWgat(I, J)
                    TOTAL_THIC(J) = TOTAL_THIC(J) + FAREGAT(i)*THICgat(I, J)*RHOICE*DLZWgat(I, J)
                    wb%lqws(ilmos(I), j) = wb%lqws(ilmos(I), j) + FAREGAT(i) &
                                               *thlqgat(i, j)*rhow*dlzwgat(i, j)
                    wb%frws(ilmos(I), j) = wb%frws(ilmos(I), j) + FAREGAT(i) &
                                               *thicgat(i, j)*rhoice*dlzwgat(i, j)
                    sov%tbar(ilmos(I),j) = sov%tbar(ilmos(I), j) + TBARgat(I,J)*ACLASS(ilmos(I),jlmos(i))                    
                    sov%thic(ilmos(I),j) = sov%thic(ilmos(I), j) + FAREGAT(i)*thicgat(i, j)
                    sov%thlq(ilmos(I),j) = sov%thlq(ilmos(I), j) + FAREGAT(i)*thlqgat(i, j)
                END DO
!            END DO
        END IF !IF (FRAC(I) >= 0.0) THEN
    END DO !DO I = 1, nml

    !> Calculate storage
    wb%stg = wb%rcan + wb%sncan + wb%pndw + wb%sno + wb%wsno + &
                sum(wb%lqws, 2) + sum(wb%frws, 2)
    wb%dstg = wb%stg - wb%dstg

    TOTAL_STORE = TOTAL_SCAN + TOTAL_RCAN + TOTAL_SNO + TOTAL_WSNO + TOTAL_ZPND + &
        sum(TOTAL_THLQ) + sum(TOTAL_THIC)

    !> Write output CSV files.
    if (BASINBALANCEOUTFLAG > 0) then

        !> Water balance.
        write(fls%fl(mfk%f900)%iun, "((i4, ','), (i5, ','), 999(e14.6, ','))") &
            JDAY_NOW, YEAR_NOW              , &   !1
            TOTAL_PREACC/TOTAL_AREA  , &   !2
            TOTAL_EVAPACC/TOTAL_AREA , &   !3
            TOTAL_ROFACC/TOTAL_AREA  , &   !4
            TOTAL_ROFOACC/TOTAL_AREA , &   !5
            TOTAL_ROFSACC/TOTAL_AREA , &   !6
            TOTAL_ROFBACC/TOTAL_AREA , &   !7
            TOTAL_PRE/TOTAL_AREA     , &   !8
            TOTAL_EVAP/TOTAL_AREA    , &   !9
            TOTAL_ROF/TOTAL_AREA     , &   !10
            TOTAL_ROFO/TOTAL_AREA    , &   !11
            TOTAL_ROFS/TOTAL_AREA    , &   !12
            TOTAL_ROFB/TOTAL_AREA    , &   !13
            TOTAL_SCAN/TOTAL_AREA    , &   !15
            TOTAL_RCAN/TOTAL_AREA    , &   !16
            TOTAL_SNO/TOTAL_AREA     , &   !14
            TOTAL_WSNO/TOTAL_AREA, &
            TOTAL_ZPND/TOTAL_AREA    , &   !17
            (TOTAL_THLQ(J)/TOTAL_AREA, j = 1, ignd), &
            (TOTAL_THIC(J)/TOTAL_AREA, j = 1, ignd), &
            ((TOTAL_THLQ(J) + TOTAL_THIC(J))/TOTAL_AREA, j = 1, ignd), &
            SUM(TOTAL_THLQ(1:ignd))/TOTAL_AREA, &
            SUM(TOTAL_THIC(1:ignd))/TOTAL_AREA, &
            (SUM(TOTAL_THLQ(1:ignd)) + SUM(TOTAL_THIC(1:ignd)))/TOTAL_AREA, &
            TOTAL_STORE/TOTAL_AREA, &
            (TOTAL_STORE - TOTAL_STORE_2)/TOTAL_AREA, &
            (TOTAL_STORE - INIT_STORE)/TOTAL_AREA

        !> Energy balance.
        write(901, "((i4, ','), (i5, ','), 999(e12.5, ','))") &
            JDAY_NOW, YEAR_NOW,    &
            TOTAL_HFSACC/TOTAL_AREA,  &
            TOTAL_QEVPACC/TOTAL_AREA

        ! Monthly totals.
        TOTAL_PRE_ACC_M = TOTAL_PRE_ACC_M + TOTAL_PRE
        TOTAL_EVAP_ACC_M = TOTAL_EVAP_ACC_M + TOTAL_EVAP
        TOTAL_ROF_ACC_M = TOTAL_ROF_ACC_M + TOTAL_ROF
        TOTAL_ROFO_ACC_M = TOTAL_ROFO_ACC_M + TOTAL_ROFO
        TOTAL_ROFS_ACC_M = TOTAL_ROFS_ACC_M + TOTAL_ROFS
        TOTAL_ROFB_ACC_M = TOTAL_ROFB_ACC_M + TOTAL_ROFB
        TOTAL_PRE_M = TOTAL_PRE_M + TOTAL_PRE
        TOTAL_EVAP_M = TOTAL_EVAP_M + TOTAL_EVAP
        TOTAL_ROF_M = TOTAL_ROF_M + TOTAL_ROF
        TOTAL_ROFO_M = TOTAL_ROFO_M + TOTAL_ROFO
        TOTAL_ROFS_M = TOTAL_ROFS_M + TOTAL_ROFS
        TOTAL_ROFB_M = TOTAL_ROFB_M + TOTAL_ROFB
        TOTAL_SCAN_M = TOTAL_SCAN_M + TOTAL_SCAN
        TOTAL_RCAN_M = TOTAL_RCAN_M + TOTAL_RCAN
        TOTAL_SNO_M = TOTAL_SNO_M + TOTAL_SNO
        TOTAL_WSNO_M = TOTAL_WSNO_M + TOTAL_WSNO
        TOTAL_ZPND_M = TOTAL_ZPND_M + TOTAL_ZPND
        TOTAL_THLQ_M = TOTAL_THLQ_M + TOTAL_THLQ
        TOTAL_THIC_M = TOTAL_THIC_M + TOTAL_THIC
        TOTAL_STORE_M = TOTAL_STORE
        TOTAL_STORE_ACC_M = TOTAL_STORE

        ! Write out monthly totals.
        call FIND_MONTH(JDAY_NOW, YEAR_NOW, imonth_now)
        if (imonth_now /= imonth_old) then

            write(902, "((i4, ','), (i5, ','), 999(e14.6, ','))") &
                JDAY_NOW, YEAR_NOW, &
                TOTAL_PRE_ACC_M/TOTAL_AREA, &
                TOTAL_EVAP_ACC_M/TOTAL_AREA, &
                TOTAL_ROF_ACC_M/TOTAL_AREA, &
                TOTAL_ROFO_ACC_M/TOTAL_AREA, &
                TOTAL_ROFS_ACC_M/TOTAL_AREA, &
                TOTAL_ROFB_ACC_M/TOTAL_AREA, &
                TOTAL_PRE_M/TOTAL_AREA, &
                TOTAL_EVAP_M/TOTAL_AREA, &
                TOTAL_ROF_M/TOTAL_AREA, &
                TOTAL_ROFO_M/TOTAL_AREA, &
                TOTAL_ROFS_M/TOTAL_AREA, &
                TOTAL_ROFB_M/TOTAL_AREA, &
                TOTAL_SCAN_M/TOTAL_AREA, &
                TOTAL_RCAN_M/TOTAL_AREA, &
                TOTAL_SNO_M/TOTAL_AREA, &
                TOTAL_WSNO_M/TOTAL_AREA, &
                TOTAL_ZPND_M/TOTAL_AREA, &
                (TOTAL_THLQ_M(j)/TOTAL_AREA, j = 1, IGND), &
                (TOTAL_THIC_M(j)/TOTAL_AREA, j = 1, IGND), &
                ((TOTAL_THLQ_M(j) + TOTAL_THIC_M(j))/TOTAL_AREA, j = 1, IGND), &
                sum(TOTAL_THLQ_M(1:IGND))/TOTAL_AREA, &
                sum(TOTAL_THIC_M(1:IGND))/TOTAL_AREA, &
                (sum(TOTAL_THLQ_M(1:IGND)) + sum(TOTAL_THIC_M(1:IGND)))/TOTAL_AREA, &
                TOTAL_STORE_M/TOTAL_AREA, &
                (TOTAL_STORE_M - TOTAL_STORE_2_M)/TOTAL_AREA, &
                (TOTAL_STORE_ACC_M - INIT_STORE)/TOTAL_AREA

                TOTAL_PRE_M = 0.0
                TOTAL_EVAP_M = 0.0
                TOTAL_ROF_M = 0.0
                TOTAL_ROFO_M = 0.0
                TOTAL_ROFS_M = 0.0
                TOTAL_ROFB_M = 0.0
                TOTAL_SCAN_M = 0.0
                TOTAL_RCAN_M = 0.0
                TOTAL_SNO_M = 0.0
                TOTAL_WSNO_M = 0.0
                TOTAL_ZPND_M = 0.0
                TOTAL_THLQ_M = 0.0
                TOTAL_THIC_M = 0.0
                TOTAL_STORE_2_M = TOTAL_STORE_M
                TOTAL_STORE_M = 0.0

                imonth_old = imonth_now

        end if

    end if !(BASINBALANCEOUTFLAG > 0) then

!>  Added by Gonzalo Sapriza
    !DELTA STORAGE
    DO I = 1, IGND
        DSTG = DSTG + THLQ_FLD(:,I) + THIC_FLD(:,I)
    ENDDO
    DSTG = DSTG + RCANACC + SCANACC + SNOACC - STG_I

    if (OUTFIELDSFLAG == 1) then
        call UpdateFIELDSOUT(vr, ts, iof, &
                             wb%pre, wb%evap, wb%rof, wb%dstg, &
                             sov%tbar, wb%lqws, wb%frws, &
                             wb%rcan, wb%sncan, &
                             wb%pndw, wb%sno, wb%wsno, &
                             eng%gflx, eng%hfs, eng%qevp, &
                             sov%thlq, sov%thic ,&
                             NA, IGND, &
                             JDAY_NOW, YEAR_NOW)
    end if
   STG_I = DSTG + STG_I

!RESET ACCUMULATION VARIABLES TO ZERO

!> RESET ACCUMULATOR ARRAYS.

    PREACC  = 0.
    GTACC   = 0.
    QEVPACC = 0.
    HFSACC  = 0.
    HMFNACC = 0.
    ROFACC  = 0.
    SNOACC  = 0.
    CANARE  = 0.
    SNOARE  = 0.
    ROFOACC = 0.
    ROFSACC = 0.
    ROFBACC = 0.
    WTBLACC = 0.
      TBARACC = 0.
      THLQACC = 0.
      THICACC = 0.
      THALACC = 0.
      GFLXACC = 0.
    ALVSACC = 0.
    ALIRACC = 0.
    RHOSACC = 0.
    TSNOACC = 0.
    WSNOACC = 0.
    TCANACC = 0.
    RCANACC = 0.
    SCANACC = 0.
    GROACC  = 0.
    FSINACC = 0.
    FLINACC = 0.
    TAACC   = 0.
    UVACC   = 0.
    PRESACC = 0.
    QAACC   = 0.
    EVAPACC = 0.
    FLUTACC = 0.

TOTAL_STORE_2 = TOTAL_STORE
TOTAL_STORE = 0.0
TOTAL_RCAN = 0.0
TOTAL_SCAN = 0.0
TOTAL_SNO = 0.0
TOTAL_WSNO = 0.0
TOTAL_ZPND = 0.0
TOTAL_THLQ = 0.0
TOTAL_THIC = 0.0
TOTAL_PRE=0.0
TOTAL_EVAP=0.0
TOTAL_ROF=0.0
TOTAL_ROFO=0.0
TOTAL_ROFS=0.0
TOTAL_ROFB=0.0
TOTAL_HFSACC = 0.0
TOTAL_QEVPACC = 0.0

eng%gflx = 0.0
eng%hfs  = 0.0
eng%qevp = 0.0

sov%tbar = 0.0
sov%thic = 0.0
sov%thlq = 0.0

THIC_FLD = 0.
THLQ_FLD = 0.
DSTG     = 0.
    
ENDIF  ! IF(NCOUNT==48) THEN

end if !(ipid == 0)

NCOUNT=NCOUNT+1 !todo: does this work with hourly forcing data?
NSUM=NSUM+1
NSUM_TOTAL=NSUM_TOTAL+1
IF(NCOUNT>48) THEN !48 is the last half-hour period of the day
                      ! when they're numbered 1-48
  NCOUNT=1
  NSUM=1
ENDIF

!> *********************************************************************
!> Call routing routine
!> *********************************************************************
if (ipid == 0) then

CALL WF_ROUTE(WF_ROUTETIMESTEP,WF_R1,WF_R2, &
     NA,NAA,NTYPE,YCOUNT,XCOUNT,IYMIN, &
     WF_IYMAX,JXMIN,WF_JXMAX,YYY,XXX,WF_IBN,WF_IROUGH, &
     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE, &
     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE,WF_ELEV,FRAC, &
     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX, &
     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R, &
     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME, &
     WF_B1,WF_B2,WF_QREL, WF_QR, &
     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2, &
     WF_STORE1,WF_STORE2, &
     DRIVERTIMESTEP,ROFGRD, NA, M_C,M_R,M_S, NA, &
     WF_S, JAN,JDAY_NOW,HOUR_NOW,MINS_NOW)

DO I=1,WF_NO
  WF_QSYN(I)     = WF_QO2(WF_S(I))
  WF_QSYN_AVG(I) = WF_QSYN_AVG(I) + WF_QO2(WF_S(I))
  WF_QSYN_CUM(I) = WF_QSYN_CUM(I) + WF_QO2(WF_S(I)) 
  WF_QHYD_AVG(I) = WF_QHYD(I) !(MAM)THIS SEEMS WORKING OKAY (AS IS THE CASE IN THE READING) FOR A DAILY STREAM FLOW DATA.
ENDDO

IF (JAN == 1) THEN
!>     this is done so that INIT_STORE is not recalculated for
!>     each iteration when wf_route is not used
  JAN = 2
ENDIF



!> *********************************************************************
!> Write measured and simulated streamflow to file and screen
!> Also write daily summary (pre, evap, rof)
!> *********************************************************************

    !> Write output for hourly streamflow.
    if (STREAMFLOWFLAG == 1 .and. STREAMFLOWOUTFLAG >= 2) then
        write(71, 5085) JDAY_NOW, HOUR_NOW, MINS_NOW, (WF_QHYD(i), WF_QSYN(i), i = 1, WF_NO)
    end if

IF(NCOUNT==48) THEN !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

  DO I = 1, WF_NO
    WF_QHYD_CUM(I) = WF_QHYD_CUM(I) + WF_QHYD_AVG(I)
  ENDDO

    !> Write output for daily and cumulative daily streamflow.
    if (STREAMFLOWOUTFLAG > 0) then
        write(fls%fl(mfk%f70)%iun, 5084) JDAY_NOW, (WF_QHYD_AVG(i), WF_QSYN_AVG(i)/NCOUNT, i = 1, WF_NO)
        if (STREAMFLOWOUTFLAG >= 2) then
            write(72, 5084) JDAY_NOW, (WF_QHYD_CUM(i), WF_QSYN_CUM(i)/NCOUNT, i = 1, WF_NO)
        end if
    end if

5084 format(i5,',', f10.3, 999(',', f10.3))
5085 format(3(i5,','), f10.3, 999(',', f10.3))

if (ro%VERBOSEMODE > 0) then

  IF (WF_NUM_POINTS .GT. 1) THEN !FOR MORE THAN ONE OUTPUT

    print 5176, YEAR_NOW, JDAY_NOW, (WF_QHYD_AVG(I), WF_QSYN_AVG(I)/NCOUNT, I = 1, WF_NO)

  ELSE !FOR GENERAL CASE OR SINGLE GRID OUTPUT POINT

    !todo: Update or remove this altogether. If to update, take NA-1 or something more akin
    !to an outlet, than the average middle-elevation grid (as it's coded now).
    !Should there be a choice to print point-process (pre, evap, rof) vs flow-process (wf_qo2)?
    j = ceiling(real(NA)/2); if (WF_NUM_POINTS > 0) j = op%N_OUT(1)
    print 5176, YEAR_NOW, JDAY_NOW, (WF_QHYD_AVG(I), WF_QSYN_AVG(I)/NCOUNT, I = 1, WF_NO), wb%pre(j), wb%evap(j), wb%rof(j)

  END IF

end if !(ro%VERBOSEMODE > 0) then

    if (mtsflg%AUTOCALIBRATIONFLAG > 0) then
        call stats_update_daily(WF_QHYD_AVG, WF_QSYN_AVG, NCOUNT)
        if (mtsflg%PREEMPTIONFLAG > 1) then
            if (FTEST > FBEST) goto 199
        end if
    end if

  WF_QSYN_AVG = 0.0

wb%pre = 0.0
wb%evap = 0.0
wb%rof = 0.0
wb%rofo = 0.0
wb%rofs =  0.0
wb%rofb = 0.0

ENDIF !(NCOUNT==48) THEN

end if !(ipid == 0) then

5176 format(2i5, 999(f10.3))

! *********************************************************************
! Update time counters and return to beginning of main loop
! *********************************************************************
MINS_NOW = MINS_NOW + TIME_STEP_MINS ! increment the current time by 30 minutes
IF (MINS_NOW == 60) THEN
  MINS_NOW = 0
  HOUR_NOW = HOUR_NOW + 1
  IF (HOUR_NOW==24) THEN
    HOUR_NOW = 0
!    IF(mtsflg%AUTOCALIBRATIONFLAG .GE. 1 .AND. mtsflg%PREEMPTIONFLAG == 1)THEN
!      IF(FTEST > FBEST) GOTO 199
!    ENDIF
    JDAY_NOW = JDAY_NOW + 1
    IF (JDAY_NOW >= 366) THEN
      IF (MOD(YEAR_NOW,400) == 0) THEN !LEAP YEAR
        IF (JDAY_NOW == 367) THEN
          JDAY_NOW = 1
          YEAR_NOW = YEAR_NOW + 1
        ENDIF
      ELSE IF (MOD(YEAR_NOW,100) == 0) THEN !NOT A LEAP YEAR
        JDAY_NOW = 1
        YEAR_NOW = YEAR_NOW + 1
      ELSE IF (MOD(YEAR_NOW,4) == 0) THEN !LEAP YEAR
        IF (JDAY_NOW == 367) THEN
          JDAY_NOW = 1
          YEAR_NOW = YEAR_NOW + 1
        ENDIF
      ELSE !NOT A LEAP YEAR
        JDAY_NOW = 1
        YEAR_NOW = YEAR_NOW + 1
      ENDIF
    ENDIF
  ENDIF
ENDIF

!> check if we should terminate the run yet
IF (YEAR_NOW >= YEAR_STOP .AND. YEAR_STOP > 0) THEN
  IF(YEAR_NOW > YEAR_STOP) THEN
    ENDDATE = .TRUE.
  ELSEIF (YEAR_NOW == YEAR_STOP .AND. JDAY_NOW >= JDAY_STOP) THEN
    IF (JDAY_NOW > JDAY_STOP) THEN
      ENDDATE = .TRUE.
    ELSEIF (JDAY_NOW == JDAY_STOP .AND. HOUR_NOW >= HOUR_STOP) THEN
      IF (HOUR_NOW > HOUR_STOP) THEN
        ENDDATE = .TRUE.
      ELSEIF (HOUR_NOW == HOUR_STOP .AND. MINS_NOW >= MINS_STOP) THEN
        ENDDATE = .TRUE.
      ENDIF
    ENDIF
  ENDIF
ENDIF

    TIME_STEP_NOW = TIME_STEP_NOW + TIME_STEP_MINS
    if (TIME_STEP_NOW == HOURLYFLAG) TIME_STEP_NOW = 0

    !> *********************************************************************
    !> Read in meteorological forcing data
    !> *********************************************************************
    call climate_module_loaddata(bi, .false., cm, ENDDATA)

END DO !WHILE(.NOT.ENDDATE .AND. .NOT.ENDDATA)

    !> End program if not the head node.
    if (ipid /= 0) then
!        print 4696, ipid
        goto 999

!4696 format (1x, 'Node ', i4, ' is exiting...')

    end if !(ipid /= 0) then

CALL CLASSS (cp%TBARROW,cp%THLQROW,cp%THICROW,GFLXROW,TSFSROW, &
             cp%TPNDROW,cp%ZPNDROW,TBASROW,cp%ALBSROW,cp%TSNOROW, &
             cp%RHOSROW,cp%SNOROW,cp%TCANROW,cp%RCANROW,cp%SCANROW, &
             cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
             ILMOS,JLMOS,IWMOS,JWMOS, &
             NML,NA,NTYPE,ILG,IGND,ICAN,ICAN+1, &
             TBARGAT,THLQGAT,THICGAT,GFLXGAT,TSFSGAT, &
             TPNDGAT,ZPNDGAT,TBASGAT,ALBSGAT,TSNOGAT, &
             RHOSGAT,SNOGAT,TCANGAT,RCANGAT,SCANGAT, &
             GROGAT,CMAIGAT,TACGAT,QACGAT,WSNOGAT, &
             cp%MANNROW,MANNGAT,cp%DDROW,DDGAT, &
             cp%SANDROW,SANDGAT,cp%CLAYROW,CLAYGAT,cp%XSLPROW,XSLPGAT, &
             DrySnowRow, SnowAgeROW,DrySnowGAT, SnowAgeGAT, &
             TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
             DriftROW, SublROW, DepositionROW, &
             DriftGAT, SublGAT, DepositionGAT)
!>
!>   * SCATTER OPERATION ON DIAGNOSTIC VARIABLES SPLIT OUT OF
!>   * CLASSS FOR CONSISTENCY WITH GCM APPLICATIONS.
!>
      DO 380 K=1,NML
          CDHROW (ILMOS(K),JLMOS(K))=CDHGAT (K)
          CDMROW (ILMOS(K),JLMOS(K))=CDMGAT (K)
          HFSROW (ILMOS(K),JLMOS(K))=HFSGAT (K)
          TFXROW (ILMOS(K),JLMOS(K))=TFXGAT (K)
          QEVPROW(ILMOS(K),JLMOS(K))=QEVPGAT(K)
          QFSROW (ILMOS(K),JLMOS(K))=QFSGAT (K)
          QFXROW (ILMOS(K),JLMOS(K))=QFXGAT (K)
          PETROW (ILMOS(K),JLMOS(K))=PETGAT (K)
          GAROW  (ILMOS(K),JLMOS(K))=GAGAT  (K)
          EFROW  (ILMOS(K),JLMOS(K))=EFGAT  (K)
          GTROW  (ILMOS(K),JLMOS(K))=GTGAT  (K)
          QGROW  (ILMOS(K),JLMOS(K))=QGGAT  (K)
          ALVSROW(ILMOS(K),JLMOS(K))=ALVSGAT(K)
          ALIRROW(ILMOS(K),JLMOS(K))=ALIRGAT(K)
          SFCTROW(ILMOS(K),JLMOS(K))=SFCTGAT(K)
          SFCUROW(ILMOS(K),JLMOS(K))=SFCUGAT(K)
          SFCVROW(ILMOS(K),JLMOS(K))=SFCVGAT(K)
          SFCQROW(ILMOS(K),JLMOS(K))=SFCQGAT(K)
          FSNOROW(ILMOS(K),JLMOS(K))=FSNOGAT(K)
          FSGVROW(ILMOS(K),JLMOS(K))=FSGVGAT(K)
          FSGSROW(ILMOS(K),JLMOS(K))=FSGSGAT(K)
          FSGGROW(ILMOS(K),JLMOS(K))=FSGGGAT(K)
          FLGVROW(ILMOS(K),JLMOS(K))=FLGVGAT(K)
          FLGSROW(ILMOS(K),JLMOS(K))=FLGSGAT(K)
          FLGGROW(ILMOS(K),JLMOS(K))=FLGGGAT(K)
          HFSCROW(ILMOS(K),JLMOS(K))=HFSCGAT(K)
          HFSSROW(ILMOS(K),JLMOS(K))=HFSSGAT(K)
          HFSGROW(ILMOS(K),JLMOS(K))=HFSGGAT(K)
          HEVCROW(ILMOS(K),JLMOS(K))=HEVCGAT(K)
          HEVSROW(ILMOS(K),JLMOS(K))=HEVSGAT(K)
          HEVGROW(ILMOS(K),JLMOS(K))=HEVGGAT(K)
          HMFCROW(ILMOS(K),JLMOS(K))=HMFCGAT(K)
          HMFNROW(ILMOS(K),JLMOS(K))=HMFNGAT(K)
          HTCCROW(ILMOS(K),JLMOS(K))=HTCCGAT(K)
          HTCSROW(ILMOS(K),JLMOS(K))=HTCSGAT(K)
          PCFCROW(ILMOS(K),JLMOS(K))=PCFCGAT(K)
          PCLCROW(ILMOS(K),JLMOS(K))=PCLCGAT(K)
          PCPNROW(ILMOS(K),JLMOS(K))=PCPNGAT(K)
          PCPGROW(ILMOS(K),JLMOS(K))=PCPGGAT(K)
          QFGROW (ILMOS(K),JLMOS(K))=QFGGAT (K)
          QFNROW (ILMOS(K),JLMOS(K))=QFNGAT (K)
          QFCLROW(ILMOS(K),JLMOS(K))=QFCLGAT(K)
          QFCFROW(ILMOS(K),JLMOS(K))=QFCFGAT(K)
          ROFROW (ILMOS(K),JLMOS(K))=ROFGAT (K)
          ROFOROW(ILMOS(K),JLMOS(K))=ROFOGAT(K)
          ROFSROW(ILMOS(K),JLMOS(K))=ROFSGAT(K)
          ROFBROW(ILMOS(K),JLMOS(K))=ROFBGAT(K)
          TROFROW(ILMOS(K),JLMOS(K))=TROFGAT(K)
          TROOROW(ILMOS(K),JLMOS(K))=TROOGAT(K)
          TROSROW(ILMOS(K),JLMOS(K))=TROSGAT(K)
          TROBROW(ILMOS(K),JLMOS(K))=TROBGAT(K)
          ROFCROW(ILMOS(K),JLMOS(K))=ROFCGAT(K)
          ROFNROW(ILMOS(K),JLMOS(K))=ROFNGAT(K)
          ROVGROW(ILMOS(K),JLMOS(K))=ROVGGAT(K)
          WTRCROW(ILMOS(K),JLMOS(K))=WTRCGAT(K)
          WTRSROW(ILMOS(K),JLMOS(K))=WTRSGAT(K)
          WTRGROW(ILMOS(K),JLMOS(K))=WTRGGAT(K)
          DRROW  (ILMOS(K),JLMOS(K))=DRGAT  (K)
          WTABROW(ILMOS(K),JLMOS(K))=WTABGAT(K)
          ILMOROW(ILMOS(K),JLMOS(K))=ILMOGAT(K)
          UEROW  (ILMOS(K),JLMOS(K))=UEGAT(K)
          HBLROW (ILMOS(K),JLMOS(K))=HBLGAT(K)
380   CONTINUE
!>
      DO 390 L=1,IGND
      DO 390 K=1,NML
          HMFGROW(ILMOS(K),JLMOS(K),L)=HMFGGAT(K,L)
          HTCROW (ILMOS(K),JLMOS(K),L)=HTCGAT (K,L)
          QFCROW (ILMOS(K),JLMOS(K),L)=QFCGAT (K,L)
390   CONTINUE
!>
      DO 430 M=1,50
          DO 420 L=1,6
              DO 410 K=1,NML
                  ITCTROW(ILMOS(K),JLMOS(K),L,M)=ITCTGAT(K,L,M)
410           CONTINUE
420       CONTINUE
430   CONTINUE

!> *********************************************************************
!> Run is now over, print final results to the screen and close files
!> *********************************************************************

!> *********************************************************************
!> Save the state of the basin in r2c file format
!> *********************************************************************

!> Write the resume file
IF (SAVERESUMEFLAG == 2) THEN !todo: done: use a flag
  PRINT *, 'Saving state variables in r2c file format'

! Allocate arrays for save_state_r2c
      OPEN(55, FILE = 'save_state_r2c.txt', action = 'read')
      READ(55,*,IOSTAT=IOS)NR2C_S,DELTR2C_S
      IF(IOS == 0)THEN
         ALLOCATE(GRD_S(NR2C_S),GAT_S(NR2C_S),GRDGAT_S(NR2C_S),R2C_ATTRIBUTES_S(NR2C_S,3),STAT=PAS)
         IF(PAS /= 0)THEN
           PRINT*,'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                  'RECORD AT THE FIRST LINE IN THE save_state_r2c.txt FILE. ', &
                  'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
           STOP
         ENDIF 
      ENDIF
      CLOSE(55)

  call SAVE_STATE_R2C(NML,NLTEST,NMTEST,NCOUNT, &
                      MINS_NOW,ACLASS,NR2C_S,GRD_S,GAT_S,GRDGAT_S,R2C_ATTRIBUTES_S,&
                      NA,XXX,YYY,XCOUNT,YCOUNT,ILMOS,JLMOS,ILG,ICAN,ICP1,IGND, &
                      TBARGAT,THLQGAT,THICGAT,TPNDGAT,ZPNDGAT, &
                      TBASGAT,ALBSGAT,TSNOGAT,RHOSGAT,SNOGAT,  &
                      TCANGAT,RCANGAT,SCANGAT,GROGAT, CMAIGAT, &
                      FCANGAT,LNZ0GAT,ALVCGAT,ALICGAT,PAMXGAT, &
                       PAMNGAT,CMASGAT,ROOTGAT,RSMNGAT,QA50GAT, &
                       VPDAGAT,VPDBGAT,PSGAGAT,PSGBGAT,PAIDGAT, &
                       HGTDGAT,ACVDGAT,ACIDGAT,TSFSGAT,WSNOGAT, &
                       THPGAT, THRGAT, THMGAT, BIGAT,  PSISGAT, &
                       GRKSGAT,THRAGAT,HCPSGAT,TCSGAT,          &
                       THFCGAT,PSIWGAT,DLZWGAT,ZBTWGAT,         &
                       ZSNLGAT,ZPLGGAT,ZPLSGAT,TACGAT, QACGAT,  &
                       DRNGAT, XSLPGAT,XDGAT,WFSFGAT,KSGAT,     &
                       ALGWGAT,ALGDGAT,ASVDGAT,ASIDGAT,AGVDGAT, &
                       AGIDGAT,ISNDGAT,RADJGAT,ZBLDGAT,Z0ORGAT, &
                       ZRFMGAT,ZRFHGAT,ZDMGAT, ZDHGAT, FSVHGAT, &
                       FSIHGAT,CSZGAT, FDLGAT, ULGAT,  VLGAT,   &
                       TAGAT,  QAGAT,  PRESGAT,PREGAT, PADRGAT, &
                       VPDGAT, TADPGAT,RHOAGAT,RPCPGAT,TRPCGAT, &
                       SPCPGAT,TSPCGAT,RHSIGAT,FCLOGAT,DLONGAT, &
                       GGEOGAT,                                 &
                       CDHGAT, CDMGAT, HFSGAT, TFXGAT, QEVPGAT, &
                       QFSGAT, QFXGAT, PETGAT, GAGAT,  EFGAT,   &
                       GTGAT,  QGGAT,  ALVSGAT,ALIRGAT, &
                       SFCTGAT,SFCUGAT,SFCVGAT,SFCQGAT,FSNOGAT, &
                       FSGVGAT,FSGSGAT,FSGGGAT,FLGVGAT,FLGSGAT, &
                       FLGGGAT,HFSCGAT,HFSSGAT,HFSGGAT,HEVCGAT, &
                       HEVSGAT,HEVGGAT,HMFCGAT,HMFNGAT,HTCCGAT, &
                       HTCSGAT,PCFCGAT,PCLCGAT,PCPNGAT,PCPGGAT, &
                       QFGGAT, QFNGAT, QFCLGAT,QFCFGAT,ROFGAT,  &
                       ROFOGAT,ROFSGAT,ROFBGAT,TROFGAT,TROOGAT, &
                       TROSGAT,TROBGAT,ROFCGAT,ROFNGAT,ROVGGAT, &
                       WTRCGAT,WTRSGAT,WTRGGAT,DRGAT,  GFLXGAT, &
                       HMFGGAT,HTCGAT, QFCGAT,MANNGAT, DDGAT,   &
                       SANDGAT,CLAYGAT,IGDRGAT,VMODGAT,QLWOGAT, &
                       coordsys1,datum1, zone1,  XORIGIN,YORIGIN,XDELTA,YDELTA)
ENDIF !IF (SAVERESUMEFLAG == 2) THEN

!> Write the resume file
IF (SAVERESUMEFLAG == 1) THEN !todo: done: use a flag
  PRINT *, 'Saving state variables'
  call SAVE_STATE( &
   HOURLYFLAG, MINS_NOW, TIME_STEP_NOW, &
   cm%clin(cfk%FB)%filefmt, cm%clin(cfk%FI)%filefmt, &
   cm%clin(cfk%PR)%filefmt, cm%clin(cfk%TT)%filefmt, &
   cm%clin(cfk%UV)%filefmt, cm%clin(cfk%P0)%filefmt, cm%clin(cfk%HU)%filefmt, &
   cm%clin(cfk%FB)%climvGrd, FSVHGRD, FSIHGRD, cm%clin(cfk%FI)%climvGrd, &
   I, J, XCOUNT, YCOUNT, jan, &
   VPDGRD, TADPGRD, PADRGRD, RHOAGRD, RHSIGRD, &
   RPCPGRD, TRPCGRD, SPCPGRD, TSPCGRD, cm%clin(cfk%TT)%climvGrd, &
   cm%clin(cfk%HU)%climvGrd, cm%clin(cfk%PR)%climvGrd, RPREGRD, SPREGRD, cm%clin(cfk%P0)%climvGrd, &

!MAM - FOR FORCING DATA INTERPOLATION
   FSVHGATPRE, FSIHGATPRE, FDLGATPRE, PREGATPRE, &
   TAGATPRE, ULGATPRE, PRESGATPRE, QAGATPRE, &
   
   IPCP, NA, NA, ILMOS, JLMOS, IWMOS, JWMOS, &
   NML, NMW, &
   cp%GCGRD, cp%FAREROW, cp%MIDROW, NTYPE, ILG, NMTEST, &
   TBARGAT, THLQGAT, THICGAT, TPNDGAT, ZPNDGAT, &
   TBASGAT, ALBSGAT, TSNOGAT, RHOSGAT, SNOGAT, &
   TCANGAT, RCANGAT, SCANGAT, GROGAT, FRZCGAT, CMAIGAT, &
   FCANGAT, LNZ0GAT, ALVCGAT, ALICGAT, PAMXGAT, &
   PAMNGAT, CMASGAT, ROOTGAT, RSMNGAT, QA50GAT, &
   VPDAGAT, VPDBGAT, PSGAGAT, PSGBGAT, PAIDGAT, &
   HGTDGAT, ACVDGAT, ACIDGAT, TSFSGAT, WSNOGAT, &
   THPGAT, THRGAT, THMGAT, BIGAT, PSISGAT, &
   GRKSGAT, THRAGAT, HCPSGAT, TCSGAT, THFCGAT, &
   PSIWGAT, DLZWGAT, ZBTWGAT, ZSNLGAT, ZPLGGAT, &
   ZPLSGAT, TACGAT, QACGAT, DRNGAT, XSLPGAT, &
   XDGAT, WFSFGAT, KSGAT, ALGWGAT, ALGDGAT, &
   ASVDGAT, ASIDGAT, AGVDGAT, AGIDGAT, ISNDGAT, &
   RADJGAT, ZBLDGAT, Z0ORGAT, ZRFMGAT, ZRFHGAT, &
   ZDMGAT, ZDHGAT, FSVHGAT, FSIHGAT, CSZGAT, &
   FDLGAT, ULGAT, VLGAT, TAGAT, QAGAT, PRESGAT, &
   PREGAT, PADRGAT, VPDGAT, TADPGAT, RHOAGAT, &
   RPCPGAT, TRPCGAT, SPCPGAT, TSPCGAT, RHSIGAT, &
   FCLOGAT, DLONGAT, GGEOGAT, CDHGAT, CDMGAT, &
   HFSGAT, TFXGAT, QEVPGAT, QFSGAT, QFXGAT, &
   PETGAT, GAGAT, EFGAT, GTGAT, QGGAT, &
   ALVSGAT, ALIRGAT, SFCTGAT, SFCUGAT, SFCVGAT, &
   SFCQGAT, FSNOGAT, FSGVGAT, FSGSGAT, FSGGGAT, &
   FLGVGAT, FLGSGAT, FLGGGAT, HFSCGAT, HFSSGAT, &
   HFSGGAT, HEVCGAT, HEVSGAT, HEVGGAT, HMFCGAT, &
   HMFNGAT, HTCCGAT, HTCSGAT, PCFCGAT, PCLCGAT, &
   PCPNGAT, PCPGGAT, QFGGAT, QFNGAT, QFCLGAT, &
   QFCFGAT, ROFGAT, ROFOGAT, ROFSGAT, ROFBGAT, &
   TROFGAT, TROOGAT, TROSGAT, TROBGAT, ROFCGAT, &
   ROFNGAT, ROVGGAT, WTRCGAT, WTRSGAT, WTRGGAT, &
   DRGAT, HMFGGAT, HTCGAT, QFCGAT, ITCTGAT, &
   IGND, ICAN, ICP1, &
   cp%TBARROW, cp%THLQROW, cp%THICROW, cp%TPNDROW, cp%ZPNDROW, &
   TBASROW, cp%ALBSROW, cp%TSNOROW, cp%RHOSROW, cp%SNOROW, &
   cp%TCANROW, cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, &
   cp%FCANROW, cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
   cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, cp%QA50ROW, &
   cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, cp%PSGBROW, PAIDROW, &
   HGTDROW, ACVDROW, ACIDROW, TSFSROW, WSNOROW, &
   THPROW, THRROW, THMROW, BIROW, PSISROW, &
   GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
   PSIWROW, DLZWROW, ZBTWROW, hp%ZSNLROW, hp%ZPLGROW, &
   hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, cp%DRNROW, cp%XSLPROW, &
   cp%XDROW, WFSFROW, cp%KSROW, ALGWROW, ALGDROW, &
   ASVDROW, ASIDROW, AGVDROW, AGIDROW, &
   ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
   cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, CSZGRD, &
   cm%clin(cfk%UV)%climvGrd, VLGRD, FCLOGRD, DLONGRD, GGEOGRD, &
   cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
   IGDRROW, IGDRGAT, VMODGRD, VMODGAT, QLWOGAT, &
   CTVSTP, CTSSTP, CT1STP, CT2STP, CT3STP, &
   WTVSTP, WTSSTP, WTGSTP, &
   sl%DELZ, FCS, FGS, FC, FG, N, &
   ALVSCN, ALIRCN, ALVSG, ALIRG, ALVSCS, &
   ALIRCS, ALVSSN, ALIRSN, ALVSGC, ALIRGC, &
   ALVSSC, ALIRSC, TRVSCN, TRIRCN, TRVSCS, &
   TRIRCS, FSVF, FSVFS, &
   RAICAN, RAICNS, SNOCAN, SNOCNS, &
   FRAINC, FSNOWC, FRAICS, FSNOCS, &
   DISP, DISPS, ZOMLNC, ZOMLCS, ZOELNC, ZOELCS, &
   ZOMLNG, ZOMLNS, ZOELNG, ZOELNS, &
   CHCAP, CHCAPS, CMASSC, CMASCS, CWLCAP, &
   CWFCAP, CWLCPS, CWFCPS, RC, RCS, RBCOEF, &
   FROOT, ZPLIMC, ZPLIMG, ZPLMCS, ZPLMGS, &
   TRSNOW, ZSNOW, JDAY_NOW, JLAT, IDISP, &
   IZREF, IWF, IPAI, IHGT, IALC, IALS, IALG, &
   TBARC, TBARG, TBARCS, TBARGS, THLIQC, THLIQG, &
   THICEC, THICEG, HCPC, HCPG, TCTOPC, TCBOTC, &
   TCTOPG, TCBOTG, &
   GZEROC, GZEROG, GZROCS, GZROGS, G12C, G12G, &
   G12CS, G12GS, G23C, G23G, G23CS, G23GS, &
   QFREZC, QFREZG, QMELTC, QMELTG, &
   EVAPC, EVAPCG,EVAPG, EVAPCS, EVPCSG, EVAPGS, &
   TCANO, TCANS, TPONDC, TPONDG, TPNDCS, TPNDGS, &
   TSNOCS, TSNOGS, WSNOCS, WSNOGS, RHOSCS, RHOSGS, &
   WTABGAT, &
   ILMOGAT, UEGAT, HBLGAT, &
   ILW, ITC, ITCG, ITG, ISLFD, &
   NLANDCS, NLANDGS, NLANDC, NLANDG, NLANDI, &
   GFLXGAT, CDHROW, CDMROW, HFSROW, TFXROW, &
   QEVPROW, QFSROW, QFXROW, PETROW, GAROW, &
   EFROW, GTROW, QGROW, TSFROW, ALVSROW, &
   ALIRROW, SFCTROW, SFCUROW, SFCVROW, SFCQROW, &
   FSGVROW, FSGSROW, FSGGROW, FLGVROW, FLGSROW, &
   FLGGROW, HFSCROW, HFSSROW, HFSGROW, HEVCROW, &
   HEVSROW, HEVGROW, HMFCROW, HMFNROW, HTCCROW, &
   HTCSROW, PCFCROW, PCLCROW, PCPNROW, PCPGROW, &
   QFGROW, QFNROW, QFCLROW, QFCFROW, ROFROW, &
   ROFOROW, ROFSROW, ROFBROW, TROFROW, TROOROW, &
   TROSROW, TROBROW, ROFCROW, ROFNROW, ROVGROW, &
   WTRCROW, WTRSROW, WTRGROW, DRROW, WTABROW, &
   ILMOROW, UEROW, HBLROW, HMFGROW, HTCROW, &
   QFCROW, FSNOROW, ITCTROW, NCOUNT, ireport, &
   wfo_seq, YEAR_NOW, ensim_MONTH, ensim_DAY, &
   HOUR_NOW, XXX, YYY, NA, &
   NTYPE, DELT, TFREZ, UVGRD, SBC, RHOW, CURREC, &
   M_C, M_S, M_R, &
     WF_ROUTETIMESTEP,WF_R1,WF_R2,NAA,IYMIN, &
     WF_IYMAX,JXMIN,WF_JXMAX,WF_IBN,WF_IROUGH, &
     WF_ICHNL,WF_NEXT,WF_IREACH,AL,GRDN,GRDE, &
     WF_DA,WF_BNKFLL,WF_CHANNELSLOPE ,WF_ELEV,FRAC, &
     WF_NO,WF_NL,WF_MHRD,WF_KT,WF_IY,WF_JX, &
     WF_QHYD,WF_RES,WF_RESSTORE,WF_NORESV_CTRL,WF_R, &
     WF_NORESV,WF_NREL,WF_KTR,WF_IRES,WF_JRES,WF_RESNAME, &
     WF_B1,WF_B2,WF_QREL, WF_QR, &
     WF_TIMECOUNT,WF_NHYD,WF_QBASE,WF_QI1,WF_QI2,WF_QO1,WF_QO2, &
     WF_STORE1,WF_STORE2, &
     DRIVERTIMESTEP,ROFGRD, &
     WF_S, &
  TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
  TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
  FINAL_STORE, TOTAL_AREA, TOTAL_HFSACC, TOTAL_QEVPACC, &
  SOIL_POR_MAX, SOIL_DEPTH, S0, T_ICE_LENS,NMELT,t0_ACC, &
  CO2CONC, COSZS, XDIFFUSC, CFLUXCG, CFLUXCS, &
  AILCG, AILCGS, FCANC, FCANCS, CO2I1CG, CO2I1CS, CO2I2CG, CO2I2CS, &
  SLAI, FCANCMX, ANCSVEG, ANCGVEG, RMLCSVEG, RMLCGVEG, &
  AILC, PAIC, FIELDSM,  WILTSM, &
  RMATCTEM, RMATC, NOL2PFTS, ICTEMMOD, L2MAX, ICTEM, &
  hp%fetchROW,hp%HtROW,hp%N_SROW,hp%A_SROW,hp%DistribROW, &
  fetchGAT,HtGAT,N_SGAT,A_SGAT,DistribGAT)
ENDIF !IF (SAVERESUMEFLAG == 1) THEN

!> *********************************************************************
!> Call save_init_prog_variables_class.f90 to save initi prognostic variables by
!> by fields needd by classas as initial conditions
!> *********************************************************************
!> bjd - July 14, 2014: Gonzalo Sapriza
IF (SAVERESUMEFLAG == 3) THEN

!> Save the last time step
    CALL save_init_prog_variables_class( CMAIROW     , QACROW     , TACROW      , &
                                         TBASROW     , TSFSROW    , WSNOROW     , &
                                         cp%ALBSROW  , cp%GROROW  , cp%RCANROW  , &
                                         cp%RHOSROW  , cp%SCANROW , cp%SNOROW   , &
                                         cp%TBARROW  , cp%TCANROW , cp%THICROW  , &
                                         cp%THLQROW  , cp%TPNDROW , cp%TSNOROW  , &
                                         cp%ZPNDROW                             , &
                                         NA          , NTYPE      , IGND        , &
                                         fls )

ENDIF !IF (SAVERESUMEFLAG == 3) THEN

if (OUTFIELDSFLAG == 1) call write_outputs(vr, ts, iof, bi, fls)

IF(ENDDATA)PRINT *, 'Reached end of forcing data'
IF(ENDDATE)PRINT *, 'Reached end of simulation date'

!> Calculate final storage
FINAL_STORE = 0.0
DO I = 1, nml
    IF (FRAC(ilmos(I)) >= 0.0) THEN
!        DO M = 1, NMTEST
            FINAL_STORE = FINAL_STORE + FAREGAT(i)* &
                (RCANgat(I) + SCANgat(I) + SNOgat(I) + WSNOgat(I) + ZPNDgat(I)*RHOW)
            DO J = 1, IGND
                FINAL_STORE = FINAL_STORE + FAREGAT(i)* &
                    (THLQgat(I, J)*RHOW + THICgat(I, J)*RHOICE)*DLZWgat(I, J)
            END DO
!        END DO
   END IF
END DO

!> write out final totals to screen

if (ro%VERBOSEMODE > 0) then

    print *
    print 5641, 'Total Precipitation         (mm) =', TOTAL_PREACC/TOTAL_AREA
    print 5641, 'Total Evaporation           (mm) =', TOTAL_EVAPACC/TOTAL_AREA
    print 5641, 'Total Runoff                (mm) =', TOTAL_ROFACC/TOTAL_AREA
    print 5641, 'Storage (Change/Init/Final) (mm) =', (FINAL_STORE - INIT_STORE)/TOTAL_AREA, INIT_STORE/TOTAL_AREA, &
        FINAL_STORE/TOTAL_AREA
    print *
    print 5641, 'Total Overland flow         (mm) =', TOTAL_ROFOACC/TOTAL_AREA
    print 5641, 'Total Interflow             (mm) =', TOTAL_ROFSACC/TOTAL_AREA
    print 5641, 'Total Baseflow              (mm) =', TOTAL_ROFBACC/TOTAL_AREA
    print *

5641 format(3x, a34, 999(f11.3))
5635 format(1x'Program has terminated normally.'/)

end if !(ro%VERBOSEMODE > 0) then

    print 5635

    !> Write final totals to output file.
    if (MODELINFOOUTFLAG > 0) then

        write(58, *)
        write(58, "(a, f11.3)") "  Total Precipitation         (mm) = ", TOTAL_PREACC/TOTAL_AREA
        write(58, "(a, f11.3)") "  Total Evaporation           (mm) = ", TOTAL_EVAPACC/TOTAL_AREA
        write(58, "(a, f11.3)") "  Total Runoff                (mm) = ", TOTAL_ROFACC/TOTAL_AREA
        write(58, "(a, 3f11.3)") "  Storage(Change/Init/Final)  (mm) = ", &
            (FINAL_STORE - INIT_STORE)/TOTAL_AREA, &
            INIT_STORE/TOTAL_AREA, &
            FINAL_STORE/TOTAL_AREA
        write(58, "(a, f11.3)") "  Total Overland flow         (mm) = ", TOTAL_ROFOACC/TOTAL_AREA
        write(58, "(a, f11.3)") "  Total Interflow             (mm) = ", TOTAL_ROFSACC/TOTAL_AREA
        write(58, "(a, f11.3)") "  Total Baseflow              (mm) = ", TOTAL_ROFBACC/TOTAL_AREA
        write(58, *)
        write(58, *)
        write(58, "(a)") "Program has terminated normally."
        write(58, *)

        call cpu_time(endprog)
        write(58, "('Time = ', e14.6, ' seconds.')") (endprog - startprog)

    end if !(MODELINFOOUTFLAG > 0) then

199 CONTINUE

    if (mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_write()

999 CONTINUE
!> Diane      CLOSE(UNIT=21)
!>      CLOSE(UNIT=22)
CLOSE(UNIT=51)

    !todo++:
    !todo++: CUT OUT CLASS ACCUMULATION AND OUTPUT FILES TO APPROPRIATE NODE
    !todo++:
    !> Close the CLASS output files if the GAT-index of the output point resides on this node.
    do i = 1, WF_NUM_POINTS
        if (op%K_OUT(i) >= il1 .and. op%K_OUT(i) <= il2) then
            close(150 + i*10 + 1)
            close(150 + i*10 + 2)
            close(150 + i*10 + 3)
            close(150 + i*10 + 4)
            close(150 + i*10 + 5)
            close(150 + i*10 + 6)
            close(150 + i*10 + 7)
            close(150 + i*10 + 8)
            close(150 + i*10 + 9)
            close(150 + i*10 + 10)
        end if
    end do

    !> Close model output file.
    close(58)

    !> Close CSV streamflow files.
    close(fls%fl(mfk%f70)%iun)
    close(71)
    close(72)

    !> Close the SWE CSV files.
    close(85)
    close(86)

    !> Close the legacy binary format forcing files.
    close(90)
    close(91)
    close(92)
    close(93)
    close(94)
    close(95)
    close(96)

    !> Close the CSV energy and water balance output files.
    close(fls%fl(mfk%f900)%iun)
    close(901)
    close(902)

9000 format( &
    /1x'INTERPOLATIONFLAG IS NOT SPECIFIED CORRECTLY AND IS SET TO 0 BY THE MODEL.', &
    /1x'0: NO INTERPOLATION OF FORCING DATA.', &
    /1x'1: LINEARLY INTERPOLATES FORCING DATA FOR INTERMEDIATE TIME STEPS.', &
    /1x'NOTE: INTERPOLATIONFLAG SHOULD BE SET TO 0 FOR 30 MINUTE FORCING DATA.'/)

9002 format( &
    /1x'ERROR IN READING r2c_output.txt FILE.', &
    /1x'THE FIRST RECORD AT THE FIRST LINE IS FOR THE NUMBER OF ALL THE', &
    /1x'VARIABLES LISTED IN THE r2c_output.txt FILE.',&
    /1x'THE SECOND RECORD AT THE FIRST LINE IS TIME STEP FOR R2C OUTPUT.', &
    /1x'IT SHOULD BE AN INTEGER MULTIPLE OF 30.',&
    /1x'THE REMAINING RECORDS SHOULD CONTAIN 3 COLUMNS FOR EACH VARIABLE WITH', &
    /1x'INTEGER VALUES OF EITHER 0 OR 1,', &
    /1x'AND 3 COLUMNS CONTAINING INFORMATION ABOUT THE VARIABLES.'/)

    call mpi_finalize(ierr)

STOP
END


