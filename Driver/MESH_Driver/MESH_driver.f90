program RUNMESH

!>       MESH DRIVER
!>
!>       NOV 2015 - DGP. Moved incrementing the counters to
!>                  after routing has finished. This impacts when daily
!>                  and cumulative daily streamflow are written to file
!>                  and screen. The average daily streamflow was
!>                  calculated between 23:00-23:30 before the fix, tied
!>                  to an if statement about NCOUNT == 48, which
!>                  occurred shortly after NCOUNT = NCOUNT + 1 in the
!>                  same time-step. Average daily streamflow is
!>                  calculated between 23:30-24:00 after the fix. The
!>                  change causes results in MESH_output_streamflow.csv
!>                  and MESH_output_streamflow_cumulative.csv to differ
!>                  by the amount of flow calculated between
!>                  23:30-24:00. Metrics calculated based on streamflow
!>                  also change. The daily runoff generated by CLASS
!>                  remains unchanged.
!>                  Because metrics and streamflow results differ
!>                  between this and prior revisions, r909 might be
!>                  considered the start of MESH 1.4.
!>
!>       JAN 2013 - K.C.KORNELSEN
!>                - INCORPORATED LOCATION FLAG FOR INCREASING PRECISION
!>                - OF STREAMFLOW AND RESERVOIR INPUTS
!>                - INCLUDED NSE AND NEGATIVE NSE AS OBJFN'S
!>       JAN 2014 - M. MACDONALD.  INCORPORATED BLOWING SNOW ALGORITHMS
!>       AUG 2013 - M. MACDONALD
!>                - INCORPORATE OPTIONAL COUPLING OF CLASS WITH CTEM
!>                - MOVE SOME INITIALIZATION AND SCATTER OF CLASS
!>                  DIAGNOSTIC VARIABLES IN TO MESH_DRIVER
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.

    use sa_mesh_shared_variabletypes
    use sa_mesh_shared_variables

    !> For subroutines: FIND_MONTH, FIND_DAY.
    use EF_MODULE

    !> For data types: HydrologyParameters, SoilValues.
    !> For subroutine: GetIndices.
    use MESH_INPUT_MODULE
    use FLAGS

    use module_mpi_flags
    use module_mpi_shared_variables
    use module_mpi

    use sa_mesh_run_within_tile
    use sa_mesh_run_within_grid
    use sa_mesh_run_between_grid

    use MODEL_OUTPUT
    use model_output_variabletypes
    use climate_forcing
    use model_dates
    use SIMSTATS_config
    use SIMSTATS
    use model_files_variabletypes
    use model_files_variables
    use model_files

    use process_CLASS_config

    implicit none

    !> istop: To stop all MPI process
    !* inp: Number of active tasks.
    !* ipid: Current process ID.
    integer ipid_recv, itag, ierrcode, istop, u, invars
    logical lstat

    integer, dimension(:), allocatable :: irqst
    integer, dimension(:, :), allocatable :: imstat

    !* ierr: Diagnostic error/status return from various subroutines.
    integer :: ierr = 0

    !> Local variables.
    !* NA: Temporary store for the number of grid cells.
    !* NTYPE: Temporary store for the number of GRUs.
    !* NML: Temporary store for the number of active land elements (NA, NTYPE).
    !* IGND: Temporary store for the number of soil layers.
    !* iun: Temporary store for the unit number of a file.
    integer NA, NTYPE, NML, IGND, iun, ik, jk

    !+ For split-vector approach
    integer ii1, ii2, iilen

!>  INTEGER CONSTANTS.
!todo: Fix this (e.g., replace M_C with NRVR; move to process_WF_ROUTE).
    integer, parameter :: M_C = 5

!todo clean up commets and arrange variables a bit better

!> FOR INITIALIZATION OF BASIN STORAGE
!-    integer JAN

!>     FOR ROUTING
!todo: Fix this (e.g., replace M_C with NRVR; move to process_WF_ROUTE).
!* WF_R1: MANNING'S N FOR RIVER CHANNEL
!* WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
    real WF_R1(M_C), WF_R2(M_C)

!>==========
!>
!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
    character(10) wf_landclassname(10)
    integer(kind = 4) wfo_yy, wfo_mm, wfo_dd, wfo_hh, wfo_mi, wfo_ss, &
        wfo_ms, nj, ensim_month, ensim_day
    integer(kind = 4) WFO_SEQ, ENSIM_IOS
    integer(kind = 4) CURREC
!> End of ENSIM Changes 
!>== ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

!> *******************************************************************
!> For reading in the last information in mesh_paramters_hydrology.ini
!> *******************************************************************
    character(30) NMTESTFORMAT

!>=======================================================================
!>     * DIMENSION STATEMENTS

!> FIRST SET OF DEFINITIONS:

!> BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!> VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!> THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!> MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!> "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!> A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!> ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!> GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!> DIAGNOSTIC VARIABLES.

!> THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!> REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!> LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!> NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!> SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!> ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!> NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!> VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!> DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!> THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!> "ROW" VARIABLES.

!>     * CONSTANTS (PARAMETER DEFINITIONS):

!* M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
!* M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
!* M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
!* M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
!* M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
!* M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS

!* VERSION: MESH_DRIVER VERSION
!* RELEASE: PROGRAM RELEASE VERSIONS
!> ANDY * VER_OK: IF INPUT FILES ARE CORRECT VERSION FOR PROGRAM
    character(24) :: VERSION = 'TRUNK (918)'
!+CHARACTER :: VERSION*24 = 'TAG'
    character(8) RELEASE
    logical VER_OK
!>
!>*******************************************************************
!>
!> OPERATIONAL VARIABLES:

!* IY: Y-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* JX: X-DIRECTION GRID CO-ORDINATE, USED TO READ FORCING DATA
!* NN: GRID SQUARE, USED TO READ DRAINAGE DATABASE
!* II: GRU, USED TO READ DRAINAGE DATABASE
!* NCOUNT: HALF-HOURLY BASED TIME STEP (200 LOOP)
!* NSUM: NUMBER OF ITERATIONS, TIME STEPS PASSED (200 LOOP)
!* NSUM_TOTAL: total number of iterations
!* i: COUNTER
!* j: COUNTER
!* k: COUNTER
!* l: COUNTER
!* m: COUNTER
!* INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
!* DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
!-    integer NCOUNT, NSUM
    integer i, j, k, l, m, &
        INDEPPAR, DEPPAR

    integer FRAME_NO_NEW

!> MAM - logical variables to control simulation runs:
    logical :: ENDDATE = .false., ENDDATA = .false.

!> OUTPUT VARIABLES:
!> THE SUFFIX "ACC" REFERS TO THE ACCUMULATOR ARRAYS USED IN
!> CALCULATING TIME AVERAGES.
!* ALL: DEFINITIONS IN CLASS DOCUMENTATION
!    real, dimension(:), allocatable :: PREACC, GTACC, QEVPACC, &
!        HFSACC, ROFACC, SNOACC, ALVSACC, ALIRACC, FSINACC, FLINACC, &
!        TAACC, UVACC, PRESACC, QAACC, EVAPACC, FLUTACC, ROFOACC, &
!        ROFSACC, ROFBACC, HMFNACC, WTBLACC, WSNOACC, RHOSACC, TSNOACC, &
!        TCANACC, RCANACC, SCANACC, GROACC, CANARE, SNOARE, ZPNDACC

!> FIELD OF DELTA STORAGE AND INITIAL STORAGE
!-    real, dimension(:), allocatable :: DSTG, STG_I

!    real, dimension(:, :), allocatable :: TBARACC, THLQACC, THICACC, &
!        THALACC, &
!-        THLQ_FLD, THIC_FLD, &
!        GFLXACC

!* TOTAL_ROFACC: TOTAL RUNOFF
!* TOTAL_EVAPACC: TOTAL EVAPORATION
!* TOTAL_PREACC: TOTAL PRECIPITATION
!* INIT_STORE: INITIAL STORAGE
!* FINAL_STORE: FINAL STORAGE
!* TOTAL_AREA: TOTAL FRACTIONED DRAINAGE AREA
!    real TOTAL_ROFACC, TOTAL_ROFOACC, TOTAL_ROFSACC, &
!        TOTAL_ROFBACC, TOTAL_EVAPACC, TOTAL_PREACC, INIT_STORE, &
!        FINAL_STORE, TOTAL_AREA, &
!        TOTAL_PRE_ACC_M, TOTAL_EVAP_ACC_M, TOTAL_ROF_ACC_M, &
!        TOTAL_ROFO_ACC_M, TOTAL_ROFS_ACC_M, TOTAL_ROFB_ACC_M, &
!        TOTAL_PRE_M, TOTAL_EVAP_M, TOTAL_ROF_M, &
!        TOTAL_ROFO_M, TOTAL_ROFS_M, TOTAL_ROFB_M, &
!        TOTAL_SCAN_M, TOTAL_RCAN_M, &
!        TOTAL_SNO_M, TOTAL_WSNO_M, &
!        TOTAL_ZPND_M, &
!        TOTAL_STORE_M, TOTAL_STORE_2_M, &
!        TOTAL_STORE_ACC_M

!* TOTAL_HFS = TOTAL SENSIBLE HEAT FLUX
!* TOTAL_QEVP = TOTAL LATENT HEAT FLUX
!    real TOTAL_HFSACC, TOTAL_QEVPACC

!    real TOTAL_STORE, TOTAL_STORE_2, TOTAL_RCAN, TOTAL_SCAN, TOTAL_SNO, TOTAL_WSNO, TOTAL_ZPND
!    real TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
!    real, dimension(:), allocatable :: TOTAL_THLQ, TOTAL_THIC, &
!        TOTAL_THLQ_M, TOTAL_THIC_M

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

!+    integer SUBBASINCOUNT
!+    integer, dimension(:), allocatable :: SUBBASIN

!> These are the types defined in mesh_input_module.f that contain arrays
!> that need to be allocated in read_initial_inputs.f.
    type(ShedGridParams) :: shd
!    type(SoilLevels) :: sl
!-    type(SoilValues) :: sv
!-    type(HydrologyParameters) :: hp
    type(fl_ids) :: fls

    !* printoutwb: Print components of the water balance to the
    !*             console if enabled.
    logical printoutwb

    !* printoutstfl: Print members of the simulation hydrograph to the
    !*               console if enabled.
    logical printoutstfl, printoutqhyd

!>THESE ARE THTE TYPES DEFINED IN MODEL_OUTPUT.F95 NEED TO WRITE OUTPUT FIELD ACCUMULATED
!> OR AVERAGE FOR THE WATER BALANCE AND SOME OTHER STATES VARIABLES
    type(OUT_FLDS) :: VR
    type(dates_model) :: ts
    type(iter_counter) :: ic
    type(INFO_OUT) :: ifo
    type(CLIM_INFO) :: cm
    type(met_data) :: md_grd
    type(water_balance) :: wb_grd, wb_acc, wb_out
    type(energy_balance) :: eb_grd, eb_acc, eb_out
    type(soil_statevars) :: spv_grd, spv_acc
    type(streamflow_hydrograph) :: stfl
    type(reservoir_release) :: rrls

    logical R2COUTPUT
    integer, parameter :: R2CFILEUNITSTART = 500
    integer NR2C, DELTR2C, NR2CFILES, NR2CSTATES, NR2C_R, DELTR2C_R, NR2C_S, DELTR2C_S
    integer, allocatable, dimension(:) :: GRD, GAT, GRDGAT, GRD_R, GAT_R, GRDGAT_R, GRD_S, GAT_S, GRDGAT_S
    character(50), allocatable, dimension(:, :) :: R2C_ATTRIBUTES, R2C_ATTRIBUTES_R, R2C_ATTRIBUTES_S

! To use with variable format expressions in writing some output files
    character(20) IGND_CHAR
    character(2000) FMT

    character(500) WRT_900_1, WRT_900_2, WRT_900_3, WRT_900_4, WRT_900_f
    character(500) fl_listMesh

    real :: startprog, endprog
    integer :: narg
!real :: alpharain
!character*50 :: alphCh

!> ((((((((((((((((((((((((((((((((((
!> Set the acceptable version numbers
!> ))))))))))))))))))))))))))))))))))
!> todo this should be input file dependant,
!>  because different files will work with different releases
!>  so, make them local variables inside each read subroutine.
    RELEASE = '1.4'

    call cpu_time(startprog)
!>=======================================================================
!>      PROGRAM START

    !> Initialize MPI.
    call mpi_init(ierr)
    if (ierr /= mpi_success) then
        print *, 'Failed to initialize MPI.'
        call mpi_abort(mpi_comm_world, ierrcode, ierr)
        print *, 'ierrcode ', ierrcode, 'ierr ', ierr
    end if

    !> Grab number of total processes and current process ID.
    call mpi_comm_size(mpi_comm_world, inp, ierr)
    call mpi_comm_rank(mpi_comm_world, ipid, ierr)

    !> izero is active if the head node is used for booking and lateral flow
    !> processes.
    if (inp > 1) then
        izero = 1
    else
        izero = 0
    end if

    !> Reset verbose flag for worker nodes.
    if (ipid > 0) ro%VERBOSEMODE = 0

!>!TODO: UPDATE THIS (RELEASE(*)) WITH VERSION CHANGE
    if (ro%VERBOSEMODE > 0) print 951, trim(RELEASE), trim(VERSION)

951 format(1x, 'MESH ', a, ' ---  (', a, ')', /)

!File handled for variable in/out names
!At the moment only class,hydro parameters and some outputs

    !> Check if any command line arguments are found.
    narg = command_argument_count()
    !print *, narg
    if (narg > 0) then
        VARIABLEFILESFLAG = 1
        if (narg >= 1) then
            call get_command_argument(1, fl_listMesh)
!            print *, fl_listMesh
!        else if (narg == 2) then
!            call get_command_argument(1, fl_listMesh)
!            print *, fl_listMesh
!todo: re-instate alpha
!            call get_command_argument(2, alphCh)
!            call value(alphCh, alpharain, ierr)
!            cm%clin(8)%alpharain = alpharain
!            print *, cm%clin(8)%alpharain
        end if
        call Init_fls(fls, trim(adjustl(fl_listMesh)))
    else
!todo: Call this anyway, make loading values from file an alternate subroutine of module_files
        call Init_fls(fls)
    end if !(narg > 0) then

    call READ_INITIAL_INPUTS( &
!>GENERIC VARIABLES
                             RELEASE, &
!>variables for READ_PARAMETERS_HYDROLOGY
!todo: remove these
                             INDEPPAR, DEPPAR, &
                             WF_R2, M_C, &
                             shd, &
!                             sv, &
!                             hp, &
                             ts, cm, &
                             fls)

!>***********************************************************************
!> Forcing data time step should not be less than 30 min - there is no
!> any increase in accuracy as delt (CLASS model time step) is 30 min.
!>=======================================================================

!todo: Move this to climate module.
    if (HOURLYFLAG < 30) then
        print 1028
        stop
    end if

1028 format(/1x, 'FORCING DATA TIME STEP IS LESS THAN 30 MIN', &
            /1x, 'AGGREGATE THE FORCING DATA TO 30 MIN INTERVAL AND TRY AGAIN', /)

    !> Assign shed values to local variables.
    NA = shd%NA
    NTYPE = shd%lc%NTYPE
    IGND = shd%lc%IGND

    !> Initialize output fields.
    call init_water_balance(wb_grd, shd)
    call init_energy_balance(eb_grd, shd)
    call init_soil_statevars(spv_grd, shd)

    !> Calculate the grid and basin fractional areas.
    wb_grd%grid_area = 0.0
    wb_grd%basin_area = 0.0
    do i = 1, NA
        do m = 1, NTYPE
            wb_grd%grid_area(i) = wb_grd%grid_area(i) + shd%lc%ACLASS(i, m)*shd%FRAC(i)
        end do
        wb_grd%basin_area = wb_grd%basin_area + wb_grd%grid_area(i)
    end do

    if (ipid == 0) then

        !> Hourly output.
        call init_met_data(md_grd, shd)

        !> Daily average grid values.
        call init_energy_balance(eb_acc, shd)
        call init_soil_statevars(spv_acc, shd)
        call init_water_balance(wb_acc, shd)

        !> Basin output values.
        !* 1: Accumulated over the run.
        !* 2: Daily average.
        !* 3: Monthly average.
        !* 4: Hourly average.
        allocate(wb_out%PRE(1:4), wb_out%EVAP(1:4), wb_out%ROF(1:4), wb_out%ROFO(1:4), wb_out%ROFS(1:4), wb_out%ROFB(1:4), &
                 wb_out%STG(1:4), wb_out%DSTG(1:4), &
                 wb_out%RCAN(2:4), wb_out%SNCAN(2:4), wb_out%SNO(2:4), wb_out%WSNO(2:4), wb_out%PNDW(2:4), &
                 wb_out%LQWS(2:4, IGND), wb_out%FRWS(2:4, IGND))
        wb_out%basin_area = wb_grd%basin_area
        allocate(eb_out%HFS(2:2), eb_out%QEVP(2:2), eb_out%GFLX(2:2, IGND))

    end if !(ipid == 0) then

    call run_within_tile_ini(shd, fls, ts, ic, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

    NML = shd%lc%NML

!>
!>***********************************************************************
!> MAM - Check for parameter values - all parameters should lie within the
!> specified ranges in the "minmax_parameters.txt" file.
!>=======================================================================
!>
    call check_parameters(WF_R2, M_C, NTYPE)

    call init_iter_counter(ic, YEAR_NOW, JDAY_NOW, HOUR_NOW, MINS_NOW, int(DELT))

!> Set value of FAREROW:
!todo - flag this as an issue to explore later and hide basin average code
!todo - document the problem
    !FUTUREDO: Bruce, FRAC is calculated by EnSim
    ! using Dan Princz's instructions for EnSim
    ! FRAC can be greater than 1.00
    ! So, we cannot use FAREROW in place of BASIN_FRACTION
!-    TOTAL_AREA = sum(cp%FAREROW)

!todo+++: Perhaps land-unit indexing can be done prior in the sequence
!todo+++: of initialization, after reading the drainage database.
!todo+++: Then, variables could be allocated (il1:il2) instead of
!todo+++: (1:ILG) to reduce the memory footprint of the model per node.
!> *********************************************************************
!> Calculate Indices
!> *********************************************************************

!    call GetIndices(inp, izero, ipid, shd%lc%NML, shd%lc%ILMOS, il1, il2, ilen)
!    if (ro%DIAGNOSEMODE > 0) print 1062, ipid, shd%lc%NML, ilen, il1, il2

!1062 format(/1x, 'Configuration and distribution of the domain', &
!            /3x, 'Current process: ', i10, &
!            /3x, 'Tile land elements: ', i10, &
!            /3x, 'Length of single array: ', i10, &
!            /3x, 'Starting index: ', i10, &
!            /3x, 'Stopping index: ', i10, /)

!>=======================================================================
!> ALLOCATE ALL VARIABLES

1114 format(/1x, 'Error allocating ', a, ' variables.', &
            /1x, 'Check that these bounds are within an acceptable range.', /)
1118 format(3x, a, ': ', i6)

!> LAND SURFACE PROGNOSTIC VARIABLES (for Basin_average_water_balance.csv):
!    allocate(TOTAL_THLQ(IGND), TOTAL_THIC(IGND), &
!             TOTAL_THLQ_M(IGND), TOTAL_THIC_M(IGND), stat = ierr)

    if (ierr /= 0) then
        print 1114, 'land surface prognostic'
        print 1118, 'Grid squares', NA
        print 1118, 'GRUs', NTYPE
        print 1118, 'Soil layers', IGND
        stop
    end if

!> **********************************************************************
!>  For cacluating the subbasin grids
!> **********************************************************************

!+    allocate(SUBBASIN(NML), stat = ierr)
!+    if (ierr /= 0) then
!+        print 1114, 'subbasin grid'
!+        print 1118, 'Grid squares', NA
!+        print 1118, 'GRUs', NTYPE
!+        print 1118, 'Total tile elements', NML
!+        stop
!+    end if

!> OUTPUT VARIABLES:
!    allocate(PREACC(NA), GTACC(NA), QEVPACC(NA), &
!             HFSACC(NA), ROFACC(NA), SNOACC(NA), ALVSACC(NA), ALIRACC(NA), &
!             FSINACC(NA), FLINACC(NA), &
!             TAACC(NA), UVACC(NA), PRESACC(NA), QAACC(NA), EVAPACC(NA), &
!             FLUTACC(NA), ROFOACC(NA), &
!             ROFSACC(NA), ROFBACC(NA), HMFNACC(NA), WTBLACC(NA), ZPNDACC(NA), &
!             WSNOACC(NA), RHOSACC(NA), TSNOACC(NA), &
!             TCANACC(NA), RCANACC(NA), SCANACC(NA), GROACC(NA), CANARE(NA), &
!             SNOARE(NA), &
!             TBARACC(NA, IGND), THLQACC(NA, IGND), THICACC(NA, IGND), &
!             THALACC(NA, IGND), GFLXACC(NA, IGND), &
!-             STG_I(NA), DSTG(NA), THLQ_FLD(NA, IGND), THIC_FLD(NA, IGND), &
!             stat = ierr)
!    if (ierr /= 0) then
!        print 1114, 'accumulator'
!        print 1118, 'Grid squares', NA
!        print 1118, 'Soil layers', IGND
!        stop
!    end if

    if (ipid == 0) call run_between_grid_ini(shd, fls, ts, ic, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

!> *********************************************************************
!> Set some more intial values and clear accumulators
!> *********************************************************************

!> adjust NAA to the be number of outlet squares, as currently it is the
!> number of squares with outlets into other squares in the basin, and
!> we want it to be the number of squares with outlets to outside the
!> basin.
!todo - look into the logic of this and suggest how it could be changed
!-    shd%NAA = NA - shd%NAA

!> set initial values of ncount and nsum
! NCOUNT = which half-hour period the current time is:
! The first period (0:00-0:30) is #1, the last period (23:30-0:00) is #48
!-    NCOUNT = HOUR_NOW*2 + MINS_NOW/TIME_STEP_MINS + 1

!> **********************************************************************
!>  Start of section to only run on squares that make up the watersheds
!>  that are listed in the streamflow file (subbasin)
!> **********************************************************************

!+    if (SUBBASINFLAG > 0) then
!+        do i = 1, NA
!+            SUBBASIN(i) = 0
!+        end do

!> Set values at guages to 1
!+        do i = 1, WF_NO
!+            SUBBASIN(WF_S(i)) = 1
!+        end do

!> Set values of subbasin to 1 for all upstream grids
!+        SUBBASINCOUNT = 1
!+        do while (SUBBASINCOUNT > 0)
!+            SUBBASINCOUNT = 0
!+            do i = 1, NA - 1
!+                if (SUBBASIN(shd%NEXT(i)) == 1 .and. SUBBASIN(i) == 0) then
!+                    SUBBASIN(i) = 1
!+                    SUBBASINCOUNT = SUBBASINCOUNT + 1
!+                end if
!+            end do
!+        end do !while (SUBBASINCOUNT > 0)

!> Set values of frac to 0 for all grids non-upstream grids
!+        SUBBASINCOUNT = 0
!+        do i = 1, NA
!+            if (SUBBASIN(i) == 0) then
!+                shd%FRAC(i) = 0.0
!+            else
!+                SUBBASINCOUNT = SUBBASINCOUNT + 1
!+            end if
!+        end do

  !> MAM - Write grid number, grid fractional area and percentage of GRUs in each grid
!+        open(10, file = 'subbasin_info.txt')
!+        write(10, '(a7, 3x, a18, 3x, a58)') &
!+            'GRID NO', 'GRID AREA FRACTION', 'GRU FRACTIONS, GRU 1, GRU 2, GRU 3,... IN INCREASING ORDER'
!+        do i = 1, NA
!+            if (SUBBASIN(i) == 0) then
!+            else
!+                write(10, '(i5, 3x, f10.3, 8x, 50(f10.3, 3x))') i, shd%FRAC(i), (shd%lc%ACLASS(i, m), m = 1, NMTEST)
!+            end if
!+        end do
!+        close(10)

!+    end if !(SUBBASINFLAG > 0) then

!> **********************************************************************
!>  End of subbasin section
!> **********************************************************************

    call climate_module_init(shd, ts, cm, NML, il1, il2, ENDDATA)
    if (ENDDATA) goto 999

!> *********************************************************************
!> Initialize water balance output fields
!> *********************************************************************

    if (ipid == 0) then
        if (OUTFIELDSFLAG == 1) call init_out(shd, ts, ic, ifo, vr)
    end if !(ipid == 0) then

!* JAN: The first time throught he loop, jan = 1. Jan will equal 2 after that.
!-    JAN = 1

    FRAME_NO_NEW = 1

    !> Determine what output will print to the console.
    printoutwb = (allocated(wb_acc%pre) .and. allocated(wb_acc%evap) .and. allocated(wb_acc%rof))
    printoutstfl = allocated(stfl%qsyn)
    printoutqhyd = (allocated(stfl%qhyd) .and. allocated(stfl%qsyn))

    if (ipid == 0) then

!> ******************************************************
!> echo print information to MESH_output_echo_print.txt
!> ******************************************************

        if (MODELINFOOUTFLAG > 0) then
            open(58, file = './' // trim(fls%GENDIR_OUT) // '/MESH_output_echo_print.txt')
            write(58, "('Number of Soil Layers (IGND) = ', i5)") IGND
            write(58, *)
            write(58, "('MESH_input_run_options.ini')")
            write(58, *)
            write(58, "('Configuration flags - specified by user or default values')")

!todo: this list should be updated (dgp: 2015-01-09)
            write(58, *) 'BASINSHORTWAVEFLAG   = ', cm%clin(cfk%FB)%filefmt
            write(58, *) 'BASINLONGWAVEFLAG    = ', cm%clin(cfk%FI)%filefmt
            write(58, *) 'BASINRAINFLAG        = ', cm%clin(cfk%PR)%filefmt
            write(58, *) 'BASINTEMPERATUREFLAG = ', cm%clin(cfk%TT)%filefmt
            write(58, *) 'BASINWINDFLAG        = ', cm%clin(cfk%UV)%filefmt
            write(58, *) 'BASINPRESFLAG        = ', cm%clin(cfk%P0)%filefmt
            write(58, *) 'BASINHUMIDITYFLAG    = ', cm%clin(cfk%HU)%filefmt
            write(58, *) 'HOURLYFLAG           = ', HOURLYFLAG
            write(58, *) 'RESUMEFLAG           = ', RESUMEFLAG
            write(58, *) 'SAVERESUMEFLAG       = ', SAVERESUMEFLAG
            write(58, *) 'SHDFILEFLAG          = ', SHDFILEFLAG
            write(58, *) 'SOILINIFLAG          = ', SOILINIFLAG
            write(58, *) 'STREAMFLOWFLAG       = ', STREAMFLOWFLAG
!-            write(58, *) 'CONFLAGS             = ', CONFLAGS
            write(58, *) 'RELFLG               = ', RELFLG
!-            write(58, *) 'OPTFLAGS             = ', OPTFLAGS
            write(58, *) 'PREEMPTIONFLAG       = ', mtsflg%PREEMPTIONFLAG
            write(58, *) 'INTERPOLATIONFLAG    = ', INTERPOLATIONFLAG
            write(58, *) 'SUBBASINFLAG         = ', SUBBASINFLAG
            write(58, *) 'TESTCSVFLAG          = ', 'NOTSUPPORTED'
            write(58, *) 'R2COUTPUTFLAG        = ', R2COUTPUTFLAG
            write(58, *) 'OBJFNFLAG            = ', OBJFNFLAG
            write(58, *) 'AUTOCALIBRATIONFLAG  = ', mtsflg%AUTOCALIBRATIONFLAG
            write(58, *) 'WINDOWSIZEFLAG       = ', WINDOWSIZEFLAG
            write(58, *) 'WINDOWSPACINGFLAG    = ', WINDOWSPACINGFLAG
            write(58, *) 'FROZENSOILINFILFLAG  = ', FROZENSOILINFILFLAG
            write(58, *) 'LOCATIONFLAG         = ', LOCATIONFLAG

        !> MAM - ALLOCATE AND INITIALIZE INTERPOLATION VARIABLES:
        !> For 30 minute forcing data there is no need for interpolation and
        !> hence no need to assign PRE and PST variables
            if (INTERPOLATIONFLAG > 1 .or. (INTERPOLATIONFLAG == 1 .and. sum(cm%clin(:)%hf) == 210)) then
                print 9000
                write(58, 9000)
                INTERPOLATIONFLAG = 0
            end if !(INTERPOLATIONFLAG > 1 .or. (INTERPOLATIONFLAG == 1 .and. sum(cm%clin(:)%hf) == 210)) then
!todo: restore this.
!+            write(58, "('WF_NUM_POINTS: ', i5)") WF_NUM_POINTS
!+            write(58, "('Out directory:', 5a10)") (op%DIR_OUT(i), i = 1, WF_NUM_POINTS)
!+            write(58, "('Grid number:  ', 5i10)") (op%N_OUT(i), i = 1, WF_NUM_POINTS)
!+            write(58, "('Land class:   ', 5i10)") (op%II_OUT(i), i = 1, WF_NUM_POINTS)
            write(58, *)
            write(58, "('MESH_parameters_hydrology.ini')")
            write(58, *)
!todo: fix this.
!-            write(58, "('Option flags:')")
!-            if (OPTFLAGS > 0) then
!-                do i = 1, OPTFLAGS
!-                    write(58, '(a11, i2, a19)') 'PARAMETER ', i, ' NOT CURRENTLY USED'
!-                end do
!-            end if
            write(58, "('River roughnesses:')")
!todo: change this to use NRVR
            write(58, '(5f6.3)') (WF_R2(i), i = 1, 5)
            write(58, "('Land class independent hydrologic parameters:')")
            if (FROZENSOILINFILFLAG == 1) then
                write(58, *) 'SOIL_POR_MAX = ', SOIL_POR_MAX
                write(58, *) 'SOIL_DEPTH   = ', SOIL_DEPTH
                write(58, *) 'S0           = ', S0
                write(58, *) 'T_ICE_LENS   = ', T_ICE_LENS
                do i = 5, INDEPPAR
                    j = i - 4
                    write(58, '(a38, i2, a3, f6.2)') 'OPPORTUNITY TIME FOR SIMULATION YEAR ', j, ' = ', t0_ACC(j)
                end do
            else
                do i = 1, INDEPPAR
                    write(58, '(a36, i2, a19)') 'FROZEN SOIL INFILTRATION PARAMETER ', i, ' READ BUT NOT USED'
                end do
            end if !(FROZENSOILINFILFLAG == 1) then
            write(58, "('Land class dependent hydrologic parameters:')")
            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZSNLROW'", NTYPE
            write(58, NMTESTFORMAT) (hp%ZSNLROW(1, m), m = 1, NTYPE)
            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLSROW'", NTYPE
            write(58, NMTESTFORMAT) (hp%ZPLSROW(1, m), m = 1, NTYPE)
            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLGROW'", NTYPE
            write(58, NMTESTFORMAT) (hp%ZPLGROW(1, m), m = 1, NTYPE)
            if (DEPPAR >= 4) then
                write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('FRZCROW'", NTYPE
                write(58, NMTESTFORMAT) (hp%FRZCROW(1, m), m = 1, NTYPE)
            end if
            write(58, *)
            write(58, "('MESH_parameters_CLASS.ini')")
            write(58, *)
            write(58, '(2x, 6a4)') TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6
            write(58, '(2x, 6a4)') NAME1, NAME2, NAME3, NAME4, NAME5, NAME6
            write(58, '(2x, 6a4)') PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6
            i = 1
            write(58, '(5f10.2, f7.1, 3i5)') &
                DEGLAT, DEGLON, cp%ZRFMGRD(i), cp%ZRFHGRD(i), cp%ZBLDGRD(i), cp%GCGRD(i), shd%wc%ILG, NA, NTYPE
            do m = 1, NTYPE
                write(58, '(9f8.3)') (cp%FCANROW(i, m, j), j = 1, ICAN + 1), (cp%PAMXROW(i, m, j), j = 1, ICAN)
                write(58, '(9f8.3)') (cp%LNZ0ROW(i, m, j), j = 1, ICAN + 1), (cp%PAMNROW(i, m, j), j = 1, ICAN)
                write(58, '(9f8.3)') (cp%ALVCROW(i, m, j), j = 1, ICAN + 1), (cp%CMASROW(i, m, j), j = 1, ICAN)
                write(58, '(9f8.3)') (cp%ALICROW(i, m, j), j = 1, ICAN + 1), (cp%ROOTROW(i, m, j), j = 1, ICAN)
                write(58, '(4f8.3, 8x, 4f8.3)') (cp%RSMNROW(i, m, j), j = 1, ICAN), (cp%QA50ROW(i, m, j), j = 1, ICAN)
                write(58, '(4f8.3, 8x, 4f8.3)') (cp%VPDAROW(i, m, j), j = 1, ICAN), (cp%VPDBROW(i, m, j), j = 1, ICAN)
                write(58, '(4f8.3, 8x, 4f8.3)') (cp%PSGAROW(i, m, j), j = 1, ICAN), (cp%PSGBROW(i, m, j), j = 1, ICAN)
                write(58, '(3f8.3, f8.4)') cp%DRNROW(i, m), cp%SDEPROW(i, m), cp%FAREROW(i, m), cp%DDROW(i, m)
                write(58, '(4e8.1, i8)') cp%XSLPROW(i, m), cp%XDROW(i, m), cp%MANNROW(i, m), cp%KSROW(i, m), cp%MIDROW(i, m)
                write(58, '(6f10.1)') (cp%SANDROW(i, m, j), j = 1, IGND)
                write(58, '(6f10.1)') (cp%CLAYROW(i, m, j), j = 1, IGND)
                write(58, '(6f10.1)') (cp%ORGMROW(i, m, j), j = 1, IGND)
                write(58, '(9f10.2)') (cp%TBARROW(i, m, j), j = 1, IGND), cp%TCANROW(i, m), cp%TSNOROW(i, m), cp%TPNDROW(i, m)
                write(58, '(10f10.3)') &
                    (cp%THLQROW(i, m, j), j = 1, IGND), (cp%THICROW(i, m, j), j = 1, IGND), cp%ZPNDROW(i, m)
                write(58, '(2f10.4, f10.2, f10.3, f10.4, f10.3, f10.3)') &
                    cp%RCANROW(i, m), cp%SCANROW(i, m), cp%SNOROW(i, m), cp%ALBSROW(i, m), cp%RHOSROW(i, m), cp%GROROW(i, m)
                write(58, *)
            end do !m = 1, NTYPE
        end if !(MODELINFOOUTFLAG > 0) then
    end if !(ipid == 0) then

!> *********************************************************************
!> Open and print header information to the output files
!> *********************************************************************

    if (ipid == 0) then

!> *********************************************************************
!> Open and read in values from r2c_output.txt file
!> *********************************************************************

        NR2CFILES = 0
        if (R2COUTPUTFLAG >= 1) then
            inquire(file = 'r2c_output.txt', exist = R2COUTPUT)
            if (R2COUTPUT) then
                open(56, file = 'r2c_output.txt', action = 'read')
                read(56, *, iostat = ierr) NR2C, DELTR2C
                if (ierr == 0) then
                    allocate(GRD(NR2C), GAT(NR2C), GRDGAT(NR2C), R2C_ATTRIBUTES(NR2C, 3), stat = ierr)
                    if (ierr /= 0) then
                        print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                            'RECORD AT THE FIRST LINE IN THE r2c_output.txt FILE. ', &
                            'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
                        stop
                    end if
                end if
                if (ierr /= 0 .or. mod(DELTR2C, 30) /= 0) then
                    print 9002
                    stop
                end if
                print *
                print *, 'THE FOLLOWING R2C OUTPUT FILES WILL BE WRITTEN:'
                do i = 1, NR2C
                    read(56, *, iostat = ierr) GRD(i), GAT(i), GRDGAT(i), (R2C_ATTRIBUTES(i, j), j = 1, 3)
                    if (ierr /= 0) then
                        print *, 'ERROR READING r2c_output.txt FILE AT LINE ', i + 1
                        stop
                    else
                        if (GRD(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GRD)    : ', R2C_ATTRIBUTES(i, 3)
                        end if
                        if (GAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GAT)    : ', R2C_ATTRIBUTES(i, 3)
                        end if
                        if (GRDGAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GRDGAT) : ', R2C_ATTRIBUTES(i, 3)
                        end if
                    end if
                end do
                close(56)
            else
                print *
                print *, "r2c_output.txt FILE DOESN'T EXIST. ", &
                    'R2COUTPUTFLAG SHOULD BE SET TO ZERO IF R2C OUTPUTS ARE NOT NEEDED.'
                print *
                stop
            end if
        end if

!> WRITE THE HEADER FOR R2C FILES:
        if (NR2CFILES > 0) then
            call WRITE_R2C_HEADER(NTYPE, NR2C, NR2CFILES, GRD, GAT, GRDGAT, R2C_ATTRIBUTES, &
                                  R2CFILEUNITSTART, NR2CSTATES, shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
                                  shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta, shd%xCount, shd%yCount)
        end if

!> For the ENSIM timestamp
        wfo_seq = 0

    end if !(ipid == 0) then

!> End of ENSIM Changes

!> *********************************************************************
!> Output information to screen
!> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *, 'NUMBER OF GRID SQUARES: ', NA
        print *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NTYPE
        print *, 'NUMBER OF RIVER CLASSES: ', shd%NRVR
        print *, 'MINIMUM NUMBER FOR ILG: ', shd%lc%ILG
        print *, 'NUMBER OF GRID SQUARES IN West-East DIRECTION: ', shd%xCount
        print *, 'NUMBER OF GRID SQUARES IN South-North DIRECTION: ', shd%yCount
        print *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', shd%AL
        print *, 'NUMBER OF DRAINAGE OUTLETS: ', (NA - shd%NAA)
        print *
        print *
        print *
    end if !(ro%VERBOSEMODE > 0) then

    if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_init(ts, stfl%ns)

    !todo: temporary until mpi-friendly RESUMEFLAG/SAVERESUMEFLAG has been implemented.
    if (RESUMEFLAG > 0) then
        stop ' RESUMEFLAG and SAVERESUMEFLAG not supported'
    end if

!>
!>*******************************************************************
!>
!> Check if we are reading in a resume_state.r2c file
!+    if (RESUMEFLAG == 2) then
!+        print *, 'Reading saved state variables'

! Allocate arrays for resume_state_r2c
!+        open(54, file = 'resume_state_r2c.txt', action = 'read')
!+        read(54, *, iostat = ierr) NR2C_R, DELTR2C_R
!+        if (ierr == 0) then
!+            allocate(GRD_R(NR2C_R), GAT_R(NR2C_R), GRDGAT_R(NR2C_R), R2C_ATTRIBUTES_R(NR2C_R, 3), stat = ierr)
!+            if (ierr /= 0) then
!+                print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
!+                    'RECORD AT THE FIRST LINE IN THE resume_state_r2c.txt FILE. ', &
!+                    'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
!+                stop
!+            end if
!+        end if
!+        close(54)

! start by gathering from ROW to GAT so as not to mess-up with CLASSS after call to save_state_r2c
!        call CLASSG (cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                     cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                     cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
!                     csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!                     csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!                     csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!                     csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!                     csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!                     csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, csfv%IGDR, &
!                     csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, cfi%VMOD, &
!                     csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!                     csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!                     csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!                     csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!                     catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!                     cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!                     cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!                     catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!                     catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!                     catv%GGEO, &
!                     cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!                     cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!                     cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!                     cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!                     cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!                     cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!                     cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!                     cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!                     cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!                     cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!                     cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!                     cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!                     cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!BEGIN: PDMROF
!                     CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM, &
!END: PDMROF
!                     shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, NA, NTYPE, &
!                     NML, il1, il2, IGND, ICAN, ICP1, cp%TBARROW, cp%THLQROW, &
!                     cp%THICROW, cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, &
!                     cp%TSNOROW, cp%RHOSROW, cp%SNOROW, cp%TCANROW, &
!                     cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, cp%FCANROW, &
!                     cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
!                     cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, &
!                     cp%QA50ROW, cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, &
!                     cp%PSGBROW, PAIDROW, HGTDROW, ACVDROW, ACIDROW, TSFSROW, &
!                     WSNOROW, THPROW, THRROW, THMROW, BIROW, PSISROW, &
!                     GRKSROW, THRAROW, HCPSROW, TCSROW, IGDRROW, &
!                     THFCROW, PSIWROW, DLZWROW, ZBTWROW, VMODGRD, &
!                     hp%ZSNLROW, hp%ZPLGROW, hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, &
!                     cp%DRNROW, cp%XSLPROW, cp%XDROW, WFSFROW, cp%KSROW, &
!                     ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
!                     AGIDROW, ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
!                     cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, FSVHGRD, &
!                     FSIHGRD, CSZGRD, cm%clin(cfk%FI)%GRD, cm%clin(cfk%UV)%GRD, VLGRD, &
!                     cm%clin(cfk%TT)%GRD, cm%clin(cfk%HU)%GRD, cm%clin(cfk%P0)%GRD, &
!                     cm%clin(cfk%PR)%GRD, PADRGRD, &
!                     VPDGRD, TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, &
!                     SPCPGRD, TSPCGRD, RHSIGRD, FCLOGRD, DLONGRD, &
!                     GGEOGRD, cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                     cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, &
!BEGIN: PDMROF
!                     hp%CMINROW, hp%CMAXROW, hp%BROW, hp%K1ROW, hp%K2ROW, &
!END: PDMROF
!                     cp%FAREROW, csfv%FARE, &
!                     hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
!                     fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT, &
!                     DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                     TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                     DriftROW, SublROW, DepositionROW, &
!                     DriftGAT, SublGAT, DepositionGAT)
!>
!>   * INITIALIZATION OF DIAGNOSTIC VARIABLES SPLIT OUT OF CLASSG
!>   * FOR CONSISTENCY WITH GCM APPLICATIONS.
!>

!> *********************************************************************
!> Set variables arrays to zero.
!> *********************************************************************

!        cdv%CDH = 0.0
!        cdv%CDM = 0.0
!        cdv%HFS = 0.0
!        cdv%TFX = 0.0
!        cdv%QEVP = 0.0
!        cdv%QFS = 0.0
!        cdv%QFX = 0.0
!        cdv%PET = 0.0
!        cdv%GA = 0.0
!        cdv%EF = 0.0
!        cdv%GTE = 0.0
!        cdv%QG = 0.0
!        cdv%ALVS = 0.0
!        cdv%ALIR = 0.0
!        cdv%SFCT = 0.0
!        cdv%SFCU = 0.0
!        cdv%SFCV = 0.0
!        cdv%SFCQ = 0.0
!        cdv%FSNO = 0.0
!        cdv%FSGV = 0.0
!        cdv%FSGS = 0.0
!        cdv%FSGG = 0.0
!        cdv%FLGV = 0.0
!        cdv%FLGS = 0.0
!        cdv%FLGG = 0.0
!        cdv%HFSC = 0.0
!        cdv%HFSS = 0.0
!        cdv%HFSG = 0.0
!        cdv%HEVC = 0.0
!        cdv%HEVS = 0.0
!        cdv%HEVG = 0.0
!        cdv%HMFC = 0.0
!        cdv%HMFN = 0.0
!        cdv%HTCC = 0.0
!        cdv%HTCS = 0.0
!        cdv%PCFC = 0.0
!        cdv%PCLC = 0.0
!        cdv%PCPN = 0.0
!        cdv%PCPG = 0.0
!        cdv%QFG = 0.0
!        cdv%QFN = 0.0
!        cdv%QFCF = 0.0
!        cdv%QFCL = 0.0
!        cdv%ROF = 0.0
!        cdv%ROFO = 0.0
!        cdv%ROFS = 0.0
!        cdv%ROFB = 0.0
!        cdv%TROF = 0.0
!        cdv%TROO = 0.0
!        cdv%TROS = 0.0
!        cdv%TROB = 0.0
!        cdv%ROFC = 0.0
!        cdv%ROFN = 0.0
!        cdv%ROVG = 0.0
!        cdv%WTRC = 0.0
!        cdv%WTRS = 0.0
!        cdv%WTRG = 0.0
!        cdv%DR = 0.0
!        cdv%HMFG = 0.0
!        cdv%HTC = 0.0
!        cdv%QFC = 0.0
!        cdv%GFLX = 0.0
!        ITCTGAT = 0

!+        call resume_state_r2c(shd%lc%NML, NA, NTYPE, ic%ts_daily, &
!+                              MINS_NOW, shd%lc%ACLASS, NR2C_R, GRD_R, GAT_R, GRDGAT_R, R2C_ATTRIBUTES_R, &
!+                              NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, ICAN, ICP1, IGND, &
!+                              cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!+                              cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!+                              cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!+                              csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!+                              csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!+                              csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!+                              csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!+                              csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!+                              csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!+                              csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!+                              csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!+                              csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!+                              csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!+                              csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!+                              catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!+                              cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!+                              cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!+                              catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!+                              catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!+                              catv%GGEO, &
!+                              cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!+                              cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!+                              cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!+                              cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!+                              cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!+                              cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!+                              cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!+                              cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!+                              cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!+                              cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!+                              cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!+                              cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!+                              cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!+                              csfv%SAND, csfv%CLAY, csfv%IGDR, cfi%VMOD, QLWOGAT, &
!+                              shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
!+                              shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)
!>
! now scatter the variables so that the GATs don't get overwritten incorrectly
!        call CLASSS(cp%TBARROW, cp%THLQROW, cp%THICROW, GFLXROW, TSFSROW, &
!                    cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, cp%TSNOROW, &
!                    cp%RHOSROW, cp%SNOROW, cp%TCANROW, cp%RCANROW, cp%SCANROW, &
!                    cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
!                    shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
!                    NA, NTYPE, NML, il1, il2, IGND, ICAN, ICAN + 1, &
!                    cpv%TBAR, cpv%THLQ, cpv%THIC, cdv%GFLX, cpv%TSFS, &
!                    cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%ALBS, cpv%TSNO, &
!                    cpv%RHOS, cpv%SNO, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
!                    cpv%GRO, cpv%CMAI, cpv%TAC, cpv%QAC, cpv%WSNO, &
!                    cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                    cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, cp%XSLPROW, csfv%XSLP, &
!                    DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                    TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                    DriftROW, SublROW, DepositionROW, &
!                    DriftGAT, SublGAT, DepositionGAT)
!>
!>   * SCATTER OPERATION ON DIAGNOSTIC VARIABLES SPLIT OUT OF
!>   * CLASSS FOR CONSISTENCY WITH GCM APPLICATIONS.
!>
!        do 180 k = il1, il2
!            ik = shd%lc%ILMOS(k)
!            jk = shd%lc%JLMOS(k)
!            CDHROW(ik, jk) = cdv%CDH(k)
!            CDMROW(ik, jk) = cdv%CDM(k)
!            HFSROW(ik, jk) = cdv%HFS(k)
!            TFXROW(ik, jk) = cdv%TFX(k)
!            QEVPROW(ik, jk) = cdv%QEVP(k)
!            QFSROW(ik, jk) = cdv%QFS(k)
!            QFXROW(ik, jk) = cdv%QFX(k)
!            PETROW(ik, jk) = cdv%PET(k)
!            GAROW(ik, jk) = cdv%GA(k)
!            EFROW(ik, jk) = cdv%EF(k)
!            GTROW(ik, jk) = cdv%GTE(k)
!            QGROW(ik, jk) = cdv%QG(k)
!            ALVSROW(ik, jk) = cdv%ALVS(k)
!            ALIRROW(ik, jk) = cdv%ALIR(k)
!            SFCTROW(ik, jk) = cdv%SFCT(k)
!            SFCUROW(ik, jk) = cdv%SFCU(k)
!            SFCVROW(ik, jk) = cdv%SFCV(k)
!            SFCQROW(ik, jk) = cdv%SFCQ(k)
!            FSNOROW(ik, jk) = cdv%FSNO(k)
!            FSGVROW(ik, jk) = cdv%FSGV(k)
!            FSGSROW(ik, jk) = cdv%FSGS(k)
!            FSGGROW(ik, jk) = cdv%FSGG(k)
!            FLGVROW(ik, jk) = cdv%FLGV(k)
!            FLGSROW(ik, jk) = cdv%FLGS(k)
!            FLGGROW(ik, jk) = cdv%FLGG(k)
!            HFSCROW(ik, jk) = cdv%HFSC(k)
!            HFSSROW(ik, jk) = cdv%HFSS(k)
!            HFSGROW(ik, jk) = cdv%HFSG(k)
!            HEVCROW(ik, jk) = cdv%HEVC(k)
!            HEVSROW(ik, jk) = cdv%HEVS(k)
!            HEVGROW(ik, jk) = cdv%HEVG(k)
!            HMFCROW(ik, jk) = cdv%HMFC(k)
!            HMFNROW(ik, jk) = cdv%HMFN(k)
!            HTCCROW(ik, jk) = cdv%HTCC(k)
!            HTCSROW(ik, jk) = cdv%HTCS(k)
!            PCFCROW(ik, jk) = cdv%PCFC(k)
!            PCLCROW(ik, jk) = cdv%PCLC(k)
!            PCPNROW(ik, jk) = cdv%PCPN(k)
!            PCPGROW(ik, jk) = cdv%PCPG(k)
!            QFGROW(ik, jk) = cdv%QFG(k)
!            QFNROW(ik, jk) = cdv%QFN(k)
!            QFCLROW(ik, jk) = cdv%QFCL(k)
!            QFCFROW(ik, jk) = cdv%QFCF(k)
!            ROFROW(ik, jk) = cdv%ROF(k)
!            ROFOROW(ik, jk) = cdv%ROFO(k)
!            ROFSROW(ik, jk) = cdv%ROFS(k)
!            ROFBROW(ik, jk) = cdv%ROFB(k)
!            TROFROW(ik, jk) = cdv%TROF(k)
!            TROOROW(ik, jk) = cdv%TROO(k)
!            TROSROW(ik, jk) = cdv%TROS(k)
!            TROBROW(ik, jk) = cdv%TROB(k)
!            ROFCROW(ik, jk) = cdv%ROFC(k)
!            ROFNROW(ik, jk) = cdv%ROFN(k)
!            ROVGROW(ik, jk) = cdv%ROVG(k)
!            WTRCROW(ik, jk) = cdv%WTRC(k)
!            WTRSROW(ik, jk) = cdv%WTRS(k)
!            WTRGROW(ik, jk) = cdv%WTRG(k)
!            DRROW(ik, jk) = cdv%DR(k)
!            WTABROW(ik, jk) = cdv%WTAB(k)
!            ILMOROW(ik, jk) = cdv%ILMO(k)
!            UEROW(ik, jk) = cdv%UE(k)
!            HBLROW(ik, jk) = cdv%HBL(k)
!180     continue
!>
!        do 190 l = 1, IGND
!            do 190 k = il1, il2
!                ik = shd%lc%ILMOS(k)
!                jk = shd%lc%JLMOS(k)
!                HMFGROW(ik, jk, l) = cdv%HMFG(k, l)
!                HTCROW(ik, jk, l) = cdv%HTC(k, l)
!                QFCROW(ik, jk, l) = cdv%QFC(k, l)
!190     continue
!>
!        do 230 m = 1, 50
!            do 220 l = 1, 6
!                do 210 k = il1, il2
!                    ITCTROW(shd%lc%ILMOS(k), shd%lc%JLMOS(k), l, m) = ITCTGAT(k, l, m)
!210     continue
!220     continue
!230     continue
!+    end if !(RESUMEFLAG == 2) then

!> *********************************************************************
!> Call read_init_prog_variables.f90 for initi prognostic variables by
!> by fields needd by classas as initial conditions
!> *********************************************************************
!> bjd - July 14, 2014: Gonzalo Sapriza
!+    if (RESUMEFLAG == 3) then
!+        call read_init_prog_variables_class(CMAIROW, QACROW, TACROW, &
!+                                            TBASROW, TSFSROW, WSNOROW, &
!                                            cp, &
!+                                            NA, NTYPE, &
!+                                            IGND, fls)
!+    end if !(RESUMEFLAG == 3) then

!> *********************************************************************
!> Call CLASSB to set more CLASS variables
!> *********************************************************************
!> bjd - July 25, 2005: For inputting field measured soil properties.

!-    call CLASSB(THPROW, THRROW, THMROW, BIROW, PSISROW, &
!-                GRKSROW, THRAROW, HCPSROW, TCSROW, THFCROW, &
!-                PSIWROW, DLZWROW, ZBTWROW, ALGWROW, ALGDROW, &
!-                cp%SANDROW, cp%CLAYROW , cp%ORGMROW, shd%lc%sl%DELZ, shd%lc%sl%ZBOT, &
!-                cp%SDEPROW, ISNDROW, IGDRROW, NA, NTYPE, &
!-                1, NA, NTYPE, IGND, ICTEMMOD, &
!-                SV%WC_THPOR, SV%WC_THLRET, SV%WC_THLMIN, SV%WC_BI, SV%WC_PSISAT, &
!-                SV%WC_GRKSAT, SV%WC_HCPS, SV%WC_TCS)

!> *********************************************************************
!> MAM - Initialize ENDDATE and ENDDATA
!> *********************************************************************
    ENDDATE = .false.
    ENDDATA = .false.

    call climate_module_loaddata(shd, .true., cm, NML, il1, il2, ENDDATA)

    if (ipid == 0) then

    !> Open CSV output files.
        if (BASINBALANCEOUTFLAG > 0) then

        !> Water balance.
            open(fls%fl(mfk%f900)%iun, &
                 file = './' // trim(fls%GENDIR_OUT) // '/' // trim(adjustl(fls%fl(mfk%f900)%fn)), &
                 iostat = ierr)
!todo: Create this only by flag.
            open(902, file = './' // trim(fls%GENDIR_OUT) // '/Basin_average_water_balance_Monthly.csv')

            wrt_900_1 = 'DAY,YEAR,PREACC' // ',EVAPACC,ROFACC,ROFOACC,' // &
                'ROFSACC,ROFBACC,PRE,EVAP,ROF,ROFO,ROFS,ROFB,SNCAN,RCAN,SNO,WSNO,PNDW,'

            wrt_900_2 = 'LQWS'
            wrt_900_3 = 'FRWS'
            wrt_900_4 = 'ALWS'

            do i = 1, IGND
                write(IGND_CHAR, '(i1)') i
                if (i < IGND) then
                    wrt_900_2 = trim(adjustl(wrt_900_2)) // trim(adjustl(IGND_CHAR)) // ',LQWS'
                    wrt_900_3 = trim(adjustl(wrt_900_3)) // trim(adjustl(IGND_CHAR)) // ',FRWS'
                    wrt_900_4 = trim(adjustl(wrt_900_4)) // trim(adjustl(IGND_CHAR)) // ',ALWS'
                else
                    wrt_900_2 = trim(adjustl(wrt_900_2)) // trim(adjustl(IGND_CHAR)) // ','
                    wrt_900_3 = trim(adjustl(wrt_900_3)) // trim(adjustl(IGND_CHAR)) // ','
                    wrt_900_4 = trim(adjustl(wrt_900_4)) // trim(adjustl(IGND_CHAR)) // ','
                end if
            end do !> i = 1, IGND

            wrt_900_f = trim(adjustl(wrt_900_1)) // &
                trim(adjustl(wrt_900_2)) // &
                trim(adjustl(wrt_900_3)) // &
                trim(adjustl(wrt_900_4)) // &
                'LQWS,FRWS,ALWS,STG,DSTG,DSTGACC'

            write(fls%fl(mfk%f900)%iun, '(a)') trim(adjustl(wrt_900_f))
            write(902, '(a)') trim(adjustl(wrt_900_f))

        !> Energy balance.
            open(901, file = './' // trim(fls%GENDIR_OUT) // '/Basin_average_energy_balance.csv')

            write(901, '(a)') 'DAY,YEAR,HFS,QEVP'

            !> Variables for basin totals.
            wb_out%PRE = 0.0
            eb_out%QEVP = 0.0
            wb_out%EVAP = 0.0
            eb_out%HFS = 0.0
            wb_out%ROF = 0.0
            wb_out%ROFO = 0.0
            wb_out%ROFS = 0.0
            wb_out%ROFB = 0.0
            wb_out%LQWS = 0.0
            wb_out%FRWS = 0.0
            wb_out%RCAN = 0.0
            wb_out%SNCAN = 0.0
            wb_out%SNO = 0.0
            wb_out%WSNO = 0.0
            wb_out%PNDW = 0.0
            wb_out%STG = 0.0
            wb_out%DSTG = 0.0

        end if !(BASINBALANCEOUTFLAG > 0) then

!> *********************************************************************
!> Initialize accumulation variables.
!> *********************************************************************

        !> Grid Variables.
        wb_acc%PRE = 0.0
        eb_acc%QEVP = 0.0
        wb_acc%EVAP = 0.0
        eb_acc%HFS = 0.0
        wb_acc%ROF = 0.0
        wb_acc%ROFO = 0.0
        wb_acc%ROFS = 0.0
        wb_acc%ROFB = 0.0
        spv_acc%TBAR = 0.0
        spv_acc%THLQ = 0.0
        wb_acc%LQWS = 0.0
        spv_acc%THIC = 0.0
        wb_acc%FRWS = 0.0
        eb_acc%GFLX = 0.0
        wb_acc%RCAN = 0.0
        wb_acc%SNCAN = 0.0
        wb_acc%SNO = 0.0
        wb_acc%WSNO = 0.0
        wb_acc%PNDW = 0.0
        wb_acc%STG = 0.0
        wb_acc%DSTG = 0.0

    end if !(ipid == 0) then

!-    call CLASSG(cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!-                cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!-                cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
!-                csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!-                csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!-                csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!-                csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!-                csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!-                csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, csfv%IGDR, &
!-                csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, cfi%VMOD, &
!-                csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!-                csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!-                csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!-                csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!-                catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!-                cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!-                cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!-                catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!-                catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!-                catv%GGEO, &
!-                cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!-                cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!-                cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!-                cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!-                cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!-                cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!-                cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!-                cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!-                cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!-                cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!-                cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!-                cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!-                cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!BEGIN: PDMROF
!-                CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM,  &
!END: PDMROF
!-                shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, NA, NTYPE, &
!-                NML, il1, il2, IGND, ICAN, ICP1, cp%TBARROW, cp%THLQROW, &
!-                cp%THICROW, cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, &
!-                cp%TSNOROW, cp%RHOSROW, cp%SNOROW, cp%TCANROW, &
!-                cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, cp%FCANROW, &
!-                cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
!-                cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, &
!-                cp%QA50ROW, cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, &
!-                cp%PSGBROW, PAIDROW, HGTDROW, ACVDROW, ACIDROW, TSFSROW, &
!-                WSNOROW, THPROW, THRROW, THMROW, BIROW, PSISROW, &
!-                GRKSROW, THRAROW, HCPSROW, TCSROW, IGDRROW, &
!-                THFCROW, PSIWROW, DLZWROW, ZBTWROW, VMODGRD, &
!-                hp%ZSNLROW, hp%ZPLGROW, hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, &
!-                cp%DRNROW, cp%XSLPROW, cp%XDROW, WFSFROW, cp%KSROW, &
!-                ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
!-                AGIDROW, ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
!-                cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, FSVHGRD, &
!-                FSIHGRD, CSZGRD, cm%clin(cfk%FI)%GRD, cm%clin(cfk%UV)%GRD, VLGRD, &
!-                cm%clin(cfk%TT)%GRD, cm%clin(cfk%HU)%GRD, cm%clin(cfk%P0)%GRD, cm%clin(cfk%PR)%GRD, PADRGRD, &
!-                VPDGRD, TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, &
!-                SPCPGRD, TSPCGRD, RHSIGRD, FCLOGRD, DLONGRD, &
!-                GGEOGRD, cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!-                cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, &
!BEGIN: PDMROF
!-                hp%CMINROW, hp%CMAXROW, hp%BROW, hp%K1ROW, hp%K2ROW, &
!END: PDMROF
!-                cp%FAREROW, csfv%FARE, &
!-                hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
!-                fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT, &
!-                DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!-                TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!-                DriftROW, SublROW, DepositionROW, &
!-                DriftGAT, SublGAT, DepositionGAT)

    !> Calculate initial storage.
!todo: Preserve 'initial' initial storage for the case of RESUMEFLAG;
!      but also preserve the initial storage of the time-step and delta
!      storage for the case of RESUMEFLAG.
    if (ipid == 0) then

        !> For grid output.
        do k = il1, il2
            if (csfv%FARE(k) >= 0.0) then
                ik = shd%lc%ILMOS(k)
                wb_grd%stg(ik) = wb_grd%stg(ik) + (cpv%RCAN(k) + cpv%SNCAN(k) + cpv%SNO(k) + cpv%ZPND(k)*RHOW)*csfv%FARE(k)
                if (cpv%SNO(k) > 0.0) wb_grd%stg(ik) = wb_grd%stg(ik) + cpv%WSNO(k)
                do j = 1, IGND
                    wb_grd%stg(ik) = wb_grd%stg(ik) + (cpv%THLQ(k, j)*RHOW + cpv%THIC(k, j)*RHOICE)*csfv%DELZW(k, j)*csfv%FARE(k)
                end do
            end if
        end do

        !> For basin accumulated totals.
        wb_out%STG(1) = sum(wb_grd%stg)

        !> For daily basin totals.
        wb_out%STG(2) = sum(wb_grd%stg)

        !> For monthly basin totals.
        wb_out%STG(3) = sum(wb_grd%stg)

    end if !(ipid == 0) then

!> *********************************************************************
!> End of Initialization
!> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *
        print 2836
        print 2835
    end if !(ro%VERBOSEMODE > 0) then

2836    format(/1x, 'DONE INTITIALIZATION')
2835    format(/1x, 'STARTING MESH')

!> *********************************************************************
!> Start of main loop that is run each half hour
!> *********************************************************************

    do while (.not. ENDDATE .and. .not. ENDDATA)

    !> MAM - Linearly interpolate forcing data for intermediate time steps
        if (INTERPOLATIONFLAG == 1) then
            call climate_module_interpolatedata(shd, csfv%FARE, cm, NML, il1, il2)
        end if

        call run_within_tile(shd, fls, ts, ic, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

! *********************************************************************
! Calculate values for output files and print them out
! *********************************************************************

    !> Send/receive process.
        itag = ic%ts_count*1000
        invars = 14 + 4*IGND

    !> Update the variable count per the active control flags.
        if (SAVERESUMEFLAG == 3) invars = invars + 10 + 4

        if (inp > 1 .and. ipid /= 0) then

        !> Send data back to head-node.

            if (allocated(irqst)) deallocate(irqst)
            if (allocated(imstat)) deallocate(imstat)
            allocate(irqst(invars), imstat(mpi_status_size, invars))
            irqst = mpi_request_null

            i = 1
            call mpi_isend(cfi%PRE(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%QFS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROF(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROFO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROFS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%ROFB(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%SNCAN(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%RCAN(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%ZPND(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%SNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%FSNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cpv%WSNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%HFS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            call mpi_isend(cdv%QEVP(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            do j = 1, IGND
                call mpi_isend(cpv%THLQ(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%THIC(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cdv%GFLX(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TBAR(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
            end do

        !> Send optional variables per the active control flags.
            if (SAVERESUMEFLAG == 3) then
                call mpi_isend(cpv%ALBS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%CMAI(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%GRO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%QAC(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%RHOS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TAC(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TBAS(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TCAN(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TPND(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_isend(cpv%TSNO(il1:il2), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                do j = 1, 4
                    call mpi_isend(cpv%TSFS(il1:il2, j), ilen, mpi_real, 0, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                end do
            end if !(SAVERESUMEFLAG == 3) then

            lstat = .false.
            do while (.not. lstat)
                call mpi_testall(invars, irqst, lstat, imstat, ierr)
            end do

!            print *, ipid, ' done sending'

        else if (inp > 1) then

        !> Receive data from worker nodes.
            if (allocated(irqst)) deallocate(irqst)
            if (allocated(imstat)) deallocate(imstat)
            allocate(irqst(invars), imstat(mpi_status_size, invars))

        !> Receive and assign variables.
            do u = 1, (inp - 1)

!                print *, 'initiating irecv for:', u, ' with ', itag

                irqst = mpi_request_null
                imstat = 0

                call GetIndices(inp, izero, u, shd%lc%NML, shd%lc%ILMOS, ii1, ii2, iilen)

                i = 1
                call mpi_irecv(cfi%PRE(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%QFS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROF(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROFO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROFS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%ROFB(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%SNCAN(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%RCAN(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%ZPND(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%SNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%FSNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cpv%WSNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%HFS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                call mpi_irecv(cdv%QEVP(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                do j = 1, IGND
                    call mpi_irecv(cpv%THLQ(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%THIC(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cdv%GFLX(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TBAR(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                end do

            !> Send optional variables per the active control flags.
                if (SAVERESUMEFLAG == 3) then
                    call mpi_irecv(cpv%ALBS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%CMAI(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%GRO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%QAC(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%RHOS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TAC(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TBAS(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TCAN(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TPND(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    call mpi_irecv(cpv%TSNO(ii1:ii2), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr); i = i + 1
                    do j = 1, 4
                        call mpi_irecv(cpv%TSFS(ii1:ii2, j), iilen, mpi_real, u, itag + i, mpi_comm_world, irqst(i), ierr)
                        i = i + 1
                    end do
                end if !(SAVERESUMEFLAG == 3) then

                lstat = .false.
                do while (.not. lstat)
                    call mpi_testall(invars, irqst, lstat, imstat, ierr)
                end do

            end do !u = 1, (inp - 1)
!            print *, 'done receiving'

        end if !(inp > 1 .and. ipid /= 0) then

!todo: change this to use mod.
        if (inp > 1 .and. ic%ts_daily == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

!> *********************************************************************
!> Start of book-keeping and grid accumulation.
!> *********************************************************************

        if (ipid == 0) then

!> Write ENSIM output
!> -----------------------------------------------------c
!>
            if (NR2CFILES > 0 .and. mod(ic%ts_daily*30, DELTR2C) == 0) then
                call FIND_MONTH (JDAY_NOW, YEAR_NOW, ensim_month)
                call FIND_DAY (JDAY_NOW, YEAR_NOW, ensim_day)
                call WRITE_R2C_DATA(shd%lc%NML, NA, NTYPE, ic%ts_daily, MINS_NOW, shd%lc%ACLASS, &
                                    NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, &
                                    NR2C, NR2CFILES, R2CFILEUNITSTART, GRD, GAT, &
                                    GRDGAT, NR2CSTATES, R2C_ATTRIBUTES, FRAME_NO_NEW, YEAR_NOW, &
                                    ensim_MONTH, ensim_DAY, HOUR_NOW, MINS_NOW, ICAN, &
                                    ICAN + 1, IGND, &
                                    cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
                                    cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
                                    cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
                                    csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
                                    csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
                                    csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
                                    csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
                                    csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
                                    csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
                                    csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
                                    csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
                                    csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
                                    csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
                                    csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
                                    catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
                                    cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
                                    cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
                                    catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
                                    catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
                                    catv%GGEO, &
                                    cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
                                    cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
                                    cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
                                    cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
                                    cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
                                    cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
                                    cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
                                    cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
                                    cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
                                    cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
                                    cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
                                    cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
                                    cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
                                    csfv%IGDR, cfi%VMOD, QLWOGAT)
                FRAME_NO_NEW = FRAME_NO_NEW + 1 !UPDATE COUNTERS
            end if

!> =======================================================================
!>     * CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.

    !> Grid data for output.
            md_grd%fsdown = cm%clin(cfk%FB)%GRD
            md_grd%fsvh = fsvhgrd
            md_grd%fsih = fsihgrd
            md_grd%fdl = cm%clin(cfk%FI)%GRD
            md_grd%ul = cm%clin(cfk%UV)%GRD
            md_grd%ta = cm%clin(cfk%TT)%GRD
            md_grd%qa = cm%clin(cfk%HU)%GRD
            md_grd%pres = cm%clin(cfk%P0)%GRD
            md_grd%pre = cm%clin(cfk%PR)%GRD
            wb_grd%PRE = 0.0
            eb_grd%QEVP = 0.0
            wb_grd%EVAP = 0.0
            eb_grd%HFS = 0.0
            wb_grd%ROF = 0.0
            wb_grd%ROFO = 0.0
            wb_grd%ROFS =  0.0
            wb_grd%ROFB = 0.0
            spv_grd%TBAR = 0.0
            spv_grd%THLQ = 0.0
            wb_grd%LQWS = 0.0
            spv_grd%THIC = 0.0
            wb_grd%FRWS = 0.0
            eb_grd%GFLX = 0.0
            wb_grd%RCAN = 0.0
            wb_grd%SNCAN = 0.0
            wb_grd%SNO = 0.0
            wb_grd%WSNO = 0.0
            wb_grd%PNDW = 0.0
            wb_grd%DSTG = wb_grd%STG
            wb_grd%STG = 0.0

            !$omp parallel do
            do k = il1, il2
                if (csfv%FARE(k) > 0.0) then
                    ik = shd%lc%ILMOS(k)
                    wb_grd%PRE(ik) = wb_grd%PRE(ik) + cfi%PRE(k)*csfv%FARE(k)*ic%dts
                    eb_grd%QEVP(ik) = eb_grd%QEVP(ik) + cdv%QEVP(k)*csfv%FARE(k)
                    wb_grd%EVAP(ik) = wb_grd%EVAP(ik) + cdv%QFS(k)*csfv%FARE(k)*ic%dts
                    eb_grd%HFS(ik)  = eb_grd%HFS(ik) + cdv%HFS(k)*csfv%FARE(k)
                    wb_grd%ROF(ik) = wb_grd%ROF(ik) + cdv%ROF(k)*csfv%FARE(k)*ic%dts
                    wb_grd%ROFO(ik) = wb_grd%ROFO(ik) + cdv%ROFO(k)*csfv%FARE(k)*ic%dts
                    wb_grd%ROFS(ik) = wb_grd%ROFS(ik) + cdv%ROFS(k)*csfv%FARE(k)*ic%dts
                    wb_grd%ROFB(ik) = wb_grd%ROFB(ik) + cdv%ROFB(k)*csfv%FARE(k)*ic%dts
                    do j = 1, IGND
                        spv_grd%TBAR(ik, j) = spv_grd%TBAR(ik, j) + cpv%TBAR(k, j)*shd%lc%ACLASS(ik, shd%lc%JLMOS(k))
                        spv_grd%THLQ(ik, j) = spv_grd%THLQ(ik, j) + cpv%THLQ(k, j)*csfv%FARE(k)
                        wb_grd%LQWS(ik, j) = wb_grd%LQWS(ik, j) + cpv%THLQ(k, j)*csfv%DELZW(k, j)*csfv%FARE(k)*RHOW
                        spv_grd%THIC(ik, j) = spv_grd%THIC(ik, j) + cpv%THIC(k, j)*csfv%FARE(k)
                        wb_grd%FRWS(ik, j) = wb_grd%FRWS(ik, j) + cpv%THIC(k, j)*csfv%DELZW(k, j)*csfv%FARE(k)*RHOICE
                        eb_grd%GFLX(ik, j) = eb_grd%GFLX(ik, j) + cdv%GFLX(k, j)*csfv%FARE(k)
                    end do
                    wb_grd%RCAN(ik) = wb_grd%RCAN(ik) + cpv%RCAN(k)*csfv%FARE(k)
                    wb_grd%SNCAN(ik) = wb_grd%SNCAN(ik) + cpv%SNCAN(k)*csfv%FARE(k)
                    wb_grd%SNO(ik) = wb_grd%SNO(ik) + cpv%SNO(k)*csfv%FARE(k)
                    if (cpv%SNO(k) > 0.0) then
                        wb_grd%WSNO(ik) = wb_grd%WSNO(ik) + cpv%WSNO(k)*csfv%FARE(k)
                    end if
                    wb_grd%PNDW(ik) = wb_grd%PNDW(ik) + cpv%ZPND(k)*csfv%FARE(k)*RHOW
                end if
            end do !k = il1, il2

            wb_grd%DSTG = wb_grd%RCAN + wb_grd%SNCAN + wb_grd%SNO + wb_grd%WSNO + wb_grd%PNDW + &
                sum(wb_grd%LQWS, 2) + sum(wb_grd%FRWS, 2) - wb_grd%STG
            wb_grd%STG = wb_grd%DSTG + wb_grd%STG

    !> Update output data.
            call updatefieldsout_temp(shd, ts, ic, ifo, &
                                      md_grd, wb_grd, &
                                      vr)

!> =======================================================================
!> ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.

            wb_acc%PRE = wb_acc%PRE + wb_grd%PRE
            eb_acc%QEVP = eb_acc%QEVP + eb_grd%QEVP
            wb_acc%EVAP = wb_acc%EVAP + wb_grd%EVAP
            eb_acc%HFS  = eb_acc%HFS + eb_grd%HFS
            wb_acc%ROF = wb_acc%ROF + wb_grd%ROF
            wb_acc%ROFO = wb_acc%ROFO + wb_grd%ROFO
            wb_acc%ROFS = wb_acc%ROFS + wb_grd%ROFS
            wb_acc%ROFB = wb_acc%ROFB + wb_grd%ROFB
            spv_acc%TBAR = spv_acc%TBAR + spv_grd%TBAR
            spv_acc%THLQ = spv_acc%THLQ + spv_grd%THLQ
!            wb_acc%LQWS = wb_acc%LQWS + wb_grd%LQWS
            spv_acc%THIC = spv_acc%THIC + spv_grd%THIC
!            wb_acc%FRWS = wb_acc%FRWS + wb_grd%FRWS
            eb_acc%GFLX = eb_acc%GFLX + eb_grd%GFLX
!            wb_acc%RCAN = wb_acc%RCAN + wb_grd%RCAN
!            wb_acc%SNCAN = wb_acc%SNCAN + wb_grd%SNCAN
!            wb_acc%SNO = wb_acc%SNO + wb_grd%SNO
!            wb_acc%WSNO = wb_acc%WSNO + wb_grd%WSNO
!            wb_acc%PNDW = wb_acc%PNDW + wb_grd%PNDW

!> CALCULATE AND PRINT DAILY AVERAGES.
            if (ic%ts_daily == 48) then !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

!                wb_acc%PRE = wb_acc%PRE
                eb_acc%QEVP = eb_acc%QEVP/real(ic%ts_daily)
!                wb_acc%EVAP = wb_acc%EVAP
                eb_acc%HFS = eb_acc%HFS/real(ic%ts_daily)
!                wb_acc%ROF = wb_acc%ROF
!                wb_acc%ROFO = wb_acc%ROFO
!                wb_acc%ROFS = wb_acc%ROFS
!                wb_acc%ROFB = wb_acc%ROFB
                spv_acc%TBAR = spv_acc%TBAR/real(ic%ts_daily)
                spv_acc%THLQ = spv_acc%THLQ/real(ic%ts_daily)
!                wb_acc%LQWS = wb_acc%LQWS/real(ic%ts_daily)
                spv_acc%THIC = spv_acc%THIC/real(ic%ts_daily)
!                wb_acc%FRWS = wb_acc%FRWS/real(ic%ts_daily)
                eb_acc%GFLX = eb_acc%GFLX/real(ic%ts_daily)
!                wb_acc%RCAN = wb_acc%RCAN/real(ic%ts_daily)
!                wb_acc%SNCAN = wb_acc%SNCAN/real(ic%ts_daily)
!                wb_acc%SNO = wb_acc%SNO/real(ic%ts_daily)
!                wb_acc%WSNO = wb_acc%WSNO/real(ic%ts_daily)
!                wb_acc%PNDW = wb_acc%PNDW/real(ic%ts_daily)

                wb_acc%LQWS = wb_grd%LQWS
                wb_acc%FRWS = wb_grd%FRWS
                wb_acc%RCAN = wb_grd%RCAN
                wb_acc%SNCAN = wb_grd%SNCAN
                wb_acc%SNO = wb_grd%SNO
                wb_acc%WSNO = wb_grd%WSNO
                wb_acc%PNDW = wb_grd%PNDW

    !> Write output CSV files.
                if (BASINBALANCEOUTFLAG > 0) then

                    wb_out%PRE(1) = wb_out%PRE(1) + sum(wb_acc%PRE)
                    wb_out%EVAP(1) = wb_out%EVAP(1) + sum(wb_acc%EVAP)
                    wb_out%ROF(1) = wb_out%ROF(1) + sum(wb_acc%ROF)
                    wb_out%ROFO(1) = wb_out%ROFO(1) + sum(wb_acc%ROFO)
                    wb_out%ROFS(1) = wb_out%ROFS(1) + sum(wb_acc%ROFS)
                    wb_out%ROFB(1) = wb_out%ROFB(1) + sum(wb_acc%ROFB)

                    wb_out%PRE(2) = sum(wb_acc%PRE)
                    eb_out%QEVP(2) = sum(eb_acc%QEVP)
                    wb_out%EVAP(2) = sum(wb_acc%EVAP)
                    eb_out%HFS(2) = sum(eb_acc%HFS)
                    wb_out%ROF(2) = sum(wb_acc%ROF)
                    wb_out%ROFO(2) = sum(wb_acc%ROFO)
                    wb_out%ROFS(2) = sum(wb_acc%ROFS)
                    wb_out%ROFB(2) = sum(wb_acc%ROFB)
                    wb_out%LQWS(2, :) = sum(wb_acc%LQWS, 1)
                    wb_out%FRWS(2, :) = sum(wb_acc%FRWS, 1)
                    wb_out%RCAN(2) = sum(wb_acc%RCAN)
                    wb_out%SNCAN(2) = sum(wb_acc%SNCAN)
                    wb_out%SNO(2) = sum(wb_acc%SNO)
                    wb_out%WSNO(2) = sum(wb_acc%WSNO)
                    wb_out%PNDW(2) = sum(wb_acc%PNDW)

                    wb_out%DSTG(2) = sum(wb_grd%STG) - wb_out%STG(2)
                    wb_out%STG(2) = sum(wb_grd%STG)

        !> Water balance.
                    write(fls%fl(mfk%f900)%iun, "(i4,',', i5,',', 999(e14.6,','))") &
                          JDAY_NOW, YEAR_NOW, &
                          wb_out%PRE(1)/wb_out%basin_area, &
                          wb_out%EVAP(1)/wb_out%basin_area, &
                          wb_out%ROF(1)/wb_out%basin_area, &
                          wb_out%ROFO(1)/wb_out%basin_area, &
                          wb_out%ROFS(1)/wb_out%basin_area, &
                          wb_out%ROFB(1)/wb_out%basin_area, &
                          wb_out%PRE(2)/wb_out%basin_area, &
                          wb_out%EVAP(2)/wb_out%basin_area, &
                          wb_out%ROF(2)/wb_out%basin_area, &
                          wb_out%ROFO(2)/wb_out%basin_area, &
                          wb_out%ROFS(2)/wb_out%basin_area, &
                          wb_out%ROFB(2)/wb_out%basin_area, &
                          wb_out%SNCAN(2)/wb_out%basin_area, &
                          wb_out%RCAN(2)/wb_out%basin_area, &
                          wb_out%SNO(2)/wb_out%basin_area, &
                          wb_out%WSNO(2)/wb_out%basin_area, &
                          wb_out%PNDW(2)/wb_out%basin_area, &
                          (wb_out%LQWS(2, j)/wb_out%basin_area, j = 1, IGND), &
                          (wb_out%FRWS(2, j)/wb_out%basin_area, j = 1, IGND), &
                          ((wb_out%LQWS(2, j) + wb_out%FRWS(2, j))/wb_out%basin_area, j = 1, IGND), &
                          sum(wb_out%LQWS(2, :))/wb_out%basin_area, &
                          sum(wb_out%FRWS(2, :))/wb_out%basin_area, &
                          (sum(wb_out%LQWS(2, :)) + sum(wb_out%FRWS(2, :)))/wb_out%basin_area, &
                          wb_out%STG(2)/wb_out%basin_area, &
                          (wb_out%DSTG(2))/wb_out%basin_area, &
                          (wb_out%STG(2) - wb_out%STG(1))/wb_out%basin_area

        !> Energy balance.
                    write(901, "(i4,',', i5,',', 999(e12.5,','))") &
                          JDAY_NOW, YEAR_NOW, &
                          eb_out%HFS(2)/wb_out%basin_area, &
                          eb_out%QEVP(2)/wb_out%basin_area

        ! Monthly totals.
                    wb_out%PRE(3) = wb_out%PRE(3) + wb_out%PRE(2)
                    wb_out%EVAP(3) = wb_out%EVAP(3) + wb_out%EVAP(2)
                    wb_out%ROF(3) = wb_out%ROF(3) + wb_out%ROF(2)
                    wb_out%ROFO(3) = wb_out%ROFO(3) + wb_out%ROFO(2)
                    wb_out%ROFS(3) = wb_out%ROFS(3) + wb_out%ROFS(2)
                    wb_out%ROFB(3) = wb_out%ROFB(3) + wb_out%ROFB(2)

        ! Write out monthly totals.
                    if (ic%now_day == 1) then

                        wb_out%LQWS(3, :) = sum(wb_acc%LQWS, 1)
                        wb_out%FRWS(3, :) = sum(wb_acc%FRWS, 1)
                        wb_out%RCAN(3) = sum(wb_acc%RCAN)
                        wb_out%SNCAN(3) = sum(wb_acc%SNCAN)
                        wb_out%SNO(3) = sum(wb_acc%SNO)
                        wb_out%WSNO(3) = sum(wb_acc%WSNO)
                        wb_out%PNDW(3) = sum(wb_acc%PNDW)

                        wb_out%DSTG(3) = sum(wb_grd%STG) - wb_out%STG(3)
                        wb_out%STG(3) = sum(wb_grd%STG)

                        write(902, "(i4,',', i5,',', 999(e14.6,','))") &
                              JDAY_NOW, YEAR_NOW, &
                              wb_out%PRE(1)/wb_out%basin_area, &
                              wb_out%EVAP(1)/wb_out%basin_area, &
                              wb_out%ROF(1)/wb_out%basin_area, &
                              wb_out%ROFO(1)/wb_out%basin_area, &
                              wb_out%ROFS(1)/wb_out%basin_area, &
                              wb_out%ROFB(1)/wb_out%basin_area, &
                              wb_out%PRE(3)/wb_out%basin_area, &
                              wb_out%EVAP(3)/wb_out%basin_area, &
                              wb_out%ROF(3)/wb_out%basin_area, &
                              wb_out%ROFO(3)/wb_out%basin_area, &
                              wb_out%ROFS(3)/wb_out%basin_area, &
                              wb_out%ROFB(3)/wb_out%basin_area, &
                              wb_out%SNCAN(3)/wb_out%basin_area, &
                              wb_out%RCAN(3)/wb_out%basin_area, &
                              wb_out%SNO(3)/wb_out%basin_area, &
                              wb_out%WSNO(3)/wb_out%basin_area, &
                              wb_out%PNDW(3)/wb_out%basin_area, &
                              (wb_out%LQWS(3, j)/wb_out%basin_area, j = 1, IGND), &
                              (wb_out%FRWS(3, j)/wb_out%basin_area, j = 1, IGND), &
                              ((wb_out%LQWS(3, j) + wb_out%FRWS(3, j))/wb_out%basin_area, j = 1, IGND), &
                              sum(wb_out%LQWS(3, :))/wb_out%basin_area, &
                              sum(wb_out%FRWS(3, :))/wb_out%basin_area, &
                              (sum(wb_out%LQWS(3, :)) + sum(wb_out%FRWS(3, :)))/wb_out%basin_area, &
                              wb_out%STG(3)/wb_out%basin_area, &
                              (wb_out%DSTG(3))/wb_out%basin_area, &
                              (wb_out%STG(3) - wb_out%STG(1))/wb_out%basin_area

                        wb_out%PRE(3) = 0.0
                        wb_out%EVAP(3) = 0.0
                        wb_out%ROF(3) = 0.0
                        wb_out%ROFO(3) = 0.0
                        wb_out%ROFS(3) = 0.0
                        wb_out%ROFB(3) = 0.0

                    end if

                end if !(BASINBALANCEOUTFLAG > 0) then

                !> Calculate storage terms.
                wb_acc%DSTG = wb_grd%DSTG
                wb_acc%STG = wb_grd%STG

                if (OUTFIELDSFLAG == 1) then
                    call UpdateFIELDSOUT(vr, ts, ifo, &
                                         wb_acc%pre, wb_acc%evap, wb_acc%rof, wb_acc%dstg, &
                                         spv_acc%tbar, wb_acc%lqws, wb_acc%frws, &
                                         wb_acc%rcan, wb_acc%sncan, &
                                         wb_acc%pndw, wb_acc%sno, wb_acc%wsno, &
                                         eb_acc%gflx, eb_acc%hfs, eb_acc%qevp, &
                                         spv_acc%thlq, spv_acc%thic, &
                                         IGND, &
                                         JDAY_NOW, YEAR_NOW)
                end if

                wb_acc%PRE = 0.0
                eb_acc%QEVP = 0.0
                wb_acc%EVAP = 0.0
                eb_acc%HFS = 0.0
                wb_acc%ROF = 0.0
                wb_acc%ROFO = 0.0
                wb_acc%ROFS =  0.0
                wb_acc%ROFB = 0.0
                spv_acc%TBAR = 0.0
                spv_acc%THLQ = 0.0
                wb_acc%LQWS = 0.0
                spv_acc%THIC = 0.0
                wb_acc%FRWS = 0.0
                eb_acc%GFLX = 0.0
                wb_acc%RCAN = 0.0
                wb_acc%SNCAN = 0.0
                wb_acc%SNO = 0.0
                wb_acc%WSNO = 0.0
                wb_acc%PNDW = 0.0

            end if !(ic%ts_daily == 48) then
        end if !(ipid == 0) then

        if (ipid == 0) call run_between_grid(shd, fls, ts, ic, cm, wb_grd, eb_grd, spv_grd, stfl, rrls, &
                                             WF_R1, WF_R2, M_C)

!> *********************************************************************
!> Call routing routine
!> *********************************************************************

        if (ipid == 0) then

!-            if (JAN == 1) then
!>     this is done so that INIT_STORE is not recalculated for
!>     each iteration when wf_route is not used
!-                JAN = 2
!-            end if

!> *********************************************************************
!> Write output to console.
!> *********************************************************************

            if (ic%ts_daily == 48) then !48 is the last half-hour period of the day
                      ! when they're numbered 1-48

                if (ro%VERBOSEMODE > 0) then
                    write(6, '(2i5)', advance = 'no') YEAR_NOW, JDAY_NOW
                    if (printoutstfl) then
                        do j = 1, stfl%ns
                            if (printoutqhyd) write(6, '(f10.3)', advance = 'no') stfl%qhyd(j)
                            write(6, '(f10.3)', advance = 'no') stfl%qsyn(j)
                        end do
                    end if
!todo: restore this.
!                    j = ceiling(real(NA)/2); if (WF_NUM_POINTS > 0) j = op%N_OUT(1)
                    j = shd%NAA
                    if (printoutwb) write(6, '(3(f10.3))', advance = 'no') wb_acc%pre(j), wb_acc%evap(j), wb_acc%rof(j)
                    write(6, *)
                end if !(ro%VERBOSEMODE > 0) then
                if (mtsflg%AUTOCALIBRATIONFLAG > 0) then
                    call stats_update_stfl_daily(stfl%qhyd, stfl%qsyn)
                    if (mtsflg%PREEMPTIONFLAG > 1) then
                        if (FTEST > FBEST) goto 199
                    end if
                end if

            end if !(ic%ts_daily == 48) then
        end if !(ipid == 0) then

5176    format(2i5, 999(f10.3))

! *********************************************************************
! Update time counters and return to beginning of main loop
! *********************************************************************
!-        NCOUNT = NCOUNT + 1 !todo: does this work with hourly forcing data?
!-        if (NCOUNT > 48) then !48 is the last half-hour period of the day
!-                      ! when they're numbered 1-48
!-            NCOUNT = 1
!-        end if

        MINS_NOW = MINS_NOW + TIME_STEP_MINS ! increment the current time by 30 minutes
        if (MINS_NOW == 60) then
            MINS_NOW = 0
            HOUR_NOW = HOUR_NOW + 1
            if (HOUR_NOW == 24) then
                HOUR_NOW = 0
                JDAY_NOW = JDAY_NOW + 1
                if (JDAY_NOW >= 366) then
                    if (mod(YEAR_NOW, 400) == 0) then !LEAP YEAR
                        if (JDAY_NOW == 367) then
                            JDAY_NOW = 1
                            YEAR_NOW = YEAR_NOW + 1
                        end if
                    else if (mod(YEAR_NOW, 100) == 0) then !NOT A LEAP YEAR
                        JDAY_NOW = 1
                        YEAR_NOW = YEAR_NOW + 1
                    else if (mod(YEAR_NOW, 4) == 0) then !LEAP YEAR
                        if (JDAY_NOW == 367) then
                            JDAY_NOW = 1
                            YEAR_NOW = YEAR_NOW + 1
                        end if
                    else !NOT A LEAP YEAR
                        JDAY_NOW = 1
                        YEAR_NOW = YEAR_NOW + 1
                    end if
                end if
            end if
        end if

!> check if we should terminate the run yet
        if (YEAR_NOW >= YEAR_STOP .and. YEAR_STOP > 0) then
            if (YEAR_NOW > YEAR_STOP) then
                ENDDATE = .true.
            else if (YEAR_NOW == YEAR_STOP .and. JDAY_NOW >= JDAY_STOP) then
                if (JDAY_NOW > JDAY_STOP) then
                    ENDDATE = .true.
                else if (JDAY_NOW == JDAY_STOP .and. HOUR_NOW >= HOUR_STOP) then
                    if (HOUR_NOW > HOUR_STOP) then
                        ENDDATE = .true.
                    else if (HOUR_NOW == HOUR_STOP .and. MINS_NOW >= MINS_STOP) then
                        ENDDATE = .true.
                    end if
                end if
            end if
        end if
        TIME_STEP_NOW = TIME_STEP_NOW + TIME_STEP_MINS
        if (TIME_STEP_NOW == HOURLYFLAG) TIME_STEP_NOW = 0

        call update_now_iter_counter(ic, YEAR_NOW, JDAY_NOW, HOUR_NOW, MINS_NOW)

    !> *********************************************************************
    !> Read in meteorological forcing data
    !> *********************************************************************
        call climate_module_loaddata(shd, .false., cm, NML, il1, il2, ENDDATA)

    end do !while (.not. ENDDATE .and. .not. ENDDATA)

    !> End program if not the head node.
    if (ipid /= 0) then
!        print 4696, ipid
        goto 999

!4696 format (1x, 'Node ', i4, ' is exiting...')

    end if !(ipid /= 0) then

!    call CLASSS(cp%TBARROW, cp%THLQROW, cp%THICROW, GFLXROW, TSFSROW, &
!                cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, cp%TSNOROW, &
!                cp%RHOSROW, cp%SNOROW, cp%TCANROW, cp%RCANROW, cp%SCANROW, &
!                cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
!                shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
!                NA, NTYPE, NML, il1, il2, IGND, ICAN, ICAN + 1, &
!                cpv%TBAR, cpv%THLQ, cpv%THIC, cdv%GFLX, cpv%TSFS, &
!                cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%ALBS, cpv%TSNO, &
!                cpv%RHOS, cpv%SNO, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
!                cpv%GRO, cpv%CMAI, cpv%TAC, cpv%QAC, cpv%WSNO, &
!                cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, cp%XSLPROW, csfv%XSLP, &
!                DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                DriftROW, SublROW, DepositionROW, &
!                DriftGAT, SublGAT, DepositionGAT)
!>
!>   * SCATTER OPERATION ON DIAGNOSTIC VARIABLES SPLIT OUT OF
!>   * CLASSS FOR CONSISTENCY WITH GCM APPLICATIONS.
!>
!    do 380 k = il1, il2
!        ik = shd%lc%ILMOS(k)
!        jk = shd%lc%JLMOS(k)
!        CDHROW(ik, jk) = cdv%CDH(k)
!        CDMROW(ik, jk) = cdv%CDM(k)
!        HFSROW(ik, jk) = cdv%HFS(k)
!        TFXROW(ik, jk) = cdv%TFX(k)
!        QEVPROW(ik, jk) = cdv%QEVP(k)
!        QFSROW(ik, jk) = cdv%QFS(k)
!        QFXROW(ik, jk) = cdv%QFX(k)
!        PETROW(ik, jk) = cdv%PET(k)
!        GAROW(ik, jk) = cdv%GA(k)
!        EFROW(ik, jk) = cdv%EF(k)
!        GTROW(ik, jk) = cdv%GTE(k)
!        QGROW(ik, jk) = cdv%QG(k)
!        ALVSROW(ik, jk) = cdv%ALVS(k)
!        ALIRROW(ik, jk) = cdv%ALIR(k)
!        SFCTROW(ik, jk) = cdv%SFCT(k)
!        SFCUROW(ik, jk) = cdv%SFCU(k)
!        SFCVROW(ik, jk) = cdv%SFCV(k)
!        SFCQROW(ik, jk) = cdv%SFCQ(k)
!        FSNOROW(ik, jk) = cdv%FSNO(k)
!        FSGVROW(ik, jk) = cdv%FSGV(k)
!        FSGSROW(ik, jk) = cdv%FSGS(k)
!        FSGGROW(ik, jk) = cdv%FSGG(k)
!        FLGVROW(ik, jk) = cdv%FLGV(k)
!        FLGSROW(ik, jk) = cdv%FLGS(k)
!        FLGGROW(ik, jk) = cdv%FLGG(k)
!        HFSCROW(ik, jk) = cdv%HFSC(k)
!        HFSSROW(ik, jk) = cdv%HFSS(k)
!        HFSGROW(ik, jk) = cdv%HFSG(k)
!        HEVCROW(ik, jk) = cdv%HEVC(k)
!        HEVSROW(ik, jk) = cdv%HEVS(k)
!        HEVGROW(ik, jk) = cdv%HEVG(k)
!        HMFCROW(ik, jk) = cdv%HMFC(k)
!        HMFNROW(ik, jk) = cdv%HMFN(k)
!        HTCCROW(ik, jk) = cdv%HTCC(k)
!        HTCSROW(ik, jk) = cdv%HTCS(k)
!        PCFCROW(ik, jk) = cdv%PCFC(k)
!        PCLCROW(ik, jk) = cdv%PCLC(k)
!        PCPNROW(ik, jk) = cdv%PCPN(k)
!        PCPGROW(ik, jk) = cdv%PCPG(k)
!        QFGROW(ik, jk) = cdv%QFG(k)
!        QFNROW(ik, jk) = cdv%QFN(k)
!        QFCLROW(ik, jk) = cdv%QFCL(k)
!        QFCFROW(ik, jk) = cdv%QFCF(k)
!        ROFROW(ik, jk) = cdv%ROF(k)
!        ROFOROW(ik, jk) = cdv%ROFO(k)
!        ROFSROW(ik, jk) = cdv%ROFS(k)
!        ROFBROW(ik, jk) = cdv%ROFB(k)
!        TROFROW(ik, jk) = cdv%TROF(k)
!        TROOROW(ik, jk) = cdv%TROO(k)
!        TROSROW(ik, jk) = cdv%TROS(k)
!        TROBROW(ik, jk) = cdv%TROB(k)
!        ROFCROW(ik, jk) = cdv%ROFC(k)
!        ROFNROW(ik, jk) = cdv%ROFN(k)
!        ROVGROW(ik, jk) = cdv%ROVG(k)
!        WTRCROW(ik, jk) = cdv%WTRC(k)
!        WTRSROW(ik, jk) = cdv%WTRS(k)
!        WTRGROW(ik, jk) = cdv%WTRG(k)
!        DRROW(ik, jk) = cdv%DR(k)
!        WTABROW(ik, jk) = cdv%WTAB(k)
!        ILMOROW(ik, jk) = cdv%ILMO(k)
!        UEROW(ik, jk) = cdv%UE(k)
!        HBLROW(ik, jk) = cdv%HBL(k)
!380     continue
!>
!    do 390 l = 1, IGND
!        do 390 k = il1, il2
!            ik = shd%lc%ILMOS(k)
!            jk = shd%lc%JLMOS(k)
!            HMFGROW(ik, jk, l) = cdv%HMFG(k, l)
!            HTCROW(ik, jk, l) = cdv%HTC(k, l)
!            QFCROW(ik, jk, l) = cdv%QFC(k, l)
!390     continue
!>
!    do 430 m = 1, 50
!        do 420 l = 1, 6
!            do 410 k = il1, il2
!                ITCTROW(shd%lc%ILMOS(k), shd%lc%JLMOS(k), l, m) = ITCTGAT(k, l, m)
!410     continue
!420     continue
!430     continue

!> *********************************************************************
!> Run is now over, print final results to the screen and close files
!> *********************************************************************

!> *********************************************************************
!> Save the state of the basin in r2c file format
!> *********************************************************************

!> Write the resume file
!+    if (SAVERESUMEFLAG == 2) then !todo: done: use a flag
!+        print *, 'Saving state variables in r2c file format'

! Allocate arrays for save_state_r2c
!+        open(55, file = 'save_state_r2c.txt', action = 'read')
!+        read(55, *, iostat = ierr) NR2C_S, DELTR2C_S
!+        if (ierr == 0) then
!+            allocate(GRD_S(NR2C_S), GAT_S(NR2C_S), GRDGAT_S(NR2C_S), R2C_ATTRIBUTES_S(NR2C_S, 3), stat = ierr)
!+            if (ierr /= 0) then
!+                print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
!+                    'RECORD AT THE FIRST LINE IN THE save_state_r2c.txt FILE. ', &
!+                    'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
!+                stop
!+            end if
!+        end if
!+        close(55)

!+        call SAVE_STATE_R2C(shd%lc%NML, NA, NTYPE, ic%ts_daily, &
!+                            MINS_NOW, shd%lc%ACLASS, NR2C_S, GRD_S, GAT_S, GRDGAT_S, R2C_ATTRIBUTES_S, &
!+                            NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, ICAN, ICP1, IGND, &
!+                            cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!+                            cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!+                            cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!+                            csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!+                            csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!+                            csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!+                            csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!+                            csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!+                            csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!+                            csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!+                            csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!+                            csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!+                            csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!+                            csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!+                            catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!+                            cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!+                            cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!+                            catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!+                            catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!+                            catv%GGEO, &
!+                            cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!+                            cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!+                            cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!+                            cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!+                            cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!+                            cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!+                            cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!+                            cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!+                            cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!+                            cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!+                            cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!+                            cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!+                            cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!+                            csfv%SAND, csfv%CLAY, csfv%IGDR, cfi%VMOD, QLWOGAT, &
!+                            shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
!+                            shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)
!+    end if !(SAVERESUMEFLAG == 2) then

!> *********************************************************************
!> Call save_init_prog_variables_class.f90 to save initi prognostic variables by
!> by fields needd by classas as initial conditions
!> *********************************************************************

!> bjd - July 14, 2014: Gonzalo Sapriza
!+    if (SAVERESUMEFLAG == 3) then
!> Save the last time step
!+        call save_init_prog_variables_class(CMAIROW, QACROW, TACROW, &
!+                                            TBASROW, TSFSROW, WSNOROW, &
!+                                            cp%ALBSROW, cp%GROROW, cp%RCANROW, &
!+                                            cp%RHOSROW, cp%SCANROW, cp%SNOROW, &
!+                                            cp%TBARROW, cp%TCANROW, cp%THICROW, &
!+                                            cp%THLQROW, cp%TPNDROW, cp%TSNOROW, &
!+                                            cp%ZPNDROW, &
!+                                            NA, NTYPE, IGND, &
!+                                            fls)
!+    end if !(SAVERESUMEFLAG == 3) then

    if (OUTFIELDSFLAG == 1) call write_outputs(shd, fls, ts, ic, ifo, vr)

    if (ENDDATA) print *, 'Reached end of forcing data'
    if (ENDDATE) print *, 'Reached end of simulation date'

!> Calculate final storage
    wb_out%DSTG(1) = 0.0
    do k = il1, il2
        if (csfv%FARE(k) > 0.0) then
            wb_out%DSTG(1) = wb_out%DSTG(1) + (cpv%RCAN(k) + cpv%SNCAN(k) + cpv%SNO(k) + cpv%ZPND(k)*RHOW)*csfv%FARE(k)
            if (cpv%SNO(k) > 0.0) wb_out%DSTG(1) = wb_out%DSTG(1) + cpv%WSNO(k)*csfv%FARE(k)
            do j = 1, IGND
                wb_out%DSTG(1) = wb_out%DSTG(1) + (cpv%THLQ(k, j)*RHOW + cpv%THIC(k, j)*RHOICE)*csfv%DELZW(k, j)*csfv%FARE(k)
            end do
        end if
    end do
    wb_out%DSTG(1) = wb_out%DSTG(1) - wb_out%STG(1)
    wb_out%STG(1) = wb_out%DSTG(1) + wb_out%STG(1)

    !> write out final totals to screen
    if (ro%VERBOSEMODE > 0) then

        print *
        print 5641, 'Total Precipitation         (mm) =', wb_out%PRE(1)/wb_out%basin_area
        print 5641, 'Total Evaporation           (mm) =', wb_out%EVAP(1)/wb_out%basin_area
        print 5641, 'Total Runoff                (mm) =', wb_out%ROF(1)/wb_out%basin_area
        print 5641, 'Storage (Change/Init/Final) (mm) =', &
            wb_out%DSTG(1)/wb_out%basin_area, &
            (wb_out%STG(1) - wb_out%DSTG(1))/wb_out%basin_area, &
            wb_out%STG(1)/wb_out%basin_area
        print *
        print 5641, 'Total Overland flow         (mm) =', wb_out%ROFO(1)/wb_out%basin_area
        print 5641, 'Total Interflow             (mm) =', wb_out%ROFS(1)/wb_out%basin_area
        print 5641, 'Total Baseflow              (mm) =', wb_out%ROFB(1)/wb_out%basin_area
        print *

5641    format(3x, a34, 999(f11.3))
5635    format(1x, 'Program has terminated normally.'/)

    end if !(ro%VERBOSEMODE > 0) then

    print 5635

    !> Write final totals to output file.
    if (MODELINFOOUTFLAG > 0) then

        write(58, *)
        write(58, '(a, f11.3)') '  Total Precipitation         (mm) = ', wb_out%PRE(1)/wb_out%basin_area
        write(58, '(a, f11.3)') '  Total Evaporation           (mm) = ', wb_out%EVAP(1)/wb_out%basin_area
        write(58, '(a, f11.3)') '  Total Runoff                (mm) = ', wb_out%ROF(1)/wb_out%basin_area
        write(58, '(a, 3f11.3)') '  Storage(Change/Init/Final)  (mm) = ', &
            wb_out%DSTG(1)/wb_out%basin_area, &
            (wb_out%STG(1) - wb_out%DSTG(1))/wb_out%basin_area, &
            wb_out%STG(1)/wb_out%basin_area
        write(58, '(a, f11.3)') '  Total Overland flow         (mm) = ', wb_out%ROFO(1)/wb_out%basin_area
        write(58, '(a, f11.3)') '  Total Interflow             (mm) = ', wb_out%ROFS(1)/wb_out%basin_area
        write(58, '(a, f11.3)') '  Total Baseflow              (mm) = ', wb_out%ROFB(1)/wb_out%basin_area
        write(58, *)
        write(58, *)
        write(58, '(a)') 'Program has terminated normally.'
        write(58, *)

        call cpu_time(endprog)
        write(58, "('Time = ', e14.6, ' seconds.')") (endprog - startprog)

    end if !(MODELINFOOUTFLAG > 0) then

199 continue

    if (mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_write()

999 continue

    !> Close model output file.
    close(58)

    !> Close the CSV energy and water balance output files.
    close(fls%fl(mfk%f900)%iun)
    close(901)
    close(902)

9000    format(/1x, 'INTERPOLATIONFLAG IS NOT SPECIFIED CORRECTLY AND IS SET TO 0 BY THE MODEL.', &
               /1x, '0: NO INTERPOLATION OF FORCING DATA.', &
               /1x, '1: LINEARLY INTERPOLATES FORCING DATA FOR INTERMEDIATE TIME STEPS.', &
               /1x, 'NOTE: INTERPOLATIONFLAG SHOULD BE SET TO 0 FOR 30 MINUTE FORCING DATA.', /)

9002    format(/1x, 'ERROR IN READING r2c_output.txt FILE.', &
               /1x, 'THE FIRST RECORD AT THE FIRST LINE IS FOR THE NUMBER OF ALL THE', &
               /1x, 'VARIABLES LISTED IN THE r2c_output.txt FILE.',&
               /1x, 'THE SECOND RECORD AT THE FIRST LINE IS TIME STEP FOR R2C OUTPUT.', &
               /1x, 'IT SHOULD BE AN INTEGER MULTIPLE OF 30.',&
               /1x, 'THE REMAINING RECORDS SHOULD CONTAIN 3 COLUMNS FOR EACH VARIABLE WITH', &
               /1x, 'INTEGER VALUES OF EITHER 0 OR 1,', &
               /1x, 'AND 3 COLUMNS CONTAINING INFORMATION ABOUT THE VARIABLES.', /)

    call mpi_finalize(ierr)

    stop

end program
